{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/bb.css","path":"css/bb.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/contact.png","path":"medias/contact.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","path":"medias/icp.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/minivaline/MiniValine.js","path":"libs/minivaline/MiniValine.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/prism/prism.css","path":"libs/prism/prism.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/xdorg.md","hash":"ec139ccc695929dd6b2bf02af0a0de5dbb7585f4","modified":1639272941870},{"_id":"source/_data/friends.json","hash":"8b454e8017b9fe5f257c8c75c5a39666198bf99d","modified":1639280068404},{"_id":"source/_posts/【Redis】Redis穿透、击穿、雪崩和数据一致性.md","hash":"c4fc3effa13b54c55823d7a37cf881aa9b845e1f","modified":1639277423678},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":499162500000},{"_id":"source/_posts/【Redis】基于Redis的分布式锁实现.md","hash":"c93a5d6700cdf7b9734685d5aba7d1ed2422d8ab","modified":1639277423713},{"_id":"source/_posts/【Redis】深入学习Redis及集群.md","hash":"28f6901965680c310160dc7c01bdb9ea2ac71689","modified":1639277423740},{"_id":"source/_posts/【数据库】MongoDB学习笔记.md","hash":"2dbfad1730ecdc857f8242355ef322c3fcd1f0a9","modified":1639277423432},{"_id":"source/_posts/【数据库】嵌入式SQL语言.md","hash":"87810c4958edf781b15620cdd1e829625add9e27","modified":1639277423464},{"_id":"source/_posts/【安全认证】JSON Web Token 入门.md","hash":"43f7a7761e16c46c1b32dac3249f64035fd129f9","modified":1639277423301},{"_id":"source/_posts/【安全认证】MD5算法加盐实现用户密码加密.md","hash":"67f5b6b2f5f377ba806ad657f6c623e72801beee","modified":1639277423337},{"_id":"source/_posts/【数据库】数据库系统基础.md","hash":"1588341af05ff18b869b1fc73a680fc1884c9332","modified":1639277423494},{"_id":"source/_posts/【数据库】数据库语言SQL.md","hash":"9d5caa47e0c54c5a0a8fcc62dff63a6564e7cef0","modified":1639277423521},{"_id":"source/_posts/【数据库优化】MySQL慢日志查询分析.md","hash":"4cdb2b6236dd339e20313e8187912cf79bc7b211","modified":1639277423550},{"_id":"source/_posts/【数据库优化】MySQL性能优化基础.md","hash":"2a7d151ba74fc950bbf8c4f1d66c6ae71caa7788","modified":1639277423626},{"_id":"source/_posts/【数据库优化】MySQL索引的使用及优化.md","hash":"83f2c60f25ec1c9f329269b9b10703c0ab3c4d38","modified":1639277423602},{"_id":"source/_posts/【杂谈】对开源的理解.md","hash":"a6fe025f11faf418ee73d83caee0aec04bf489a3","modified":1639277423651},{"_id":"source/about/index.md","hash":"be27dfb46a90ac804a80fbea57d879e9d10ab334","modified":1639277469645},{"_id":"source/categories/index.md","hash":"8f17f968622d66719c5d54ff046522295343ce52","modified":1639279965373},{"_id":"source/friends/index.md","hash":"459d76fc5e37fd22244b1203521963aacac52f59","modified":1639280009919},{"_id":"source/movies/index.md","hash":"5120d416e8b44ea24e8dfc285b994f65de4af02b","modified":1639280653632},{"_id":"source/musics/index.md","hash":"17f1243267d9218640c686b31a25da9cb288678f","modified":1639280639516},{"_id":"source/tags/index.md","hash":"10ba6cc88f0c20eab71625f6873e1d3671f5f49c","modified":1639279975652},{"_id":"source/contact/index.md","hash":"9509205962803ccc8b957aeaa18bac881cf79325","modified":1639279994742},{"_id":"source/_posts/【环境配置】Win10下配置Nginx-php7-mysql-5-6.md","hash":"af12a5c611a4fe67d98a4c62f33ce07b7bd9cae2","modified":1639277423401},{"_id":"source/books/index.md","hash":"18c1e24e492f45d4e5c3c6ec94e75eef4ed075ec","modified":1639280622524},{"_id":"source/_posts/【环境配置】Redis与MySQL多实例配置.md","hash":"1b3a3780025d56e4ca92ad8b6601f9060696d266","modified":1639277423373},{"_id":"source/_posts/【数据库优化】MySQL事务处理与并发控制.md","hash":"9774bdc6fb1f3da2d1bf7a04448a8dbc5ee06b7c","modified":1639277423577},{"_id":"themes/hexo-theme-matery/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1639271410555},{"_id":"themes/hexo-theme-matery/README.md","hash":"0366f3d50b18d095b0581e7b5974e3283d693884","modified":1639271410633},{"_id":"themes/hexo-theme-matery/CHANGELOG.md","hash":"084ec8b110a20170d08a0aa5fd8accf601051835","modified":1639271410581},{"_id":"themes/hexo-theme-matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1639271410606},{"_id":"themes/hexo-theme-matery/README_CN.md","hash":"089de96e2165ea2a8a3adf38ebda85b65e7f716e","modified":1639271410724},{"_id":"themes/hexo-theme-matery/languages/zh-HK.yml","hash":"ae34ac0e175c3037675722e436637efbceea32f0","modified":1639271410805},{"_id":"themes/hexo-theme-matery/languages/zh-CN.yml","hash":"a957b05f70265a86a87d922e18488571809d2472","modified":1639271410787},{"_id":"themes/hexo-theme-matery/languages/default.yml","hash":"54ccc01b097c5bf6820f0edfcece1a87b78ab32d","modified":1639271410768},{"_id":"themes/hexo-theme-matery/layout/about.ejs","hash":"41849f9300b8dc47048333fcf4a897dd8a2a13ca","modified":1639271410886},{"_id":"themes/hexo-theme-matery/layout/archive.ejs","hash":"cdac701de8370f9f3794a0eed4165983993a1ca7","modified":1639271410948},{"_id":"themes/hexo-theme-matery/layout/bb.ejs","hash":"21959d702f17a3d98b716daf44c8b5eecd59c7c5","modified":1639271410997},{"_id":"themes/hexo-theme-matery/layout/404.ejs","hash":"9c8ca67377211e5d60fdde272a975faa9a91a22a","modified":1639271410846},{"_id":"themes/hexo-theme-matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1639271411026},{"_id":"themes/hexo-theme-matery/layout/category.ejs","hash":"00019bca11fb46477f22017cb1f5ad8444da0580","modified":1639271411079},{"_id":"themes/hexo-theme-matery/layout/friends.ejs","hash":"92892bab5578ccf758ce57e19fca08be80d0d5b9","modified":1639271411163},{"_id":"themes/hexo-theme-matery/layout/contact.ejs","hash":"19d62e521c4253496db559478db5164ddfd2480e","modified":1639271411116},{"_id":"themes/hexo-theme-matery/layout/index.ejs","hash":"4dc6f08e7709cc04e886be72dbf0d06469f0effc","modified":1639271411223},{"_id":"themes/hexo-theme-matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1639271411395},{"_id":"themes/hexo-theme-matery/layout/tag.ejs","hash":"85a4b05bd8a6ad0f17ff2e97dae56949b379c204","modified":1639271411369},{"_id":"themes/hexo-theme-matery/source/favicon.png","hash":"fb0f42cf4455df07e5c739332a708bad1a76440e","modified":1639290347094},{"_id":"themes/hexo-theme-matery/layout/layout.ejs","hash":"974b44eb3e343cd3ee57ebad34bbb0eff4184400","modified":1639271411282},{"_id":"themes/hexo-theme-matery/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1639271411420},{"_id":"themes/hexo-theme-matery/layout/post.ejs","hash":"90b5a4c1f70e4756db569c15a7c6cad0c77c4500","modified":1639271411324},{"_id":"themes/hexo-theme-matery/layout/_partial/background.ejs","hash":"aef6edeeb11209831a11d8c7f5d59992e2573335","modified":1639271411443},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1639271411530},{"_id":"themes/hexo-theme-matery/layout/_partial/changyan.ejs","hash":"cd919d31564e118c2ee8d5cbfb7d51ee6da15d82","modified":1639271411657},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1639271411492},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover-content.ejs","hash":"28617bf2a35a4269eba6df466acd174e416d2d1e","modified":1639271411582},{"_id":"themes/hexo-theme-matery/layout/_partial/disqus.ejs","hash":"b2dc2c8b5ed56815e55cc2ea54a6dc4eeba2375d","modified":1639271411690},{"_id":"themes/hexo-theme-matery/layout/_partial/gitalk.ejs","hash":"2aa8fbb04b046fa7679092a48372d7e036835dff","modified":1639271411783},{"_id":"themes/hexo-theme-matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1639271411808},{"_id":"themes/hexo-theme-matery/layout/_partial/gitment.ejs","hash":"90f6218512ef2eab63ada7ad2fc766ae635a2297","modified":1639271411838},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1639271411619},{"_id":"themes/hexo-theme-matery/layout/_partial/head.ejs","hash":"f8438ac80df005934a330b029de292d26f0b6ecb","modified":1639271411913},{"_id":"themes/hexo-theme-matery/layout/_partial/header.ejs","hash":"59e38c70f3d8e7165e686e5e84a627835f4321b0","modified":1639271411946},{"_id":"themes/hexo-theme-matery/_config.yml","hash":"2efce9ab732b28b7284d78be52c4377152fffc10","modified":1639283781901},{"_id":"themes/hexo-theme-matery/layout/_partial/footer.ejs","hash":"a5fe98ca80e53f1a4c85026a300de74be2d27a24","modified":1639283823915},{"_id":"themes/hexo-theme-matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1639271411868},{"_id":"themes/hexo-theme-matery/layout/_partial/minivaline.ejs","hash":"5f09386aece8f9cf31f6059bbde79cd6c5171493","modified":1639271412114},{"_id":"themes/hexo-theme-matery/layout/_partial/mobile-nav.ejs","hash":"cb0cb452be1cd1857ba600f04025b506f3b6fc79","modified":1639271412178},{"_id":"themes/hexo-theme-matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1639271412085},{"_id":"themes/hexo-theme-matery/layout/_partial/index-cover.ejs","hash":"76b4a37e0364380b143fdf94bf1a5e6941564414","modified":1639271412054},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail-toc.ejs","hash":"3ff94aff01936242a9f4e1f31adb9b43bfab8d53","modified":1639271412380},{"_id":"themes/hexo-theme-matery/layout/_partial/navigation.ejs","hash":"78b70ff24b3039c871331ebec114b936c1756cc8","modified":1639271412226},{"_id":"themes/hexo-theme-matery/layout/_partial/post-cover.ejs","hash":"d1c873c5de54498c722e155aadb8c0ec39485dfa","modified":1639271412341},{"_id":"themes/hexo-theme-matery/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1639271412251},{"_id":"themes/hexo-theme-matery/layout/_partial/prev-next.ejs","hash":"c76b78782ea82340104fccc089417572e0adece4","modified":1639271412599},{"_id":"themes/hexo-theme-matery/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1639271412492},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail.ejs","hash":"880ebaf78a947631a38ad0b3d65201315845a264","modified":1639271412460},{"_id":"themes/hexo-theme-matery/layout/_partial/reward.ejs","hash":"ffc55bc7e73bc698bfc58d8e3780c336b83282cf","modified":1639271412697},{"_id":"themes/hexo-theme-matery/layout/_partial/reprint-statement.ejs","hash":"0ce3f9361f558b99cc2f059c5e50b0e2a152ae38","modified":1639271412666},{"_id":"themes/hexo-theme-matery/layout/_partial/search.ejs","hash":"150529c9fb9aa8ddb42ec3e02645d301faa2503b","modified":1639271412731},{"_id":"themes/hexo-theme-matery/layout/_partial/social-link.ejs","hash":"6f871bd3a70f720e4e451f1f4f625cbc6d8994a4","modified":1639271412785},{"_id":"themes/hexo-theme-matery/layout/_partial/valine.ejs","hash":"0e4c0a6154aa34007849928ca88f05b6185b256e","modified":1639271412816},{"_id":"themes/hexo-theme-matery/layout/_partial/share.ejs","hash":"c941730a2471d6aab367cbb6e09ed08b56c83143","modified":1639271412756},{"_id":"themes/hexo-theme-matery/layout/_widget/category-cloud.ejs","hash":"1b3df1009234c0112424b497b18b4ad8240b3bc7","modified":1639271412886},{"_id":"themes/hexo-theme-matery/layout/_widget/category-radar.ejs","hash":"1d8747fda89a0b2ca3c7008867cbfeecad0578a6","modified":1639271412916},{"_id":"themes/hexo-theme-matery/layout/_widget/music.ejs","hash":"e9e3e327d5de9d7aeadbde32e1d558652d9e9195","modified":1639271412979},{"_id":"themes/hexo-theme-matery/layout/_widget/my-projects.ejs","hash":"ef60b64021fa349b0048425d858dfcf6c906fede","modified":1639271413049},{"_id":"themes/hexo-theme-matery/layout/_widget/dream.ejs","hash":"9a472ad5591100cdb65d0df9d01034163bd6dd9d","modified":1639271412944},{"_id":"themes/hexo-theme-matery/layout/_widget/my-gallery.ejs","hash":"65a2d2f9722f84c7fd98f6bdf79087a14848ebd8","modified":1639271413014},{"_id":"themes/hexo-theme-matery/layout/_widget/artitalk.ejs","hash":"b14e486f12b9ac42a273b80e4d785fcb94cf04b2","modified":1639271412845},{"_id":"themes/hexo-theme-matery/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1639271413086},{"_id":"themes/hexo-theme-matery/layout/_widget/post-charts.ejs","hash":"ab5f986f428215941aeaa0c88aefd440c47d3bcf","modified":1639271413153},{"_id":"themes/hexo-theme-matery/layout/_widget/post-calendar.ejs","hash":"48821e644bc73553d7c5c56d2e8ee111a70cd776","modified":1639271413123},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1639271413251},{"_id":"themes/hexo-theme-matery/layout/_widget/video.ejs","hash":"a0e002377af2a7f7e4da6d9a644de97adb035925","modified":1639271413312},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-wordcloud.ejs","hash":"487aacb2454d6bf0d21cdb07ddd1fd5ddbca9038","modified":1639271413281},{"_id":"themes/hexo-theme-matery/layout/_widget/recommend.ejs","hash":"8551137e94ca4e2e3b8b63d5626255884cb60cb5","modified":1639271413215},{"_id":"themes/hexo-theme-matery/source/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1639271413462},{"_id":"themes/hexo-theme-matery/source/css/matery.css","hash":"46a87d97fa095ecc120c49f39d85ca502010725f","modified":1639283063024},{"_id":"themes/hexo-theme-matery/source/css/bb.css","hash":"aa15633888c7cf9baea8bb48d796c68b57cf14bf","modified":1639271413361},{"_id":"themes/hexo-theme-matery/source/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1639271413484},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","hash":"af18dd29e58642c18bab9b89541767b494c468dd","modified":1639271413438},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1639271413384},{"_id":"themes/hexo-theme-matery/source/medias/contact.png","hash":"443ea472dd49b74d9d70295837eb381c8c64f02c","modified":1639271416329},{"_id":"themes/hexo-theme-matery/source/js/search.js","hash":"e1482406c58ea2a0eb178d7e4efb2c879cdddc80","modified":1639271413514},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","hash":"fb0f42cf4455df07e5c739332a708bad1a76440e","modified":1639290347094},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1639271416369},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1639271416293},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1639271416311},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1639271416602},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1639271416767},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1639271416672},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1639271416786},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1639271416892},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1639271416943},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1639271416963},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1639271416982},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1639271417001},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1639271417136},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1639271417052},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1639271417089},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1639271413610},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1639271413578},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1639271413642},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1639271413686},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1639271414285},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1639271414314},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","hash":"58587f49516452d819a78d42a87f2f687a2b2ed9","modified":1639275458993},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1639271413545},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1639271414427},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1639271414340},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1639271414453},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1639271414367},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1639271414401},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1639271414479},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1639271414529},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1639271414575},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1639271415111},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1639271415032},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1639271414891},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1639271415143},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1639271415169},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1639271415589},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1639271415778},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1639271415866},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1639271416120},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1639271415805},{"_id":"themes/hexo-theme-matery/source/libs/minivaline/MiniValine.js","hash":"fbb58c37e2c74f127ae0c566afa9b48889aab79f","modified":1639271415740},{"_id":"themes/hexo-theme-matery/source/libs/prism/prism.css","hash":"62e5474893dece076534352f564ceabd6e088a5a","modified":1639271415836},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1639271416155},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1639271413966},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1639271414074},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1639271414025},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1639271414051},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1639271415315},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1639271415345},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1639271415370},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1639271415398},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1639271415425},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1639271415448},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1639271415468},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1639271415551},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1639271415486},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1639271415503},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1639271415901},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1639271416049},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1639271416090},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1639271415929},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1639271415957},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1639271415983},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1639271416009},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1639271416415},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1639271416475},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1639271416455},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1639271416562},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1639271416654},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1639271416582},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1639271416809},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1639271416726},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1639271416622},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1639271416869},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1639271416914},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1639271416828},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1639271417033},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1639271417070},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1639271417155},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.png","hash":"aa58bb3e69b0845a594a288b74627e7f795f0583","modified":1639275431879},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1639271414627},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1639271415079},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1639271415230},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1639271413726},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1639271416201},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1639271413938},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1639271413760},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1639271413886},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1639271413913},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1639271414252},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1639271414228},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1639271416352},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1639271416436},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1639271416518},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1639271414955},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1639271415621},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1639271415693},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1639271413996},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1639271414199},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1639271416538},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1639271416269},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1639271414110},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1639271416499},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1639271413848},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1639271414164},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1639271414857},{"_id":"public/atom.xml","hash":"3181bcf86198eaf8481a2af3eaeae653faa648e7","modified":1639290620863},{"_id":"public/search.xml","hash":"743916893abed2a219fe0118194450e77f204110","modified":1639290620863},{"_id":"public/categories/index.html","hash":"43f2df84f7b280076e92ba6a0a50a8c2425b30df","modified":1639290620863},{"_id":"public/books/index.html","hash":"33f804d82f7b3597aa88c10c0824d25e860bf601","modified":1639290620863},{"_id":"public/friends/index.html","hash":"9d3f2c123368a0e3b7671356031261be8c9779e6","modified":1639290620863},{"_id":"public/contact/index.html","hash":"b0fb7287f9b43ae1d51adaed273796d42ad1a103","modified":1639290620863},{"_id":"public/about/index.html","hash":"15e6bd03dda5b9aeb305235e6d0f2338004506b0","modified":1639290620863},{"_id":"public/musics/index.html","hash":"56d184cb43866b687aaa8b46e3819b6e6d5555f1","modified":1639290620863},{"_id":"public/tags/index.html","hash":"9df5c1796771cc90a02b9d14507dcecc78212b34","modified":1639290620863},{"_id":"public/movies/index.html","hash":"4634f731f1ae4126cfd6ee4f5caa829f162536f6","modified":1639290620863},{"_id":"public/2021/12/12/hello-world/index.html","hash":"6f89a1d9134d7ad2504cb9755ee207ba5691d480","modified":1639290620863},{"_id":"public/2021/12/12/xdorg/index.html","hash":"e21b79c087208812a59a4aa977bbaf1d13fcfc7c","modified":1639290620863},{"_id":"public/2020/02/11/huan-jing-pei-zhi-redis-yu-mysql-duo-shi-li-pei-zhi/index.html","hash":"f41b233e92b9925acc1e784b7429984fd9ea920f","modified":1639290620863},{"_id":"public/2019/12/08/redis-ji-yu-redis-de-fen-bu-shi-suo-shi-xian/index.html","hash":"bb9ec2668af1b9280a3374bcd1f8896e5b30283e","modified":1639290620863},{"_id":"public/2019/09/27/redis-redis-chuan-tou-ji-chuan-xue-beng-he-shu-ju-yi-zhi-xing/index.html","hash":"0c8c02f7049e173a95c0f07f8a1e9f7f7e82d9a3","modified":1639290620863},{"_id":"public/2019/09/20/redis-shen-ru-xue-xi-redis-ji-ji-qun/index.html","hash":"9458236c1abeb2dde0decc8fd79638bcc83dd49c","modified":1639290620863},{"_id":"public/2019/09/07/shu-ju-ku-you-hua-mysql-shi-wu-chu-li-yu-bing-fa-kong-zhi/index.html","hash":"09b614961d997f4c584d36b1f2a71948228ccdeb","modified":1639290620863},{"_id":"public/2019/09/05/shu-ju-ku-you-hua-mysql-suo-yin-de-shi-yong-ji-you-hua/index.html","hash":"2b46f9d9bd048ef0a84a1f220c2d0abb98554215","modified":1639290620863},{"_id":"public/2019/09/01/shu-ju-ku-you-hua-mysql-xing-neng-you-hua-ji-chu/index.html","hash":"99499c829fddbf51a248a3d48c06dd2603870c16","modified":1639290620863},{"_id":"public/2019/08/29/shu-ju-ku-you-hua-mysql-man-ri-zhi-cha-xun-fen-xi/index.html","hash":"e627c7c5aba36e1f349a5d2a1c743bcb9a05065d","modified":1639290620863},{"_id":"public/2019/08/06/an-quan-ren-zheng-json-web-token-ru-men/index.html","hash":"ec7c89f9dc81fd2226acfe853bc8b0ae24c5d9b2","modified":1639290620863},{"_id":"public/2019/07/28/an-quan-ren-zheng-md5-suan-fa-jia-yan-shi-xian-yong-hu-mi-ma-jia-mi/index.html","hash":"2ab2bdd3220a86655bcce062c0803bc5b38c115f","modified":1639290620863},{"_id":"public/2019/07/16/shu-ju-ku-qian-ru-shi-sql-yu-yan/index.html","hash":"6f1ffaacfbed0856c1024c7cbce377d3e1dcec5c","modified":1639290620863},{"_id":"public/2019/07/01/shu-ju-ku-shu-ju-ku-yu-yan-sql/index.html","hash":"0a45d5e66d631fdbb43cede2415f1f2efe400b47","modified":1639290620863},{"_id":"public/2019/06/22/shu-ju-ku-shu-ju-ku-xi-tong-ji-chu/index.html","hash":"ff8cd5cf97adf78dc7153007d4cd3957e7311122","modified":1639290620863},{"_id":"public/2019/04/11/za-tan-dui-kai-yuan-de-li-jie/index.html","hash":"7f2f3741efd0a57e259ecbab38374263a55e3d05","modified":1639290620863},{"_id":"public/2018/10/22/huan-jing-pei-zhi-win10-xia-pei-zhi-nginx-php7-mysql-5-6/index.html","hash":"25c3732b8249d29c2d44a4bc9adc5a646d6c236d","modified":1639290620863},{"_id":"public/2016/07/30/shu-ju-ku-mongodb-xue-xi-bi-ji/index.html","hash":"b9f2b72f18b0ea756edc811fccdad9bd0cbe7091","modified":1639290620863},{"_id":"public/archives/index.html","hash":"36efb4c6ff3496e4ab5e80b08849f9c7ff2f6ff4","modified":1639290620863},{"_id":"public/archives/page/2/index.html","hash":"9e14b515693ed7394bcc76a7ddc8c0a57a7ab0bc","modified":1639290620863},{"_id":"public/archives/2016/index.html","hash":"3c81d34ada1ef46e3ca57edc1821c6a44a0ee028","modified":1639290620863},{"_id":"public/archives/2016/07/index.html","hash":"341881491724f167434bf49723dc301a23b5e09b","modified":1639290620863},{"_id":"public/archives/2018/index.html","hash":"25c0e43059512cd33991d8243a6d8e7de2b42320","modified":1639290620863},{"_id":"public/archives/2018/10/index.html","hash":"3e6505137c669879b8b06f97d18e526d3e48a845","modified":1639290620863},{"_id":"public/archives/2019/index.html","hash":"0345bb71a31e3faa236d56c4abf5e8dfa5d4eff4","modified":1639290620863},{"_id":"public/archives/2019/page/2/index.html","hash":"3cb5be8d514c4e7e913c76ad00277970a4a6bd03","modified":1639290620863},{"_id":"public/archives/2019/04/index.html","hash":"49889787edc2b173d273cb9a6c938d0240153bb8","modified":1639290620863},{"_id":"public/archives/2019/06/index.html","hash":"e46eeaa69996f7326bfd0831f4bc95c9dda6a6a8","modified":1639290620863},{"_id":"public/archives/2019/07/index.html","hash":"838fb67d442b833d323cfa43a830562037d957de","modified":1639290620863},{"_id":"public/archives/2019/08/index.html","hash":"eebf2fff45a986514382e3dc2f98a49ce34ed7aa","modified":1639290620863},{"_id":"public/archives/2019/09/index.html","hash":"ce96a89ce240e13d97f3585fa7a95c3147c910f4","modified":1639290620863},{"_id":"public/archives/2019/12/index.html","hash":"7992d897c08efee323605c9aeff741ccf38576ed","modified":1639290620863},{"_id":"public/archives/2020/index.html","hash":"0ef0d8a571beefa7fa924a329ad4641bb67c4966","modified":1639290620863},{"_id":"public/archives/2020/02/index.html","hash":"45189bfd29de694becbe852cafa1a7b640257331","modified":1639290620863},{"_id":"public/archives/2021/index.html","hash":"80a273a858cdefb6db70a057666ac20bf4361754","modified":1639290620863},{"_id":"public/archives/2021/12/index.html","hash":"838bad26e70d7b722f8cdbd0e5ccb4d362d9385f","modified":1639290620863},{"_id":"public/categories/Redis/index.html","hash":"6654c8d7429f9c5b38176132528795dccd0c72be","modified":1639290620863},{"_id":"public/categories/安全认证/index.html","hash":"9600102580dd41e476bbb5a3b537441feeecd8ca","modified":1639290620863},{"_id":"public/categories/数据库/index.html","hash":"517e4b38393fa9d89c2cca121970efd548721005","modified":1639290620863},{"_id":"public/categories/杂谈/index.html","hash":"26867431830f4d514abc520c7227d3b2b53bf0ed","modified":1639290620863},{"_id":"public/categories/环境配置/index.html","hash":"d15c43233f0d546a45cb4601734a5de97b345b20","modified":1639290620863},{"_id":"public/index.html","hash":"a4c42ddec6f8800ac704840850363cb83832660f","modified":1639290620863},{"_id":"public/page/2/index.html","hash":"1b972e091e15b21187e64c14e8dae76a8459a0ae","modified":1639290620863},{"_id":"public/tags/后端开发/index.html","hash":"c05c7636827025857f4c0ef2a957b82a80afd13b","modified":1639290620863},{"_id":"public/tags/后端开发/page/2/index.html","hash":"10f3b6497297c492a7b9e4346ad79beac8b6a567","modified":1639290620863},{"_id":"public/tags/Redis/index.html","hash":"4a8ea3291b74af566aaea760e459cf5278e45eba","modified":1639290620863},{"_id":"public/tags/安全认证/index.html","hash":"773a066b40057071c0a4f247a3a72d988e07d52a","modified":1639290620863},{"_id":"public/tags/数据库/index.html","hash":"f7097a81443a68560ff45a3ff00502c7758ab89c","modified":1639290620863},{"_id":"public/tags/mongodb/index.html","hash":"8e6c7881d096ac3bd6a434a91fed21058d174169","modified":1639290620863},{"_id":"public/tags/杂谈/index.html","hash":"c02137d54189b85c38e77674cb0a1e519112fb52","modified":1639290620863},{"_id":"public/tags/开源/index.html","hash":"a589938443188679503bd909607a4c76bbff68e2","modified":1639290620863},{"_id":"public/tags/环境配置/index.html","hash":"72d7f650e3b828aead079eed1b58909c780f611b","modified":1639290620863},{"_id":"public/favicon.png","hash":"fb0f42cf4455df07e5c739332a708bad1a76440e","modified":1639290620863},{"_id":"public/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1639290620863},{"_id":"public/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1639290620863},{"_id":"public/medias/contact.png","hash":"443ea472dd49b74d9d70295837eb381c8c64f02c","modified":1639290620863},{"_id":"public/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1639290620863},{"_id":"public/medias/logo.png","hash":"fb0f42cf4455df07e5c739332a708bad1a76440e","modified":1639290620863},{"_id":"public/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1639290620863},{"_id":"public/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1639290620863},{"_id":"public/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1639290620863},{"_id":"public/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1639290620863},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1639290620863},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1639290620863},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1639290620863},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1639290620863},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1639290620863},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1639290620863},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1639290620863},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1639290620863},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1639290620863},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1639290620863},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1639290620863},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1639290620863},{"_id":"public/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1639290620863},{"_id":"public/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1639290620863},{"_id":"public/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1639290620863},{"_id":"public/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1639290620863},{"_id":"public/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1639290620863},{"_id":"public/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1639290620863},{"_id":"public/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1639290620863},{"_id":"public/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1639290620863},{"_id":"public/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1639290620863},{"_id":"public/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1639290620863},{"_id":"public/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1639290620863},{"_id":"public/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1639290620863},{"_id":"public/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1639290620863},{"_id":"public/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1639290620863},{"_id":"public/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1639290620863},{"_id":"public/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1639290620863},{"_id":"public/medias/reward/alipay.jpg","hash":"58587f49516452d819a78d42a87f2f687a2b2ed9","modified":1639290620863},{"_id":"public/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1639290620863},{"_id":"public/medias/reward/wechat.png","hash":"aa58bb3e69b0845a594a288b74627e7f795f0583","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1639290620863},{"_id":"public/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1639290620863},{"_id":"public/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1639290620863},{"_id":"public/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1639290620863},{"_id":"public/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1639290620863},{"_id":"public/css/bb.css","hash":"aa15633888c7cf9baea8bb48d796c68b57cf14bf","modified":1639290620863},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1639290620863},{"_id":"public/css/my-gitalk.css","hash":"af18dd29e58642c18bab9b89541767b494c468dd","modified":1639290620863},{"_id":"public/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1639290620863},{"_id":"public/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1639290620863},{"_id":"public/js/search.js","hash":"e1482406c58ea2a0eb178d7e4efb2c879cdddc80","modified":1639290620863},{"_id":"public/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1639290620863},{"_id":"public/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1639290620863},{"_id":"public/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1639290620863},{"_id":"public/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1639290620863},{"_id":"public/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1639290620863},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1639290620863},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1639290620863},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1639290620863},{"_id":"public/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1639290620863},{"_id":"public/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1639290620863},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1639290620863},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1639290620863},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1639290620863},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1639290620863},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1639290620863},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1639290620863},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1639290620863},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1639290620863},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1639290620863},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1639290620863},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1639290620863},{"_id":"public/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1639290620863},{"_id":"public/libs/prism/prism.css","hash":"62e5474893dece076534352f564ceabd6e088a5a","modified":1639290620863},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1639290620863},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1639290620863},{"_id":"public/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1639290620863},{"_id":"public/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1639290620863},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1639290620863},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1639290620863},{"_id":"public/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1639290620863},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1639290620863},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1639290620863},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1639290620863},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1639290620863},{"_id":"public/css/matery.css","hash":"46a87d97fa095ecc120c49f39d85ca502010725f","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1639290620863},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1639290620863},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1639290620863},{"_id":"public/libs/minivaline/MiniValine.js","hash":"fbb58c37e2c74f127ae0c566afa9b48889aab79f","modified":1639290620863},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1639290620863},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1639290620863},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1639290620863},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1639290620863},{"_id":"public/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1639290620863},{"_id":"public/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1639290620863},{"_id":"public/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1639290620863},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1639290620863},{"_id":"public/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1639290620863},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1639290620863},{"_id":"public/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1639290620863},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1639290620863},{"_id":"public/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1639290620863},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1639290620863}],"Category":[{"name":"Redis","_id":"ckx2vb6uq0006vcue6kjsbcvu"},{"name":"安全认证","_id":"ckx2vb6v7000lvcue4kf39ypx"},{"name":"数据库","_id":"ckx2vb6vi000xvcuebgl2guja"},{"name":"杂谈","_id":"ckx2vb6vk0017vcuee7tf26td"},{"name":"环境配置","_id":"ckx2vb6vm001evcuecksu7x6m"}],"Data":[{"_id":"friends","data":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}],"Page":[{"title":"categories","date":"2021-12-12T03:32:45.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-12-12 11:32:45\n---\n","updated":"2021-12-12T03:32:45.373Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckx2vb6tk0000vcuegoqebgdi","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"books","date":"2021-12-12T03:43:42.000Z","_content":"","source":"books/index.md","raw":"---\ntitle: books\ndate: 2021-12-12 11:43:42\n---\n","updated":"2021-12-12T03:43:42.524Z","path":"books/index.html","comments":1,"layout":"page","_id":"ckx2vb6ul0002vcue13hw0mco","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"friends","date":"2021-12-12T03:33:29.000Z","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2021-12-12 11:33:29\n---\n","updated":"2021-12-12T03:33:29.919Z","path":"friends/index.html","comments":1,"layout":"page","_id":"ckx2vb6un0004vcue9d0642yl","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"contact","date":"2021-12-12T03:33:14.000Z","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2021-12-12 11:33:14\n---\n","updated":"2021-12-12T03:33:14.742Z","path":"contact/index.html","comments":1,"layout":"page","_id":"ckx2vb6us0008vcueg31c9p00","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"about","date":"2016-11-09T09:29:51.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-11-09 17:29:51\n---\n","updated":"2021-12-12T02:51:09.645Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckx2vb6uy000avcueh5x78faa","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"musics","date":"2021-12-12T03:43:59.000Z","_content":"","source":"musics/index.md","raw":"---\ntitle: musics\ndate: 2021-12-12 11:43:59\n---\n","updated":"2021-12-12T03:43:59.516Z","path":"musics/index.html","comments":1,"layout":"page","_id":"ckx2vb6v0000cvcue2ufn135g","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"tags","date":"2021-12-12T03:32:55.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-12-12 11:32:55\n---\n","updated":"2021-12-12T03:32:55.652Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckx2vb6v4000gvcueeuh17br4","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"movies","date":"2021-12-12T03:44:13.000Z","_content":"","source":"movies/index.md","raw":"---\ntitle: movies\ndate: 2021-12-12 11:44:13\n---\n","updated":"2021-12-12T03:44:13.632Z","path":"movies/index.html","comments":1,"layout":"page","_id":"ckx2vb6v6000ivcuehret2b1v","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-12-12T02:58:11.674Z","updated":"1985-10-26T08:15:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6uf0001vcue36hs3vh1","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"【Redis】Redis穿透、击穿、雪崩和数据一致性","date":"2019-09-27T11:15:31.000Z","_content":"\n### 1. 缓存穿透\n访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。\n* 解决方案：\n    1. 采用布隆过滤器（bloomfilter就类似于一个hash set），使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；\n    2. 访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。\n    3. 接口限流与熔断、降级\n    4. 使用互斥锁排队（分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock））\n\n\n### 2. 缓存雪崩\n大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。\n* 解决方案\n    1. 可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。\n    2. 建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;\n    3. 加锁排队，实现同上;\n\n\n### 3. 缓存击穿\n一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。\n* 解决方案\n    + 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。\n\n\n### 4. 缓存并发竞争\n多个redis的client同时set key引起的并发问题（例如：多客户端同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2）\n* 解决方案\n    1. 如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可。\n    2. 如果对这个key操作，要求顺序：\n        1. 分布式锁+时间戳（假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00<7:05），那就不做set操作了）\n        2. 利用消息队列（把Redis.set操作放在队列中使其串行化,必须的一个一个执行）\n\n\n### 5. 缓存和数据库一致性解决方案\n#### 5.1 并发量、一致性要求都不是很高的场景\n+ 写流程：**先淘汰缓存，再写数据库**，之后再**异步将数据刷回缓存**\n+ 读流程：先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存\n\n1. 优点：实现起来简单，异步刷新，补缺补漏\n2. 缺点：容灾不足，并发问题，一个比较大的缺陷在于刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性\n\n\n#### 5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）\n+ 写流程：**先淘汰缓存，再写数据库**，监听从库binlog，通过**解析binlog来刷新缓存**\n+ 读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存\n\n1. 优点：容灾\n2. 缺点：只适合简单业务，复杂业务容易发生并发问题（例如：读/写的时候，缓存中的数据已失效，此时又发生了更新）\n\n\n#### 5.3 业务只需要达到“最终一致性”要求的场景\n+ 写流程：**先淘汰缓存，再写数据库，监听从库binlog**，通过分析binlog我们解析出需要需要刷新的**数据标识**，然后将**数据标识写入MQ**，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。\n+ 读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。\n\n1. 优点：容灾完善，无并发问题\n2. 缺点：只能达到\"最终一致性\"\n\n\n#### 5.4 强一致性的场景\n+ 写流程：我们把**修改的数据通过Cache_0标记**“正在被修改”，如果**标记成功，写数据库，删除缓存，监听从库binlog**，通过分析binlog我们解析出需要需要刷新的数据标识，然后将数据标识**写入MQ**，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存； 那如果标记失败，则要放弃这次修改。\n+ 读流程：先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；如果没有被标记，读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。\n\n1. 优点：容灾完善，无并发问题\n2. 缺点：增加Cache_0强依赖，复杂度是比较高的（涉及到Databus、MQ、定时任务等等组件）\n\n","source":"_posts/【Redis】Redis穿透、击穿、雪崩和数据一致性.md","raw":"---\ntitle: 【Redis】Redis穿透、击穿、雪崩和数据一致性\ndate: 2019-09-27 19:15:31\ntags: [后端开发, Redis]\ncategories: Redis\n---\n\n### 1. 缓存穿透\n访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。\n* 解决方案：\n    1. 采用布隆过滤器（bloomfilter就类似于一个hash set），使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；\n    2. 访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。\n    3. 接口限流与熔断、降级\n    4. 使用互斥锁排队（分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock））\n\n\n### 2. 缓存雪崩\n大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。\n* 解决方案\n    1. 可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。\n    2. 建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;\n    3. 加锁排队，实现同上;\n\n\n### 3. 缓存击穿\n一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。\n* 解决方案\n    + 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。\n\n\n### 4. 缓存并发竞争\n多个redis的client同时set key引起的并发问题（例如：多客户端同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2）\n* 解决方案\n    1. 如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可。\n    2. 如果对这个key操作，要求顺序：\n        1. 分布式锁+时间戳（假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00<7:05），那就不做set操作了）\n        2. 利用消息队列（把Redis.set操作放在队列中使其串行化,必须的一个一个执行）\n\n\n### 5. 缓存和数据库一致性解决方案\n#### 5.1 并发量、一致性要求都不是很高的场景\n+ 写流程：**先淘汰缓存，再写数据库**，之后再**异步将数据刷回缓存**\n+ 读流程：先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存\n\n1. 优点：实现起来简单，异步刷新，补缺补漏\n2. 缺点：容灾不足，并发问题，一个比较大的缺陷在于刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性\n\n\n#### 5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）\n+ 写流程：**先淘汰缓存，再写数据库**，监听从库binlog，通过**解析binlog来刷新缓存**\n+ 读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存\n\n1. 优点：容灾\n2. 缺点：只适合简单业务，复杂业务容易发生并发问题（例如：读/写的时候，缓存中的数据已失效，此时又发生了更新）\n\n\n#### 5.3 业务只需要达到“最终一致性”要求的场景\n+ 写流程：**先淘汰缓存，再写数据库，监听从库binlog**，通过分析binlog我们解析出需要需要刷新的**数据标识**，然后将**数据标识写入MQ**，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。\n+ 读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。\n\n1. 优点：容灾完善，无并发问题\n2. 缺点：只能达到\"最终一致性\"\n\n\n#### 5.4 强一致性的场景\n+ 写流程：我们把**修改的数据通过Cache_0标记**“正在被修改”，如果**标记成功，写数据库，删除缓存，监听从库binlog**，通过分析binlog我们解析出需要需要刷新的数据标识，然后将数据标识**写入MQ**，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存； 那如果标记失败，则要放弃这次修改。\n+ 读流程：先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；如果没有被标记，读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。\n\n1. 优点：容灾完善，无并发问题\n2. 缺点：增加Cache_0强依赖，复杂度是比较高的（涉及到Databus、MQ、定时任务等等组件）\n\n","slug":"【Redis】Redis穿透、击穿、雪崩和数据一致性","published":1,"updated":"2021-12-12T02:50:23.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6um0003vcue55ld6yfr","content":"<h3 id=\"1-缓存穿透\"><a href=\"#1-缓存穿透\" class=\"headerlink\" title=\"1. 缓存穿透\"></a>1. 缓存穿透</h3><p>访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。</p>\n<ul>\n<li>解决方案：<ol>\n<li>采用布隆过滤器（bloomfilter就类似于一个hash set），使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；</li>\n<li>访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。</li>\n<li>接口限流与熔断、降级</li>\n<li>使用互斥锁排队（分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock））</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-缓存雪崩\"><a href=\"#2-缓存雪崩\" class=\"headerlink\" title=\"2. 缓存雪崩\"></a>2. 缓存雪崩</h3><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>\n<ul>\n<li>解决方案<ol>\n<li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li>\n<li>建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</li>\n<li>加锁排队，实现同上;</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"3-缓存击穿\"><a href=\"#3-缓存击穿\" class=\"headerlink\" title=\"3. 缓存击穿\"></a>3. 缓存击穿</h3><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p>\n<ul>\n<li>解决方案<ul>\n<li>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-缓存并发竞争\"><a href=\"#4-缓存并发竞争\" class=\"headerlink\" title=\"4. 缓存并发竞争\"></a>4. 缓存并发竞争</h3><p>多个redis的client同时set key引起的并发问题（例如：多客户端同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2）</p>\n<ul>\n<li>解决方案<ol>\n<li>如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可。</li>\n<li>如果对这个key操作，要求顺序：<ol>\n<li>分布式锁+时间戳（假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了）</li>\n<li>利用消息队列（把Redis.set操作放在队列中使其串行化,必须的一个一个执行）</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"5-缓存和数据库一致性解决方案\"><a href=\"#5-缓存和数据库一致性解决方案\" class=\"headerlink\" title=\"5. 缓存和数据库一致性解决方案\"></a>5. 缓存和数据库一致性解决方案</h3><h4 id=\"5-1-并发量、一致性要求都不是很高的场景\"><a href=\"#5-1-并发量、一致性要求都不是很高的场景\" class=\"headerlink\" title=\"5.1 并发量、一致性要求都不是很高的场景\"></a>5.1 并发量、一致性要求都不是很高的场景</h4><ul>\n<li>写流程：<strong>先淘汰缓存，再写数据库</strong>，之后再<strong>异步将数据刷回缓存</strong></li>\n<li>读流程：先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li>\n</ul>\n<ol>\n<li>优点：实现起来简单，异步刷新，补缺补漏</li>\n<li>缺点：容灾不足，并发问题，一个比较大的缺陷在于刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性</li>\n</ol>\n<h4 id=\"5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）\"><a href=\"#5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）\" class=\"headerlink\" title=\"5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）\"></a>5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）</h4><ul>\n<li>写流程：<strong>先淘汰缓存，再写数据库</strong>，监听从库binlog，通过<strong>解析binlog来刷新缓存</strong></li>\n<li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li>\n</ul>\n<ol>\n<li>优点：容灾</li>\n<li>缺点：只适合简单业务，复杂业务容易发生并发问题（例如：读/写的时候，缓存中的数据已失效，此时又发生了更新）</li>\n</ol>\n<h4 id=\"5-3-业务只需要达到“最终一致性”要求的场景\"><a href=\"#5-3-业务只需要达到“最终一致性”要求的场景\" class=\"headerlink\" title=\"5.3 业务只需要达到“最终一致性”要求的场景\"></a>5.3 业务只需要达到“最终一致性”要求的场景</h4><ul>\n<li>写流程：<strong>先淘汰缓存，再写数据库，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的<strong>数据标识</strong>，然后将<strong>数据标识写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li>\n<li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li>\n</ul>\n<ol>\n<li>优点：容灾完善，无并发问题</li>\n<li>缺点：只能达到”最终一致性”</li>\n</ol>\n<h4 id=\"5-4-强一致性的场景\"><a href=\"#5-4-强一致性的场景\" class=\"headerlink\" title=\"5.4 强一致性的场景\"></a>5.4 强一致性的场景</h4><ul>\n<li>写流程：我们把<strong>修改的数据通过Cache_0标记</strong>“正在被修改”，如果<strong>标记成功，写数据库，删除缓存，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的数据标识，然后将数据标识<strong>写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存； 那如果标记失败，则要放弃这次修改。</li>\n<li>读流程：先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；如果没有被标记，读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li>\n</ul>\n<ol>\n<li>优点：容灾完善，无并发问题</li>\n<li>缺点：增加Cache_0强依赖，复杂度是比较高的（涉及到Databus、MQ、定时任务等等组件）</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"1-缓存穿透\"><a href=\"#1-缓存穿透\" class=\"headerlink\" title=\"1. 缓存穿透\"></a>1. 缓存穿透</h3><p>访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。</p>\n<ul>\n<li>解决方案：<ol>\n<li>采用布隆过滤器（bloomfilter就类似于一个hash set），使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；</li>\n<li>访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。</li>\n<li>接口限流与熔断、降级</li>\n<li>使用互斥锁排队（分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock））</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-缓存雪崩\"><a href=\"#2-缓存雪崩\" class=\"headerlink\" title=\"2. 缓存雪崩\"></a>2. 缓存雪崩</h3><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>\n<ul>\n<li>解决方案<ol>\n<li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li>\n<li>建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</li>\n<li>加锁排队，实现同上;</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"3-缓存击穿\"><a href=\"#3-缓存击穿\" class=\"headerlink\" title=\"3. 缓存击穿\"></a>3. 缓存击穿</h3><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p>\n<ul>\n<li>解决方案<ul>\n<li>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-缓存并发竞争\"><a href=\"#4-缓存并发竞争\" class=\"headerlink\" title=\"4. 缓存并发竞争\"></a>4. 缓存并发竞争</h3><p>多个redis的client同时set key引起的并发问题（例如：多客户端同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2）</p>\n<ul>\n<li>解决方案<ol>\n<li>如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可。</li>\n<li>如果对这个key操作，要求顺序：<ol>\n<li>分布式锁+时间戳（假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了）</li>\n<li>利用消息队列（把Redis.set操作放在队列中使其串行化,必须的一个一个执行）</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"5-缓存和数据库一致性解决方案\"><a href=\"#5-缓存和数据库一致性解决方案\" class=\"headerlink\" title=\"5. 缓存和数据库一致性解决方案\"></a>5. 缓存和数据库一致性解决方案</h3><h4 id=\"5-1-并发量、一致性要求都不是很高的场景\"><a href=\"#5-1-并发量、一致性要求都不是很高的场景\" class=\"headerlink\" title=\"5.1 并发量、一致性要求都不是很高的场景\"></a>5.1 并发量、一致性要求都不是很高的场景</h4><ul>\n<li>写流程：<strong>先淘汰缓存，再写数据库</strong>，之后再<strong>异步将数据刷回缓存</strong></li>\n<li>读流程：先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li>\n</ul>\n<ol>\n<li>优点：实现起来简单，异步刷新，补缺补漏</li>\n<li>缺点：容灾不足，并发问题，一个比较大的缺陷在于刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性</li>\n</ol>\n<h4 id=\"5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）\"><a href=\"#5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）\" class=\"headerlink\" title=\"5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）\"></a>5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）</h4><ul>\n<li>写流程：<strong>先淘汰缓存，再写数据库</strong>，监听从库binlog，通过<strong>解析binlog来刷新缓存</strong></li>\n<li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li>\n</ul>\n<ol>\n<li>优点：容灾</li>\n<li>缺点：只适合简单业务，复杂业务容易发生并发问题（例如：读/写的时候，缓存中的数据已失效，此时又发生了更新）</li>\n</ol>\n<h4 id=\"5-3-业务只需要达到“最终一致性”要求的场景\"><a href=\"#5-3-业务只需要达到“最终一致性”要求的场景\" class=\"headerlink\" title=\"5.3 业务只需要达到“最终一致性”要求的场景\"></a>5.3 业务只需要达到“最终一致性”要求的场景</h4><ul>\n<li>写流程：<strong>先淘汰缓存，再写数据库，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的<strong>数据标识</strong>，然后将<strong>数据标识写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li>\n<li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li>\n</ul>\n<ol>\n<li>优点：容灾完善，无并发问题</li>\n<li>缺点：只能达到”最终一致性”</li>\n</ol>\n<h4 id=\"5-4-强一致性的场景\"><a href=\"#5-4-强一致性的场景\" class=\"headerlink\" title=\"5.4 强一致性的场景\"></a>5.4 强一致性的场景</h4><ul>\n<li>写流程：我们把<strong>修改的数据通过Cache_0标记</strong>“正在被修改”，如果<strong>标记成功，写数据库，删除缓存，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的数据标识，然后将数据标识<strong>写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存； 那如果标记失败，则要放弃这次修改。</li>\n<li>读流程：先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；如果没有被标记，读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li>\n</ul>\n<ol>\n<li>优点：容灾完善，无并发问题</li>\n<li>缺点：增加Cache_0强依赖，复杂度是比较高的（涉及到Databus、MQ、定时任务等等组件）</li>\n</ol>\n"},{"title":"xdorg","date":"2021-12-12T01:35:41.000Z","_content":"","source":"_posts/xdorg.md","raw":"---\ntitle: xdorg\ndate: 2021-12-12 09:35:41\ntags:\n---\n","slug":"xdorg","published":1,"updated":"2021-12-12T01:35:41.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6uo0005vcue8dxq1ddo","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"【Redis】基于Redis的分布式锁实现","date":"2019-12-08T08:04:23.000Z","_content":"\r\n### SETNX命令简介\n- `SETNX key value`返回(`1:key`的值被设置，`0:key`的值没被设置)，将`key`的值设为`value`，并且仅当`key`不存在。\n- 锁的`key`为目标数据的唯一键，`value`为锁的期望超时时间点；\n- 基于`Redis`实现的分布式锁，主要基于`redis`的`setnx（set if not exist）`命令；\n<!-- more -->\n\n### 1. jedis实现分布式锁\n``` xml\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.0.1</version>\n</dependency>\n```\n\n#### 1.1 实现示例:\n``` java\npublic static boolean correctGetLock(String lockKey, String requestId, int expireTime) {\n    String result = jedis.set(lockKey, requestId, \"NX\", \"PX\", expireTime);\n    if (\"OK\".equals(result)) {\n        return true;\n    }\n    return false;\n}\n```\n`jedis.set(String key, String value, String nxxx, String expx, int time)`\n    - **`key`**：保证唯一，用来当锁（`redis`记录的`key`）\n    - **`value`**：`redis`记录的`value`，目的是为了标志锁的所有者（竞争锁的客户端），保证解锁时只能解自己加的锁。`requestId`可以使用`UUID.randomUUID().toString()`方法生成\n    - **`nxxx`**：`\"NX\"`意思是`SET IF NOT EXIST`，即当`key`不存在时，我们进行`set`操作，若`key`已经存在，则不做任何操作\n    - **`expx`**：`\"PX\"`意思是要给这个`key`加一个过期的设置（单位毫秒），过期时间由第五个参数决定\n    - **`time`**：`expx`设置为`\"PX\"`时，`redis key`的过期时间\n\n#### 1.2 解锁示例:\n``` java\npublic boolean correctReleaseLock(String lockKey, String requestId) {\n    String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\";\n    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));\n    if (RELEASE_SUCCESS.equals(result)) {\n        return true;\n    }\n    return false;\n}\n```\n`eval`命令执行`Lua`代码的时候，`Lua`代码将被当成一个命令去执行，并且直到`eval`命令执行完成，`Redis`才会执行其他命令，所以保证了检查和删除操作都是原子的。\n\n#### 1.3 这类琐最大的缺点\n加锁时只作用在一个`Redis`节点上，即使`Redis`通过`sentinel`保证高可用，如果这个`master`节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：\n1. 在`Redis`的`master`节点上拿到了锁；\n2. 但是这个加锁的`key`还没有同步到`slave`节点；\n3. `master`故障，发生故障转移，`slave`节点升级为`master`节点；\n4. 导致锁丢失。\n\n> 因此，`Redis`作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：`Redlock`。基于`Redis`的`Redisson`实现了`Redlock`。\n\n\n### 2. Redisson实现普通分布式锁\n普通分布式实现非常简单，无论是那种架构，向`Redis`通过`EVAL`命令执行`LUA脚本`即可。\n``` xml\n<dependency>\n    <groupId>org.redisson</groupId>\n    <artifactId>redisson</artifactId>\n    <version>3.3.2</version>\n</dependency>\n```\n\n**单机模式:**\n``` java\n// 构造redisson实现分布式锁必要的Config\nConfig config = new Config();\nconfig.useSingleServer().setAddress(\"redis://172.29.1.180:5379\")\n                        .setPassword(\"a123456\").setDatabase(0);\n// 构造RedissonClient\nRedissonClient redissonClient = Redisson.create(config);\n// 设置锁定资源名称, 还可以getFairLock(), getReadWriteLock()\nRLock lock = redissonClient.getLock(\"DISLOCK\");\nboolean isLock;\ntry {\n    // 尝试获取分布式锁\n    // 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。\n    isLock = lock.tryLock(500, 10000, TimeUnit.MILLISECONDS);\n    if (isLock) {\n        //TODO if get lock success, do something;\n    }\n} catch (Exception e) {\n} finally {\n    // 无论如何, 最后都要解锁\n    lock.unlock();\n}\n```\n\n**哨兵模式:**\n即`Sentinel`模式，实现代码和单机模式几乎一样，唯一的不同就是`Config`的构造：\n``` java\nConfig config = new Config();\nconfig.useSentinelServers().addSentinelAddress(\n        \"redis://172.29.3.245:26378\",\"redis://172.29.3.245:26379\", \"redis://172.29.3.245:26380\")\n      .setMasterName(\"mymaster\").setPassword(\"a123456\").setDatabase(0);\n```\n\n**集群模式:**\n即`Cluster`模式，集群模式构造`Config`如下：\n``` java\nConfig config = new Config();\nconfig.useClusterServers().addNodeAddress(\n        \"redis://172.29.3.245:6375\",\"redis://172.29.3.245:6376\", \"redis://172.29.3.245:6377\",\n        \"redis://172.29.3.245:6378\",\"redis://172.29.3.245:6379\", \"redis://172.29.3.245:6380\")\n      .setPassword(\"a123456\").setScanInterval(5000);\r```\n\n\n### 3. Redisson实现Redlock分布式锁\n#### 3.1 Redlock算法大概原理：\n- 在`Redis`的分布式环境中，我们假设有`N`个`Redis master`。这些节点**完全互相独立，不存在主从复制或者其他集群协调机制**。我们确保将在`N`个实例上使用与在`Redis`单实例下相同方法获取和释放锁。\n- 为了取到锁，客户端应该执行以下操作:\n    - 获取当前`Unix`时间，以毫秒为单位。\n    - 依次尝试从`N`个实例，使用相同的`key`和具有唯一性的`value`（例如UUID）获取锁。\n    - 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。\n    - **当且仅当(N/2+1)的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功**，例如3个节点至少需要`3/2+1=2`2个。\n    - 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。\n    - 若获取锁失败，客户端应该在**所有的Redis实例上进行解锁**（即便某些Redis实例根本就没有加锁成功）。\n\n#### 3.2 使用`Redlock`\n单机模式`Redis`为例:\n``` java\nConfig config = new Config();\nconfig.useClusterServers().addNodeAddress(\n        \"redis://127.0.0.1:6379\",\"redis://127.0.0.1:6369\", \"redis://127.0.0.1:6359\",\n        \"redis://127.0.0.1:6349\",\"redis://127.0.0.1:6339\")\n        .setPassword(\"******\");\n// 节点1\nConfig config1 = new Config();\nconfig1.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\nRedissonClient redissonClient1 = Redisson.create(config1);\n// 节点2\nConfig config2 = new Config();\nconfig2.useSingleServer().setAddress(\"redis://127.0.0.1:6378\");\nRedissonClient redissonClient2 = Redisson.create(config2);\n// 节点3\nConfig config3 = new Config();\nconfig3.useSingleServer().setAddress(\"redis://127.0.0.1:6377\");\nRedissonClient redissonClient3 = Redisson.create(config3);\n// 设置锁定资源名称\nString resourceName = \"REDLOCK\";\nRLock lock1 = redissonClient1.getLock(resourceName);\nRLock lock2 = redissonClient2.getLock(resourceName);\nRLock lock3 = redissonClient3.getLock(resourceName);\n// 实例化RedissonRedLock\nRedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);\ntry {\n    boolean isLock = redLock.tryLock(500, 30000, TimeUnit.MILLISECONDS);\n    if (isLock) {\n        //TODO if get lock success, do something;\n        Thread.sleep(30000);\n    }\n} catch (Exception e) {\n} finally {\n    //解锁\n    redLock.unlock();\n}\n```\n最核心的变化就是 `RedissonRedLock redLock`=**`new RedissonRedLock(lock1,lock2,lock3)`;**，因为我这里是以三个节点为例。\n+ 如果是主从`Redis`架构、哨兵`Redis`架构、集群`Redis`架构实现`Redlock`，只需要改变上述`config1`、`config2`、`config3`为主从模式、哨兵模式、集群模式配置即可，但相应需要`3`个独立的`Redis`主从集群、`3`个`Redis`独立的哨兵集群、`3`个独立的`Cluster`集群。\n+ 以`sentinel`模式架构为例，`3`个`sentinel`模式集群，如果要获取分布式锁，那么需要向这`3`个`sentinel`集群通过`EVAL`命令执行`LUA`脚本，需要`3/2+1=2`，即至少2个`sentinel`集群响应成功，才算成功的以`Redlock`算法获取到分布式锁。\n\n\n### 4. Redlock问题合集\n#### 4.1 N个节点的理解\n假设我们用`N(>=3)`个节点实现`Redlock`算法的分布式锁。**不是**一个有`N`个主节点的cluster集群；而是**要么是`N`个redis单实例，要么是`N`个sentinel集群，要么是`N`个cluster集群**。\n\n#### 4.2 失效时间如何设置\n这个问题的场景是，假设设置失效时间10秒，如果由于某些原因导致10秒还没执行完任务，这时候锁自动失效，导致其他线程也会拿到分布式锁。\n这确实是Redis分布式最大的问题，不管是普通分布式锁，还是Redlock算法分布式锁，都没有解决这个问题。也有一些文章提出了对失效时间续租，即延长失效时间，很明显这又提升了分布式锁的复杂度（没有现成的框架有实现）。\n\n#### 4.3 redis分布式锁的高可用\n关于Redis分布式锁的安全性问题，在分布式系统专家Martin Kleppmann和Redis的作者Antirez之间已经发生过一场争论。有兴趣的同学，搜索\"基于Redis的分布式锁到底安全吗\"就能得到你想要的答案，需要注意的是，有上下两篇（这应该就是传说中的神仙打架吧）。\n\n#### 4.4 使用Zookeeper还是Redis实现分布式锁\n没有绝对的好坏，只有更适合自己的业务。\n就**性能**而言，`Redis`很明显优于`Zookeeper`；就分布式锁实现的健壮性(**高可用**)而言，`Zookeeper`很明显优于`Redis`。至于如何选择，还要看具体业务场景。\n\n> 参考：[https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ](https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ)","source":"_posts/【Redis】基于Redis的分布式锁实现.md","raw":"---\ntitle: 【Redis】基于Redis的分布式锁实现\ndate: 2019-12-08 16:04:23\ntags: [后端开发, Redis]\ncategories: Redis\n---\n\r\n### SETNX命令简介\n- `SETNX key value`返回(`1:key`的值被设置，`0:key`的值没被设置)，将`key`的值设为`value`，并且仅当`key`不存在。\n- 锁的`key`为目标数据的唯一键，`value`为锁的期望超时时间点；\n- 基于`Redis`实现的分布式锁，主要基于`redis`的`setnx（set if not exist）`命令；\n<!-- more -->\n\n### 1. jedis实现分布式锁\n``` xml\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.0.1</version>\n</dependency>\n```\n\n#### 1.1 实现示例:\n``` java\npublic static boolean correctGetLock(String lockKey, String requestId, int expireTime) {\n    String result = jedis.set(lockKey, requestId, \"NX\", \"PX\", expireTime);\n    if (\"OK\".equals(result)) {\n        return true;\n    }\n    return false;\n}\n```\n`jedis.set(String key, String value, String nxxx, String expx, int time)`\n    - **`key`**：保证唯一，用来当锁（`redis`记录的`key`）\n    - **`value`**：`redis`记录的`value`，目的是为了标志锁的所有者（竞争锁的客户端），保证解锁时只能解自己加的锁。`requestId`可以使用`UUID.randomUUID().toString()`方法生成\n    - **`nxxx`**：`\"NX\"`意思是`SET IF NOT EXIST`，即当`key`不存在时，我们进行`set`操作，若`key`已经存在，则不做任何操作\n    - **`expx`**：`\"PX\"`意思是要给这个`key`加一个过期的设置（单位毫秒），过期时间由第五个参数决定\n    - **`time`**：`expx`设置为`\"PX\"`时，`redis key`的过期时间\n\n#### 1.2 解锁示例:\n``` java\npublic boolean correctReleaseLock(String lockKey, String requestId) {\n    String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\";\n    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));\n    if (RELEASE_SUCCESS.equals(result)) {\n        return true;\n    }\n    return false;\n}\n```\n`eval`命令执行`Lua`代码的时候，`Lua`代码将被当成一个命令去执行，并且直到`eval`命令执行完成，`Redis`才会执行其他命令，所以保证了检查和删除操作都是原子的。\n\n#### 1.3 这类琐最大的缺点\n加锁时只作用在一个`Redis`节点上，即使`Redis`通过`sentinel`保证高可用，如果这个`master`节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：\n1. 在`Redis`的`master`节点上拿到了锁；\n2. 但是这个加锁的`key`还没有同步到`slave`节点；\n3. `master`故障，发生故障转移，`slave`节点升级为`master`节点；\n4. 导致锁丢失。\n\n> 因此，`Redis`作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：`Redlock`。基于`Redis`的`Redisson`实现了`Redlock`。\n\n\n### 2. Redisson实现普通分布式锁\n普通分布式实现非常简单，无论是那种架构，向`Redis`通过`EVAL`命令执行`LUA脚本`即可。\n``` xml\n<dependency>\n    <groupId>org.redisson</groupId>\n    <artifactId>redisson</artifactId>\n    <version>3.3.2</version>\n</dependency>\n```\n\n**单机模式:**\n``` java\n// 构造redisson实现分布式锁必要的Config\nConfig config = new Config();\nconfig.useSingleServer().setAddress(\"redis://172.29.1.180:5379\")\n                        .setPassword(\"a123456\").setDatabase(0);\n// 构造RedissonClient\nRedissonClient redissonClient = Redisson.create(config);\n// 设置锁定资源名称, 还可以getFairLock(), getReadWriteLock()\nRLock lock = redissonClient.getLock(\"DISLOCK\");\nboolean isLock;\ntry {\n    // 尝试获取分布式锁\n    // 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。\n    isLock = lock.tryLock(500, 10000, TimeUnit.MILLISECONDS);\n    if (isLock) {\n        //TODO if get lock success, do something;\n    }\n} catch (Exception e) {\n} finally {\n    // 无论如何, 最后都要解锁\n    lock.unlock();\n}\n```\n\n**哨兵模式:**\n即`Sentinel`模式，实现代码和单机模式几乎一样，唯一的不同就是`Config`的构造：\n``` java\nConfig config = new Config();\nconfig.useSentinelServers().addSentinelAddress(\n        \"redis://172.29.3.245:26378\",\"redis://172.29.3.245:26379\", \"redis://172.29.3.245:26380\")\n      .setMasterName(\"mymaster\").setPassword(\"a123456\").setDatabase(0);\n```\n\n**集群模式:**\n即`Cluster`模式，集群模式构造`Config`如下：\n``` java\nConfig config = new Config();\nconfig.useClusterServers().addNodeAddress(\n        \"redis://172.29.3.245:6375\",\"redis://172.29.3.245:6376\", \"redis://172.29.3.245:6377\",\n        \"redis://172.29.3.245:6378\",\"redis://172.29.3.245:6379\", \"redis://172.29.3.245:6380\")\n      .setPassword(\"a123456\").setScanInterval(5000);\r```\n\n\n### 3. Redisson实现Redlock分布式锁\n#### 3.1 Redlock算法大概原理：\n- 在`Redis`的分布式环境中，我们假设有`N`个`Redis master`。这些节点**完全互相独立，不存在主从复制或者其他集群协调机制**。我们确保将在`N`个实例上使用与在`Redis`单实例下相同方法获取和释放锁。\n- 为了取到锁，客户端应该执行以下操作:\n    - 获取当前`Unix`时间，以毫秒为单位。\n    - 依次尝试从`N`个实例，使用相同的`key`和具有唯一性的`value`（例如UUID）获取锁。\n    - 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。\n    - **当且仅当(N/2+1)的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功**，例如3个节点至少需要`3/2+1=2`2个。\n    - 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。\n    - 若获取锁失败，客户端应该在**所有的Redis实例上进行解锁**（即便某些Redis实例根本就没有加锁成功）。\n\n#### 3.2 使用`Redlock`\n单机模式`Redis`为例:\n``` java\nConfig config = new Config();\nconfig.useClusterServers().addNodeAddress(\n        \"redis://127.0.0.1:6379\",\"redis://127.0.0.1:6369\", \"redis://127.0.0.1:6359\",\n        \"redis://127.0.0.1:6349\",\"redis://127.0.0.1:6339\")\n        .setPassword(\"******\");\n// 节点1\nConfig config1 = new Config();\nconfig1.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\nRedissonClient redissonClient1 = Redisson.create(config1);\n// 节点2\nConfig config2 = new Config();\nconfig2.useSingleServer().setAddress(\"redis://127.0.0.1:6378\");\nRedissonClient redissonClient2 = Redisson.create(config2);\n// 节点3\nConfig config3 = new Config();\nconfig3.useSingleServer().setAddress(\"redis://127.0.0.1:6377\");\nRedissonClient redissonClient3 = Redisson.create(config3);\n// 设置锁定资源名称\nString resourceName = \"REDLOCK\";\nRLock lock1 = redissonClient1.getLock(resourceName);\nRLock lock2 = redissonClient2.getLock(resourceName);\nRLock lock3 = redissonClient3.getLock(resourceName);\n// 实例化RedissonRedLock\nRedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);\ntry {\n    boolean isLock = redLock.tryLock(500, 30000, TimeUnit.MILLISECONDS);\n    if (isLock) {\n        //TODO if get lock success, do something;\n        Thread.sleep(30000);\n    }\n} catch (Exception e) {\n} finally {\n    //解锁\n    redLock.unlock();\n}\n```\n最核心的变化就是 `RedissonRedLock redLock`=**`new RedissonRedLock(lock1,lock2,lock3)`;**，因为我这里是以三个节点为例。\n+ 如果是主从`Redis`架构、哨兵`Redis`架构、集群`Redis`架构实现`Redlock`，只需要改变上述`config1`、`config2`、`config3`为主从模式、哨兵模式、集群模式配置即可，但相应需要`3`个独立的`Redis`主从集群、`3`个`Redis`独立的哨兵集群、`3`个独立的`Cluster`集群。\n+ 以`sentinel`模式架构为例，`3`个`sentinel`模式集群，如果要获取分布式锁，那么需要向这`3`个`sentinel`集群通过`EVAL`命令执行`LUA`脚本，需要`3/2+1=2`，即至少2个`sentinel`集群响应成功，才算成功的以`Redlock`算法获取到分布式锁。\n\n\n### 4. Redlock问题合集\n#### 4.1 N个节点的理解\n假设我们用`N(>=3)`个节点实现`Redlock`算法的分布式锁。**不是**一个有`N`个主节点的cluster集群；而是**要么是`N`个redis单实例，要么是`N`个sentinel集群，要么是`N`个cluster集群**。\n\n#### 4.2 失效时间如何设置\n这个问题的场景是，假设设置失效时间10秒，如果由于某些原因导致10秒还没执行完任务，这时候锁自动失效，导致其他线程也会拿到分布式锁。\n这确实是Redis分布式最大的问题，不管是普通分布式锁，还是Redlock算法分布式锁，都没有解决这个问题。也有一些文章提出了对失效时间续租，即延长失效时间，很明显这又提升了分布式锁的复杂度（没有现成的框架有实现）。\n\n#### 4.3 redis分布式锁的高可用\n关于Redis分布式锁的安全性问题，在分布式系统专家Martin Kleppmann和Redis的作者Antirez之间已经发生过一场争论。有兴趣的同学，搜索\"基于Redis的分布式锁到底安全吗\"就能得到你想要的答案，需要注意的是，有上下两篇（这应该就是传说中的神仙打架吧）。\n\n#### 4.4 使用Zookeeper还是Redis实现分布式锁\n没有绝对的好坏，只有更适合自己的业务。\n就**性能**而言，`Redis`很明显优于`Zookeeper`；就分布式锁实现的健壮性(**高可用**)而言，`Zookeeper`很明显优于`Redis`。至于如何选择，还要看具体业务场景。\n\n> 参考：[https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ](https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ)","slug":"【Redis】基于Redis的分布式锁实现","published":1,"updated":"2021-12-12T02:50:23.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6uu0009vcue8gqq7r5g","content":"<h3 id=\"SETNX命令简介\"><a href=\"#SETNX命令简介\" class=\"headerlink\" title=\"SETNX命令简介\"></a>SETNX命令简介</h3><ul>\n<li><code>SETNX key value</code>返回(<code>1:key</code>的值被设置，<code>0:key</code>的值没被设置)，将<code>key</code>的值设为<code>value</code>，并且仅当<code>key</code>不存在。</li>\n<li>锁的<code>key</code>为目标数据的唯一键，<code>value</code>为锁的期望超时时间点；</li>\n<li>基于<code>Redis</code>实现的分布式锁，主要基于<code>redis</code>的<code>setnx（set if not exist）</code>命令；<span id=\"more\"></span></li>\n</ul>\n<h3 id=\"1-jedis实现分布式锁\"><a href=\"#1-jedis实现分布式锁\" class=\"headerlink\" title=\"1. jedis实现分布式锁\"></a>1. jedis实现分布式锁</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>redis.clients<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jedis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-1-实现示例\"><a href=\"#1-1-实现示例\" class=\"headerlink\" title=\"1.1 实现示例:\"></a>1.1 实现示例:</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">correctGetLock</span><span class=\"params\">(String lockKey, String requestId, <span class=\"keyword\">int</span> expireTime)</span> </span>&#123;</span><br><span class=\"line\">    String result = jedis.set(lockKey, requestId, <span class=\"string\">&quot;NX&quot;</span>, <span class=\"string\">&quot;PX&quot;</span>, expireTime);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>jedis.set(String key, String value, String nxxx, String expx, int time)</code><br>    - **<code>key</code>**：保证唯一，用来当锁（<code>redis</code>记录的<code>key</code>）<br>    - **<code>value</code>**：<code>redis</code>记录的<code>value</code>，目的是为了标志锁的所有者（竞争锁的客户端），保证解锁时只能解自己加的锁。<code>requestId</code>可以使用<code>UUID.randomUUID().toString()</code>方法生成<br>    - **<code>nxxx</code>**：<code>&quot;NX&quot;</code>意思是<code>SET IF NOT EXIST</code>，即当<code>key</code>不存在时，我们进行<code>set</code>操作，若<code>key</code>已经存在，则不做任何操作<br>    - **<code>expx</code>**：<code>&quot;PX&quot;</code>意思是要给这个<code>key</code>加一个过期的设置（单位毫秒），过期时间由第五个参数决定<br>    - **<code>time</code>**：<code>expx</code>设置为<code>&quot;PX&quot;</code>时，<code>redis key</code>的过期时间</p>\n<h4 id=\"1-2-解锁示例\"><a href=\"#1-2-解锁示例\" class=\"headerlink\" title=\"1.2 解锁示例:\"></a>1.2 解锁示例:</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">correctReleaseLock</span><span class=\"params\">(String lockKey, String requestId)</span> </span>&#123;</span><br><span class=\"line\">    String script = <span class=\"string\">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class=\"line\">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>eval</code>命令执行<code>Lua</code>代码的时候，<code>Lua</code>代码将被当成一个命令去执行，并且直到<code>eval</code>命令执行完成，<code>Redis</code>才会执行其他命令，所以保证了检查和删除操作都是原子的。</p>\n<h4 id=\"1-3-这类琐最大的缺点\"><a href=\"#1-3-这类琐最大的缺点\" class=\"headerlink\" title=\"1.3 这类琐最大的缺点\"></a>1.3 这类琐最大的缺点</h4><p>加锁时只作用在一个<code>Redis</code>节点上，即使<code>Redis</code>通过<code>sentinel</code>保证高可用，如果这个<code>master</code>节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：</p>\n<ol>\n<li>在<code>Redis</code>的<code>master</code>节点上拿到了锁；</li>\n<li>但是这个加锁的<code>key</code>还没有同步到<code>slave</code>节点；</li>\n<li><code>master</code>故障，发生故障转移，<code>slave</code>节点升级为<code>master</code>节点；</li>\n<li>导致锁丢失。</li>\n</ol>\n<blockquote>\n<p>因此，<code>Redis</code>作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：<code>Redlock</code>。基于<code>Redis</code>的<code>Redisson</code>实现了<code>Redlock</code>。</p>\n</blockquote>\n<h3 id=\"2-Redisson实现普通分布式锁\"><a href=\"#2-Redisson实现普通分布式锁\" class=\"headerlink\" title=\"2. Redisson实现普通分布式锁\"></a>2. Redisson实现普通分布式锁</h3><p>普通分布式实现非常简单，无论是那种架构，向<code>Redis</code>通过<code>EVAL</code>命令执行<code>LUA脚本</code>即可。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.3.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>单机模式:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造redisson实现分布式锁必要的Config</span></span><br><span class=\"line\">Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config.useSingleServer().setAddress(<span class=\"string\">&quot;redis://172.29.1.180:5379&quot;</span>)</span><br><span class=\"line\">                        .setPassword(<span class=\"string\">&quot;a123456&quot;</span>).setDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 构造RedissonClient</span></span><br><span class=\"line\">RedissonClient redissonClient = Redisson.create(config);</span><br><span class=\"line\"><span class=\"comment\">// 设置锁定资源名称, 还可以getFairLock(), getReadWriteLock()</span></span><br><span class=\"line\">RLock lock = redissonClient.getLock(<span class=\"string\">&quot;DISLOCK&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isLock;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试获取分布式锁</span></span><br><span class=\"line\">    <span class=\"comment\">// 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。</span></span><br><span class=\"line\">    isLock = lock.tryLock(<span class=\"number\">500</span>, <span class=\"number\">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO if get lock success, do something;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 无论如何, 最后都要解锁</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>哨兵模式:</strong><br>即<code>Sentinel</code>模式，实现代码和单机模式几乎一样，唯一的不同就是<code>Config</code>的构造：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config.useSentinelServers().addSentinelAddress(</span><br><span class=\"line\">        <span class=\"string\">&quot;redis://172.29.3.245:26378&quot;</span>,<span class=\"string\">&quot;redis://172.29.3.245:26379&quot;</span>, <span class=\"string\">&quot;redis://172.29.3.245:26380&quot;</span>)</span><br><span class=\"line\">      .setMasterName(<span class=\"string\">&quot;mymaster&quot;</span>).setPassword(<span class=\"string\">&quot;a123456&quot;</span>).setDatabase(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>集群模式:</strong><br>即<code>Cluster</code>模式，集群模式构造<code>Config</code>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config.useClusterServers().addNodeAddress(</span><br><span class=\"line\">        <span class=\"string\">&quot;redis://172.29.3.245:6375&quot;</span>,<span class=\"string\">&quot;redis://172.29.3.245:6376&quot;</span>, <span class=\"string\">&quot;redis://172.29.3.245:6377&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;redis://172.29.3.245:6378&quot;</span>,<span class=\"string\">&quot;redis://172.29.3.245:6379&quot;</span>, <span class=\"string\">&quot;redis://172.29.3.245:6380&quot;</span>)</span><br><span class=\"line\">      .setPassword(<span class=\"string\">&quot;a123456&quot;</span>).setScanInterval(<span class=\"number\">5000</span>);\r```</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### <span class=\"number\">3.</span> Redisson实现Redlock分布式锁</span><br><span class=\"line\">#### <span class=\"number\">3.1</span> Redlock算法大概原理：</span><br><span class=\"line\">- 在`Redis`的分布式环境中，我们假设有`N`个`Redis master`。这些节点**完全互相独立，不存在主从复制或者其他集群协调机制**。我们确保将在`N`个实例上使用与在`Redis`单实例下相同方法获取和释放锁。</span><br><span class=\"line\">- 为了取到锁，客户端应该执行以下操作:</span><br><span class=\"line\">    - 获取当前`Unix`时间，以毫秒为单位。</span><br><span class=\"line\">    - 依次尝试从`N`个实例，使用相同的`key`和具有唯一性的`value`（例如UUID）获取锁。</span><br><span class=\"line\">    - 客户端使用当前时间减去开始获取锁时间（步骤<span class=\"number\">1</span>记录的时间）就得到获取锁使用的时间。</span><br><span class=\"line\">    - **当且仅当(N/<span class=\"number\">2</span>+<span class=\"number\">1</span>)的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功**，例如<span class=\"number\">3</span>个节点至少需要`<span class=\"number\">3</span>/<span class=\"number\">2</span>+<span class=\"number\">1</span>=<span class=\"number\">2</span>`<span class=\"number\">2</span>个。</span><br><span class=\"line\">    - 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤<span class=\"number\">3</span>计算的结果）。</span><br><span class=\"line\">    - 若获取锁失败，客户端应该在**所有的Redis实例上进行解锁**（即便某些Redis实例根本就没有加锁成功）。</span><br><span class=\"line\"></span><br><span class=\"line\">#### <span class=\"number\">3.2</span> 使用`Redlock`</span><br><span class=\"line\">单机模式`Redis`为例:</span><br><span class=\"line\">``` java</span><br><span class=\"line\">Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config.useClusterServers().addNodeAddress(</span><br><span class=\"line\">        <span class=\"string\">&quot;redis://127.0.0.1:6379&quot;</span>,<span class=\"string\">&quot;redis://127.0.0.1:6369&quot;</span>, <span class=\"string\">&quot;redis://127.0.0.1:6359&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;redis://127.0.0.1:6349&quot;</span>,<span class=\"string\">&quot;redis://127.0.0.1:6339&quot;</span>)</span><br><span class=\"line\">        .setPassword(<span class=\"string\">&quot;******&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 节点1</span></span><br><span class=\"line\">Config config1 = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config1.useSingleServer().setAddress(<span class=\"string\">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class=\"line\">RedissonClient redissonClient1 = Redisson.create(config1);</span><br><span class=\"line\"><span class=\"comment\">// 节点2</span></span><br><span class=\"line\">Config config2 = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config2.useSingleServer().setAddress(<span class=\"string\">&quot;redis://127.0.0.1:6378&quot;</span>);</span><br><span class=\"line\">RedissonClient redissonClient2 = Redisson.create(config2);</span><br><span class=\"line\"><span class=\"comment\">// 节点3</span></span><br><span class=\"line\">Config config3 = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config3.useSingleServer().setAddress(<span class=\"string\">&quot;redis://127.0.0.1:6377&quot;</span>);</span><br><span class=\"line\">RedissonClient redissonClient3 = Redisson.create(config3);</span><br><span class=\"line\"><span class=\"comment\">// 设置锁定资源名称</span></span><br><span class=\"line\">String resourceName = <span class=\"string\">&quot;REDLOCK&quot;</span>;</span><br><span class=\"line\">RLock lock1 = redissonClient1.getLock(resourceName);</span><br><span class=\"line\">RLock lock2 = redissonClient2.getLock(resourceName);</span><br><span class=\"line\">RLock lock3 = redissonClient3.getLock(resourceName);</span><br><span class=\"line\"><span class=\"comment\">// 实例化RedissonRedLock</span></span><br><span class=\"line\">RedissonRedLock redLock = <span class=\"keyword\">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isLock = redLock.tryLock(<span class=\"number\">500</span>, <span class=\"number\">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO if get lock success, do something;</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">30000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//解锁</span></span><br><span class=\"line\">    redLock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最核心的变化就是 <code>RedissonRedLock redLock</code>=**<code>new RedissonRedLock(lock1,lock2,lock3)</code>;**，因为我这里是以三个节点为例。</p>\n<ul>\n<li>如果是主从<code>Redis</code>架构、哨兵<code>Redis</code>架构、集群<code>Redis</code>架构实现<code>Redlock</code>，只需要改变上述<code>config1</code>、<code>config2</code>、<code>config3</code>为主从模式、哨兵模式、集群模式配置即可，但相应需要<code>3</code>个独立的<code>Redis</code>主从集群、<code>3</code>个<code>Redis</code>独立的哨兵集群、<code>3</code>个独立的<code>Cluster</code>集群。</li>\n<li>以<code>sentinel</code>模式架构为例，<code>3</code>个<code>sentinel</code>模式集群，如果要获取分布式锁，那么需要向这<code>3</code>个<code>sentinel</code>集群通过<code>EVAL</code>命令执行<code>LUA</code>脚本，需要<code>3/2+1=2</code>，即至少2个<code>sentinel</code>集群响应成功，才算成功的以<code>Redlock</code>算法获取到分布式锁。</li>\n</ul>\n<h3 id=\"4-Redlock问题合集\"><a href=\"#4-Redlock问题合集\" class=\"headerlink\" title=\"4. Redlock问题合集\"></a>4. Redlock问题合集</h3><h4 id=\"4-1-N个节点的理解\"><a href=\"#4-1-N个节点的理解\" class=\"headerlink\" title=\"4.1 N个节点的理解\"></a>4.1 N个节点的理解</h4><p>假设我们用<code>N(&gt;=3)</code>个节点实现<code>Redlock</code>算法的分布式锁。<strong>不是</strong>一个有<code>N</code>个主节点的cluster集群；而是<strong>要么是<code>N</code>个redis单实例，要么是<code>N</code>个sentinel集群，要么是<code>N</code>个cluster集群</strong>。</p>\n<h4 id=\"4-2-失效时间如何设置\"><a href=\"#4-2-失效时间如何设置\" class=\"headerlink\" title=\"4.2 失效时间如何设置\"></a>4.2 失效时间如何设置</h4><p>这个问题的场景是，假设设置失效时间10秒，如果由于某些原因导致10秒还没执行完任务，这时候锁自动失效，导致其他线程也会拿到分布式锁。<br>这确实是Redis分布式最大的问题，不管是普通分布式锁，还是Redlock算法分布式锁，都没有解决这个问题。也有一些文章提出了对失效时间续租，即延长失效时间，很明显这又提升了分布式锁的复杂度（没有现成的框架有实现）。</p>\n<h4 id=\"4-3-redis分布式锁的高可用\"><a href=\"#4-3-redis分布式锁的高可用\" class=\"headerlink\" title=\"4.3 redis分布式锁的高可用\"></a>4.3 redis分布式锁的高可用</h4><p>关于Redis分布式锁的安全性问题，在分布式系统专家Martin Kleppmann和Redis的作者Antirez之间已经发生过一场争论。有兴趣的同学，搜索”基于Redis的分布式锁到底安全吗”就能得到你想要的答案，需要注意的是，有上下两篇（这应该就是传说中的神仙打架吧）。</p>\n<h4 id=\"4-4-使用Zookeeper还是Redis实现分布式锁\"><a href=\"#4-4-使用Zookeeper还是Redis实现分布式锁\" class=\"headerlink\" title=\"4.4 使用Zookeeper还是Redis实现分布式锁\"></a>4.4 使用Zookeeper还是Redis实现分布式锁</h4><p>没有绝对的好坏，只有更适合自己的业务。<br>就<strong>性能</strong>而言，<code>Redis</code>很明显优于<code>Zookeeper</code>；就分布式锁实现的健壮性(<strong>高可用</strong>)而言，<code>Zookeeper</code>很明显优于<code>Redis</code>。至于如何选择，还要看具体业务场景。</p>\n<blockquote>\n<p>参考：<a href=\"https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ\">https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ</a></p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h3 id=\"SETNX命令简介\"><a href=\"#SETNX命令简介\" class=\"headerlink\" title=\"SETNX命令简介\"></a>SETNX命令简介</h3><ul>\n<li><code>SETNX key value</code>返回(<code>1:key</code>的值被设置，<code>0:key</code>的值没被设置)，将<code>key</code>的值设为<code>value</code>，并且仅当<code>key</code>不存在。</li>\n<li>锁的<code>key</code>为目标数据的唯一键，<code>value</code>为锁的期望超时时间点；</li>\n<li>基于<code>Redis</code>实现的分布式锁，主要基于<code>redis</code>的<code>setnx（set if not exist）</code>命令；","more":"</li>\n</ul>\n<h3 id=\"1-jedis实现分布式锁\"><a href=\"#1-jedis实现分布式锁\" class=\"headerlink\" title=\"1. jedis实现分布式锁\"></a>1. jedis实现分布式锁</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>redis.clients<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jedis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-1-实现示例\"><a href=\"#1-1-实现示例\" class=\"headerlink\" title=\"1.1 实现示例:\"></a>1.1 实现示例:</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">correctGetLock</span><span class=\"params\">(String lockKey, String requestId, <span class=\"keyword\">int</span> expireTime)</span> </span>&#123;</span><br><span class=\"line\">    String result = jedis.set(lockKey, requestId, <span class=\"string\">&quot;NX&quot;</span>, <span class=\"string\">&quot;PX&quot;</span>, expireTime);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>jedis.set(String key, String value, String nxxx, String expx, int time)</code><br>    - **<code>key</code>**：保证唯一，用来当锁（<code>redis</code>记录的<code>key</code>）<br>    - **<code>value</code>**：<code>redis</code>记录的<code>value</code>，目的是为了标志锁的所有者（竞争锁的客户端），保证解锁时只能解自己加的锁。<code>requestId</code>可以使用<code>UUID.randomUUID().toString()</code>方法生成<br>    - **<code>nxxx</code>**：<code>&quot;NX&quot;</code>意思是<code>SET IF NOT EXIST</code>，即当<code>key</code>不存在时，我们进行<code>set</code>操作，若<code>key</code>已经存在，则不做任何操作<br>    - **<code>expx</code>**：<code>&quot;PX&quot;</code>意思是要给这个<code>key</code>加一个过期的设置（单位毫秒），过期时间由第五个参数决定<br>    - **<code>time</code>**：<code>expx</code>设置为<code>&quot;PX&quot;</code>时，<code>redis key</code>的过期时间</p>\n<h4 id=\"1-2-解锁示例\"><a href=\"#1-2-解锁示例\" class=\"headerlink\" title=\"1.2 解锁示例:\"></a>1.2 解锁示例:</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">correctReleaseLock</span><span class=\"params\">(String lockKey, String requestId)</span> </span>&#123;</span><br><span class=\"line\">    String script = <span class=\"string\">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class=\"line\">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>eval</code>命令执行<code>Lua</code>代码的时候，<code>Lua</code>代码将被当成一个命令去执行，并且直到<code>eval</code>命令执行完成，<code>Redis</code>才会执行其他命令，所以保证了检查和删除操作都是原子的。</p>\n<h4 id=\"1-3-这类琐最大的缺点\"><a href=\"#1-3-这类琐最大的缺点\" class=\"headerlink\" title=\"1.3 这类琐最大的缺点\"></a>1.3 这类琐最大的缺点</h4><p>加锁时只作用在一个<code>Redis</code>节点上，即使<code>Redis</code>通过<code>sentinel</code>保证高可用，如果这个<code>master</code>节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：</p>\n<ol>\n<li>在<code>Redis</code>的<code>master</code>节点上拿到了锁；</li>\n<li>但是这个加锁的<code>key</code>还没有同步到<code>slave</code>节点；</li>\n<li><code>master</code>故障，发生故障转移，<code>slave</code>节点升级为<code>master</code>节点；</li>\n<li>导致锁丢失。</li>\n</ol>\n<blockquote>\n<p>因此，<code>Redis</code>作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：<code>Redlock</code>。基于<code>Redis</code>的<code>Redisson</code>实现了<code>Redlock</code>。</p>\n</blockquote>\n<h3 id=\"2-Redisson实现普通分布式锁\"><a href=\"#2-Redisson实现普通分布式锁\" class=\"headerlink\" title=\"2. Redisson实现普通分布式锁\"></a>2. Redisson实现普通分布式锁</h3><p>普通分布式实现非常简单，无论是那种架构，向<code>Redis</code>通过<code>EVAL</code>命令执行<code>LUA脚本</code>即可。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.3.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>单机模式:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造redisson实现分布式锁必要的Config</span></span><br><span class=\"line\">Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config.useSingleServer().setAddress(<span class=\"string\">&quot;redis://172.29.1.180:5379&quot;</span>)</span><br><span class=\"line\">                        .setPassword(<span class=\"string\">&quot;a123456&quot;</span>).setDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 构造RedissonClient</span></span><br><span class=\"line\">RedissonClient redissonClient = Redisson.create(config);</span><br><span class=\"line\"><span class=\"comment\">// 设置锁定资源名称, 还可以getFairLock(), getReadWriteLock()</span></span><br><span class=\"line\">RLock lock = redissonClient.getLock(<span class=\"string\">&quot;DISLOCK&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isLock;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试获取分布式锁</span></span><br><span class=\"line\">    <span class=\"comment\">// 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。</span></span><br><span class=\"line\">    isLock = lock.tryLock(<span class=\"number\">500</span>, <span class=\"number\">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO if get lock success, do something;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 无论如何, 最后都要解锁</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>哨兵模式:</strong><br>即<code>Sentinel</code>模式，实现代码和单机模式几乎一样，唯一的不同就是<code>Config</code>的构造：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config.useSentinelServers().addSentinelAddress(</span><br><span class=\"line\">        <span class=\"string\">&quot;redis://172.29.3.245:26378&quot;</span>,<span class=\"string\">&quot;redis://172.29.3.245:26379&quot;</span>, <span class=\"string\">&quot;redis://172.29.3.245:26380&quot;</span>)</span><br><span class=\"line\">      .setMasterName(<span class=\"string\">&quot;mymaster&quot;</span>).setPassword(<span class=\"string\">&quot;a123456&quot;</span>).setDatabase(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>集群模式:</strong><br>即<code>Cluster</code>模式，集群模式构造<code>Config</code>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config.useClusterServers().addNodeAddress(</span><br><span class=\"line\">        <span class=\"string\">&quot;redis://172.29.3.245:6375&quot;</span>,<span class=\"string\">&quot;redis://172.29.3.245:6376&quot;</span>, <span class=\"string\">&quot;redis://172.29.3.245:6377&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;redis://172.29.3.245:6378&quot;</span>,<span class=\"string\">&quot;redis://172.29.3.245:6379&quot;</span>, <span class=\"string\">&quot;redis://172.29.3.245:6380&quot;</span>)</span><br><span class=\"line\">      .setPassword(<span class=\"string\">&quot;a123456&quot;</span>).setScanInterval(<span class=\"number\">5000</span>);\r```</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### <span class=\"number\">3.</span> Redisson实现Redlock分布式锁</span><br><span class=\"line\">#### <span class=\"number\">3.1</span> Redlock算法大概原理：</span><br><span class=\"line\">- 在`Redis`的分布式环境中，我们假设有`N`个`Redis master`。这些节点**完全互相独立，不存在主从复制或者其他集群协调机制**。我们确保将在`N`个实例上使用与在`Redis`单实例下相同方法获取和释放锁。</span><br><span class=\"line\">- 为了取到锁，客户端应该执行以下操作:</span><br><span class=\"line\">    - 获取当前`Unix`时间，以毫秒为单位。</span><br><span class=\"line\">    - 依次尝试从`N`个实例，使用相同的`key`和具有唯一性的`value`（例如UUID）获取锁。</span><br><span class=\"line\">    - 客户端使用当前时间减去开始获取锁时间（步骤<span class=\"number\">1</span>记录的时间）就得到获取锁使用的时间。</span><br><span class=\"line\">    - **当且仅当(N/<span class=\"number\">2</span>+<span class=\"number\">1</span>)的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功**，例如<span class=\"number\">3</span>个节点至少需要`<span class=\"number\">3</span>/<span class=\"number\">2</span>+<span class=\"number\">1</span>=<span class=\"number\">2</span>`<span class=\"number\">2</span>个。</span><br><span class=\"line\">    - 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤<span class=\"number\">3</span>计算的结果）。</span><br><span class=\"line\">    - 若获取锁失败，客户端应该在**所有的Redis实例上进行解锁**（即便某些Redis实例根本就没有加锁成功）。</span><br><span class=\"line\"></span><br><span class=\"line\">#### <span class=\"number\">3.2</span> 使用`Redlock`</span><br><span class=\"line\">单机模式`Redis`为例:</span><br><span class=\"line\">``` java</span><br><span class=\"line\">Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config.useClusterServers().addNodeAddress(</span><br><span class=\"line\">        <span class=\"string\">&quot;redis://127.0.0.1:6379&quot;</span>,<span class=\"string\">&quot;redis://127.0.0.1:6369&quot;</span>, <span class=\"string\">&quot;redis://127.0.0.1:6359&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;redis://127.0.0.1:6349&quot;</span>,<span class=\"string\">&quot;redis://127.0.0.1:6339&quot;</span>)</span><br><span class=\"line\">        .setPassword(<span class=\"string\">&quot;******&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 节点1</span></span><br><span class=\"line\">Config config1 = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config1.useSingleServer().setAddress(<span class=\"string\">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class=\"line\">RedissonClient redissonClient1 = Redisson.create(config1);</span><br><span class=\"line\"><span class=\"comment\">// 节点2</span></span><br><span class=\"line\">Config config2 = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config2.useSingleServer().setAddress(<span class=\"string\">&quot;redis://127.0.0.1:6378&quot;</span>);</span><br><span class=\"line\">RedissonClient redissonClient2 = Redisson.create(config2);</span><br><span class=\"line\"><span class=\"comment\">// 节点3</span></span><br><span class=\"line\">Config config3 = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config3.useSingleServer().setAddress(<span class=\"string\">&quot;redis://127.0.0.1:6377&quot;</span>);</span><br><span class=\"line\">RedissonClient redissonClient3 = Redisson.create(config3);</span><br><span class=\"line\"><span class=\"comment\">// 设置锁定资源名称</span></span><br><span class=\"line\">String resourceName = <span class=\"string\">&quot;REDLOCK&quot;</span>;</span><br><span class=\"line\">RLock lock1 = redissonClient1.getLock(resourceName);</span><br><span class=\"line\">RLock lock2 = redissonClient2.getLock(resourceName);</span><br><span class=\"line\">RLock lock3 = redissonClient3.getLock(resourceName);</span><br><span class=\"line\"><span class=\"comment\">// 实例化RedissonRedLock</span></span><br><span class=\"line\">RedissonRedLock redLock = <span class=\"keyword\">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isLock = redLock.tryLock(<span class=\"number\">500</span>, <span class=\"number\">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO if get lock success, do something;</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">30000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//解锁</span></span><br><span class=\"line\">    redLock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最核心的变化就是 <code>RedissonRedLock redLock</code>=**<code>new RedissonRedLock(lock1,lock2,lock3)</code>;**，因为我这里是以三个节点为例。</p>\n<ul>\n<li>如果是主从<code>Redis</code>架构、哨兵<code>Redis</code>架构、集群<code>Redis</code>架构实现<code>Redlock</code>，只需要改变上述<code>config1</code>、<code>config2</code>、<code>config3</code>为主从模式、哨兵模式、集群模式配置即可，但相应需要<code>3</code>个独立的<code>Redis</code>主从集群、<code>3</code>个<code>Redis</code>独立的哨兵集群、<code>3</code>个独立的<code>Cluster</code>集群。</li>\n<li>以<code>sentinel</code>模式架构为例，<code>3</code>个<code>sentinel</code>模式集群，如果要获取分布式锁，那么需要向这<code>3</code>个<code>sentinel</code>集群通过<code>EVAL</code>命令执行<code>LUA</code>脚本，需要<code>3/2+1=2</code>，即至少2个<code>sentinel</code>集群响应成功，才算成功的以<code>Redlock</code>算法获取到分布式锁。</li>\n</ul>\n<h3 id=\"4-Redlock问题合集\"><a href=\"#4-Redlock问题合集\" class=\"headerlink\" title=\"4. Redlock问题合集\"></a>4. Redlock问题合集</h3><h4 id=\"4-1-N个节点的理解\"><a href=\"#4-1-N个节点的理解\" class=\"headerlink\" title=\"4.1 N个节点的理解\"></a>4.1 N个节点的理解</h4><p>假设我们用<code>N(&gt;=3)</code>个节点实现<code>Redlock</code>算法的分布式锁。<strong>不是</strong>一个有<code>N</code>个主节点的cluster集群；而是<strong>要么是<code>N</code>个redis单实例，要么是<code>N</code>个sentinel集群，要么是<code>N</code>个cluster集群</strong>。</p>\n<h4 id=\"4-2-失效时间如何设置\"><a href=\"#4-2-失效时间如何设置\" class=\"headerlink\" title=\"4.2 失效时间如何设置\"></a>4.2 失效时间如何设置</h4><p>这个问题的场景是，假设设置失效时间10秒，如果由于某些原因导致10秒还没执行完任务，这时候锁自动失效，导致其他线程也会拿到分布式锁。<br>这确实是Redis分布式最大的问题，不管是普通分布式锁，还是Redlock算法分布式锁，都没有解决这个问题。也有一些文章提出了对失效时间续租，即延长失效时间，很明显这又提升了分布式锁的复杂度（没有现成的框架有实现）。</p>\n<h4 id=\"4-3-redis分布式锁的高可用\"><a href=\"#4-3-redis分布式锁的高可用\" class=\"headerlink\" title=\"4.3 redis分布式锁的高可用\"></a>4.3 redis分布式锁的高可用</h4><p>关于Redis分布式锁的安全性问题，在分布式系统专家Martin Kleppmann和Redis的作者Antirez之间已经发生过一场争论。有兴趣的同学，搜索”基于Redis的分布式锁到底安全吗”就能得到你想要的答案，需要注意的是，有上下两篇（这应该就是传说中的神仙打架吧）。</p>\n<h4 id=\"4-4-使用Zookeeper还是Redis实现分布式锁\"><a href=\"#4-4-使用Zookeeper还是Redis实现分布式锁\" class=\"headerlink\" title=\"4.4 使用Zookeeper还是Redis实现分布式锁\"></a>4.4 使用Zookeeper还是Redis实现分布式锁</h4><p>没有绝对的好坏，只有更适合自己的业务。<br>就<strong>性能</strong>而言，<code>Redis</code>很明显优于<code>Zookeeper</code>；就分布式锁实现的健壮性(<strong>高可用</strong>)而言，<code>Zookeeper</code>很明显优于<code>Redis</code>。至于如何选择，还要看具体业务场景。</p>\n<blockquote>\n<p>参考：<a href=\"https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ\">https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ</a></p>\n</blockquote>"},{"title":"【Redis】深入学习Redis及集群","date":"2019-09-20T08:19:26.000Z","_content":"\n\nRedis本质上是一个Key-Value类型的**内存数据库**，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。<!-- more -->Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB。另外Redis也可以对存入的Key-Value设置expire时间。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。\n\n### 1. Redis数据结构及命令操作\n#### 1.1 基本概念及操作\n+ 默认16个数据库，类似数组下表从零开始，初始默认使用零号库；\n+ 统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379；\n+ select命令切换数据库：select 0-15；\n+ dbsize：查看当前数据库的key的数量；\n+ flushdb：清空当前库；\n+ flushall；通杀全部库；\n\n#### 1.2 Redis数据结构\nredis存储的是：key-value格式的数据，其中key都是字符串，value有5种不同的数据结构:String、Hash、List、Set、Zset(Sorted Set)\n1. String：set, get, del, append, strlen\n2. Hash：hset, hget, hdel, hmset(批量设值), hmget, hgetall\n3. List：lpush, rpush, lrange, lpop(删除), rpop, lindex\n4. Set：sadd, smembers, srem(根据可以移除member), sismember(判断是否为key的成员)\n5. ZSet：zadd, zrange, zrem\n\n\n#### 1.3 Redis键(key)--常用命令介绍\n+ keys *：查看所有 key ；\n+ exists key的名字：判断某个 key 是否存在；\n+ move key dbID（0-15）： 当前库就没有了，被移除了；\n+ expire key 秒钟： 为给定的 key 设置过期时间；\n+ ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期；\n+ type key： 查看你的 key 是什么类型；\n\n### 2. Redis持久化\nRedis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，为了避免内存中数据丢失，Redis提供了RDB和AOF两种不同的数据持久化方式。\n\n#### 2.1 RDB（Redis DataBase）\nRDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。\n- 开启RDB持久化方式一：save命令，或bgsave(异步)\n- 开启方式二：在Redis配置文件redis.conf配置，配置完后启动时加载：`redis-server redis.conf`\n\n``` json\nsave 900 1     # 900s内至少达到一条写命令\nsave 300 10    # 300s内至少达至10条写命令\nsave 60 10000  # 60s内至少达到10000条写命令\n```\n\n+ RDB的几个优点\n    + 与AOF方式相比，通过rdb文件恢复数据比较快。\n    + rdb文件非常紧凑，适合于数据备份。\n    + 通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。\n\n+ RDB的几个缺点\n    + 如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。\n    + 使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。\n    + 使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。\n\n#### 2.2 AOF(Append-only file)\n与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令（以日志的形式），并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。\n- 开启方式：在Redis配置文件redis.conf配置\n\n``` json\nappendonly yes                  # 开启aof机制\nappendfilename \"appendonly.aof\" # aof文件名\n# 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec(每秒写入一次)或no(操作系统处理)\nappendfsync always\nno-appendfsync-on-rewrite no    # 默认不重写aof文件\ndir ~/redis/                    # 保存目录\n```\n\n- aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决，Redis通过重写aof，可以生成一个恢复当前数据的最少命令集，两种方式：配置no-appendfsync-on-rewrite(默认no)，或者客户端向服务器发送bgrewriteaof命令\n\n* AOF的优点：AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。\n* AOF的缺点：AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。恢复数据的速度比RDB慢。\n* 当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。\n\n##### 2.2.1 AOF文件修复\n1. 备份被写坏的AOF文件\n2. 运行redis-check-aof –fix进行修复\n3. 用diff -u来看下两个文件的差异，确认问题点\n4. 重启redis，加载修复后的AOF文件\n\n\n### 3. Redis的高并发和快速原因\n1. redis是基于内存的，内存的读写速度非常快；\n2. redis是单线程的，省去了很多上下文切换线程的时间；\n3. redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。\n4. 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。\n5. 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。\n\n\n### 4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用\n1. 哨兵(Sentinel)：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。\n    1. 集群监控：负责监控Redis master和slave进程是否正常工作\n    2. 消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员\n    3. 故障转移：如果master node挂掉了，会自动转移到slave node上\n    4. 配置中心：如果故障转移发生了，通知client客户端新的master地址\n2. 复制(Replication)：则是负责让一个Redis服务器可以配备多个备份的服务器。\n    1. 从数据库向主数据库发送sync(数据同步)命令。\n    2. 主数据库接收同步命令后，会保存快照，创建一个RDB文件。\n    3. 当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。\n    4. 主数据库将缓冲区的所有写命令发给从服务器执行。\n    5. 以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。\n\n\n### 5. Redis 主从复制、哨兵和集群这三个有什么区别\n主从复制是为了数据备份，哨兵是为了高可用，Redis主服务器挂了哨兵可以切换，集群则是因为单实例能力有限，搞多个分散压力。\n1. 主从模式：读写分离，备份，一个Master可以有多个Slaves。\n2. 哨兵entinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。\n3. 集群Cluster：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。\n\n\n### 6. Redis Cluster集群\nRedis Cluster，是Redis 3.0开始引入的分布式存储方案。\n集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。\n* 集群的作用：\n    1. 数据分区：数据分区(或称数据分片)是集群最核心的功能。\n    2. 高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。\n\n#### 6.1 Redis Cluster集群的搭建可以分为四步：\n1. **启动节点**：将节点以集群模式启动，此时节点是独立的，并没有建立联系；\n2. **节点握手**：让独立的节点连成一个网络；\n3. **分配槽**：将16384个槽分配给主节点；\n4. **指定主从关系**：为从节点指定主节点。\n\n#### 6.2 Redis Cluster工作原理\n+ 客户端与Redis节点直连,不需要中间Proxy层，直接连接任意一个Master节点\n+ 根据公式`HASH_SLOT=CRC16(key) mod 16384`，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作\n\n```\n         CRC16(key)    |  0~5460   | <--Slot--|Redis(M)|<---|Redis(S可多个从)\n         mode 16384    |\nClient --------------> | 5461~10922| <--Slot--|Redis(M)|<---|Redis(S可多个从)\n                       |\n                       |10923~10383| <--Slot--|Redis(M)|<---|Redis(S可多个从)\n\n```\n\n\n#### 6.3 Redis Cluster优点:\n1. 无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master\n2. 可以进行水平扩容\n3. 支持自动化迁移，当出现某个Slave宕机了，那么就只有Master了，这时候的高可用性就无法很好的保证了，万一master也宕机了，咋办呢？ 针对这种情况，如果说其他Master有多余的Slave ，集群自动把多余的Slave迁移到没有Slave的Master 中。\n\n#### 6.4 Redis Cluster缺点:\n1. 批量操作是个坑（不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通）\n2. 资源隔离性较差，容易出现相互影响的情况。\n\n\n#### 6.5 Redis Cluster总结：\n1. Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效。\n2. 单机下的redis可以支持16个数据库（db0 ~ db15），在Redis Cluster集群架构下只有一个数据库空间，即db0。\n3. 不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通。\n4. 如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上。\n5. Redis集群模式下进行批量操作：如果执行的key数量比较少，就用串行get操作； 如果需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。\n6. Redis Cluster的架构，是属于分片集群的架构，不做读写分离，因为redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。\n\n","source":"_posts/【Redis】深入学习Redis及集群.md","raw":"---\ntitle: 【Redis】深入学习Redis及集群\ndate: 2019-09-20 16:19:26\ntags: [后端开发, Redis]\ncategories: Redis\n---\n\n\nRedis本质上是一个Key-Value类型的**内存数据库**，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。<!-- more -->Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB。另外Redis也可以对存入的Key-Value设置expire时间。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。\n\n### 1. Redis数据结构及命令操作\n#### 1.1 基本概念及操作\n+ 默认16个数据库，类似数组下表从零开始，初始默认使用零号库；\n+ 统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379；\n+ select命令切换数据库：select 0-15；\n+ dbsize：查看当前数据库的key的数量；\n+ flushdb：清空当前库；\n+ flushall；通杀全部库；\n\n#### 1.2 Redis数据结构\nredis存储的是：key-value格式的数据，其中key都是字符串，value有5种不同的数据结构:String、Hash、List、Set、Zset(Sorted Set)\n1. String：set, get, del, append, strlen\n2. Hash：hset, hget, hdel, hmset(批量设值), hmget, hgetall\n3. List：lpush, rpush, lrange, lpop(删除), rpop, lindex\n4. Set：sadd, smembers, srem(根据可以移除member), sismember(判断是否为key的成员)\n5. ZSet：zadd, zrange, zrem\n\n\n#### 1.3 Redis键(key)--常用命令介绍\n+ keys *：查看所有 key ；\n+ exists key的名字：判断某个 key 是否存在；\n+ move key dbID（0-15）： 当前库就没有了，被移除了；\n+ expire key 秒钟： 为给定的 key 设置过期时间；\n+ ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期；\n+ type key： 查看你的 key 是什么类型；\n\n### 2. Redis持久化\nRedis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，为了避免内存中数据丢失，Redis提供了RDB和AOF两种不同的数据持久化方式。\n\n#### 2.1 RDB（Redis DataBase）\nRDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。\n- 开启RDB持久化方式一：save命令，或bgsave(异步)\n- 开启方式二：在Redis配置文件redis.conf配置，配置完后启动时加载：`redis-server redis.conf`\n\n``` json\nsave 900 1     # 900s内至少达到一条写命令\nsave 300 10    # 300s内至少达至10条写命令\nsave 60 10000  # 60s内至少达到10000条写命令\n```\n\n+ RDB的几个优点\n    + 与AOF方式相比，通过rdb文件恢复数据比较快。\n    + rdb文件非常紧凑，适合于数据备份。\n    + 通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。\n\n+ RDB的几个缺点\n    + 如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。\n    + 使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。\n    + 使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。\n\n#### 2.2 AOF(Append-only file)\n与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令（以日志的形式），并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。\n- 开启方式：在Redis配置文件redis.conf配置\n\n``` json\nappendonly yes                  # 开启aof机制\nappendfilename \"appendonly.aof\" # aof文件名\n# 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec(每秒写入一次)或no(操作系统处理)\nappendfsync always\nno-appendfsync-on-rewrite no    # 默认不重写aof文件\ndir ~/redis/                    # 保存目录\n```\n\n- aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决，Redis通过重写aof，可以生成一个恢复当前数据的最少命令集，两种方式：配置no-appendfsync-on-rewrite(默认no)，或者客户端向服务器发送bgrewriteaof命令\n\n* AOF的优点：AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。\n* AOF的缺点：AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。恢复数据的速度比RDB慢。\n* 当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。\n\n##### 2.2.1 AOF文件修复\n1. 备份被写坏的AOF文件\n2. 运行redis-check-aof –fix进行修复\n3. 用diff -u来看下两个文件的差异，确认问题点\n4. 重启redis，加载修复后的AOF文件\n\n\n### 3. Redis的高并发和快速原因\n1. redis是基于内存的，内存的读写速度非常快；\n2. redis是单线程的，省去了很多上下文切换线程的时间；\n3. redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。\n4. 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。\n5. 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。\n\n\n### 4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用\n1. 哨兵(Sentinel)：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。\n    1. 集群监控：负责监控Redis master和slave进程是否正常工作\n    2. 消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员\n    3. 故障转移：如果master node挂掉了，会自动转移到slave node上\n    4. 配置中心：如果故障转移发生了，通知client客户端新的master地址\n2. 复制(Replication)：则是负责让一个Redis服务器可以配备多个备份的服务器。\n    1. 从数据库向主数据库发送sync(数据同步)命令。\n    2. 主数据库接收同步命令后，会保存快照，创建一个RDB文件。\n    3. 当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。\n    4. 主数据库将缓冲区的所有写命令发给从服务器执行。\n    5. 以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。\n\n\n### 5. Redis 主从复制、哨兵和集群这三个有什么区别\n主从复制是为了数据备份，哨兵是为了高可用，Redis主服务器挂了哨兵可以切换，集群则是因为单实例能力有限，搞多个分散压力。\n1. 主从模式：读写分离，备份，一个Master可以有多个Slaves。\n2. 哨兵entinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。\n3. 集群Cluster：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。\n\n\n### 6. Redis Cluster集群\nRedis Cluster，是Redis 3.0开始引入的分布式存储方案。\n集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。\n* 集群的作用：\n    1. 数据分区：数据分区(或称数据分片)是集群最核心的功能。\n    2. 高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。\n\n#### 6.1 Redis Cluster集群的搭建可以分为四步：\n1. **启动节点**：将节点以集群模式启动，此时节点是独立的，并没有建立联系；\n2. **节点握手**：让独立的节点连成一个网络；\n3. **分配槽**：将16384个槽分配给主节点；\n4. **指定主从关系**：为从节点指定主节点。\n\n#### 6.2 Redis Cluster工作原理\n+ 客户端与Redis节点直连,不需要中间Proxy层，直接连接任意一个Master节点\n+ 根据公式`HASH_SLOT=CRC16(key) mod 16384`，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作\n\n```\n         CRC16(key)    |  0~5460   | <--Slot--|Redis(M)|<---|Redis(S可多个从)\n         mode 16384    |\nClient --------------> | 5461~10922| <--Slot--|Redis(M)|<---|Redis(S可多个从)\n                       |\n                       |10923~10383| <--Slot--|Redis(M)|<---|Redis(S可多个从)\n\n```\n\n\n#### 6.3 Redis Cluster优点:\n1. 无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master\n2. 可以进行水平扩容\n3. 支持自动化迁移，当出现某个Slave宕机了，那么就只有Master了，这时候的高可用性就无法很好的保证了，万一master也宕机了，咋办呢？ 针对这种情况，如果说其他Master有多余的Slave ，集群自动把多余的Slave迁移到没有Slave的Master 中。\n\n#### 6.4 Redis Cluster缺点:\n1. 批量操作是个坑（不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通）\n2. 资源隔离性较差，容易出现相互影响的情况。\n\n\n#### 6.5 Redis Cluster总结：\n1. Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效。\n2. 单机下的redis可以支持16个数据库（db0 ~ db15），在Redis Cluster集群架构下只有一个数据库空间，即db0。\n3. 不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通。\n4. 如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上。\n5. Redis集群模式下进行批量操作：如果执行的key数量比较少，就用串行get操作； 如果需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。\n6. Redis Cluster的架构，是属于分片集群的架构，不做读写分离，因为redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。\n\n","slug":"【Redis】深入学习Redis及集群","published":1,"updated":"2021-12-12T02:50:23.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6uz000bvcueg9qrafrv","content":"<p>Redis本质上是一个Key-Value类型的<strong>内存数据库</strong>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。<span id=\"more\"></span>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB。另外Redis也可以对存入的Key-Value设置expire时间。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>\n<h3 id=\"1-Redis数据结构及命令操作\"><a href=\"#1-Redis数据结构及命令操作\" class=\"headerlink\" title=\"1. Redis数据结构及命令操作\"></a>1. Redis数据结构及命令操作</h3><h4 id=\"1-1-基本概念及操作\"><a href=\"#1-1-基本概念及操作\" class=\"headerlink\" title=\"1.1 基本概念及操作\"></a>1.1 基本概念及操作</h4><ul>\n<li>默认16个数据库，类似数组下表从零开始，初始默认使用零号库；</li>\n<li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379；</li>\n<li>select命令切换数据库：select 0-15；</li>\n<li>dbsize：查看当前数据库的key的数量；</li>\n<li>flushdb：清空当前库；</li>\n<li>flushall；通杀全部库；</li>\n</ul>\n<h4 id=\"1-2-Redis数据结构\"><a href=\"#1-2-Redis数据结构\" class=\"headerlink\" title=\"1.2 Redis数据结构\"></a>1.2 Redis数据结构</h4><p>redis存储的是：key-value格式的数据，其中key都是字符串，value有5种不同的数据结构:String、Hash、List、Set、Zset(Sorted Set)</p>\n<ol>\n<li>String：set, get, del, append, strlen</li>\n<li>Hash：hset, hget, hdel, hmset(批量设值), hmget, hgetall</li>\n<li>List：lpush, rpush, lrange, lpop(删除), rpop, lindex</li>\n<li>Set：sadd, smembers, srem(根据可以移除member), sismember(判断是否为key的成员)</li>\n<li>ZSet：zadd, zrange, zrem</li>\n</ol>\n<h4 id=\"1-3-Redis键-key-–常用命令介绍\"><a href=\"#1-3-Redis键-key-–常用命令介绍\" class=\"headerlink\" title=\"1.3 Redis键(key)–常用命令介绍\"></a>1.3 Redis键(key)–常用命令介绍</h4><ul>\n<li>keys *：查看所有 key ；</li>\n<li>exists key的名字：判断某个 key 是否存在；</li>\n<li>move key dbID（0-15）： 当前库就没有了，被移除了；</li>\n<li>expire key 秒钟： 为给定的 key 设置过期时间；</li>\n<li>ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期；</li>\n<li>type key： 查看你的 key 是什么类型；</li>\n</ul>\n<h3 id=\"2-Redis持久化\"><a href=\"#2-Redis持久化\" class=\"headerlink\" title=\"2. Redis持久化\"></a>2. Redis持久化</h3><p>Redis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，为了避免内存中数据丢失，Redis提供了RDB和AOF两种不同的数据持久化方式。</p>\n<h4 id=\"2-1-RDB（Redis-DataBase）\"><a href=\"#2-1-RDB（Redis-DataBase）\" class=\"headerlink\" title=\"2.1 RDB（Redis DataBase）\"></a>2.1 RDB（Redis DataBase）</h4><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p>\n<ul>\n<li>开启RDB持久化方式一：save命令，或bgsave(异步)</li>\n<li>开启方式二：在Redis配置文件redis.conf配置，配置完后启动时加载：<code>redis-server redis.conf</code></li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save <span class=\"number\">900</span> <span class=\"number\">1</span>     # <span class=\"number\">900</span>s内至少达到一条写命令</span><br><span class=\"line\">save <span class=\"number\">300</span> <span class=\"number\">10</span>    # <span class=\"number\">300</span>s内至少达至<span class=\"number\">10</span>条写命令</span><br><span class=\"line\">save <span class=\"number\">60</span> <span class=\"number\">10000</span>  # <span class=\"number\">60</span>s内至少达到<span class=\"number\">10000</span>条写命令</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>RDB的几个优点</p>\n<ul>\n<li>与AOF方式相比，通过rdb文件恢复数据比较快。</li>\n<li>rdb文件非常紧凑，适合于数据备份。</li>\n<li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li>\n</ul>\n</li>\n<li><p>RDB的几个缺点</p>\n<ul>\n<li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li>\n<li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li>\n<li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-AOF-Append-only-file\"><a href=\"#2-2-AOF-Append-only-file\" class=\"headerlink\" title=\"2.2 AOF(Append-only file)\"></a>2.2 AOF(Append-only file)</h4><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令（以日志的形式），并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p>\n<ul>\n<li>开启方式：在Redis配置文件redis.conf配置</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendonly yes                  # 开启aof机制</span><br><span class=\"line\">appendfilename <span class=\"string\">&quot;appendonly.aof&quot;</span> # aof文件名</span><br><span class=\"line\"># 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec(每秒写入一次)或no(操作系统处理)</span><br><span class=\"line\">appendfsync always</span><br><span class=\"line\">no-appendfsync-on-rewrite no    # 默认不重写aof文件</span><br><span class=\"line\">dir ~/redis/                    # 保存目录</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决，Redis通过重写aof，可以生成一个恢复当前数据的最少命令集，两种方式：配置no-appendfsync-on-rewrite(默认no)，或者客户端向服务器发送bgrewriteaof命令</li>\n</ul>\n<ul>\n<li>AOF的优点：AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li>\n<li>AOF的缺点：AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。恢复数据的速度比RDB慢。</li>\n<li>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</li>\n</ul>\n<h5 id=\"2-2-1-AOF文件修复\"><a href=\"#2-2-1-AOF文件修复\" class=\"headerlink\" title=\"2.2.1 AOF文件修复\"></a>2.2.1 AOF文件修复</h5><ol>\n<li>备份被写坏的AOF文件</li>\n<li>运行redis-check-aof –fix进行修复</li>\n<li>用diff -u来看下两个文件的差异，确认问题点</li>\n<li>重启redis，加载修复后的AOF文件</li>\n</ol>\n<h3 id=\"3-Redis的高并发和快速原因\"><a href=\"#3-Redis的高并发和快速原因\" class=\"headerlink\" title=\"3. Redis的高并发和快速原因\"></a>3. Redis的高并发和快速原因</h3><ol>\n<li>redis是基于内存的，内存的读写速度非常快；</li>\n<li>redis是单线程的，省去了很多上下文切换线程的时间；</li>\n<li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</li>\n<li>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</li>\n<li>还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li>\n</ol>\n<h3 id=\"4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用\"><a href=\"#4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用\" class=\"headerlink\" title=\"4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用\"></a>4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用</h3><ol>\n<li>哨兵(Sentinel)：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。<ol>\n<li>集群监控：负责监控Redis master和slave进程是否正常工作</li>\n<li>消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li>\n<li>故障转移：如果master node挂掉了，会自动转移到slave node上</li>\n<li>配置中心：如果故障转移发生了，通知client客户端新的master地址</li>\n</ol>\n</li>\n<li>复制(Replication)：则是负责让一个Redis服务器可以配备多个备份的服务器。<ol>\n<li>从数据库向主数据库发送sync(数据同步)命令。</li>\n<li>主数据库接收同步命令后，会保存快照，创建一个RDB文件。</li>\n<li>当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。</li>\n<li>主数据库将缓冲区的所有写命令发给从服务器执行。</li>\n<li>以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5-Redis-主从复制、哨兵和集群这三个有什么区别\"><a href=\"#5-Redis-主从复制、哨兵和集群这三个有什么区别\" class=\"headerlink\" title=\"5. Redis 主从复制、哨兵和集群这三个有什么区别\"></a>5. Redis 主从复制、哨兵和集群这三个有什么区别</h3><p>主从复制是为了数据备份，哨兵是为了高可用，Redis主服务器挂了哨兵可以切换，集群则是因为单实例能力有限，搞多个分散压力。</p>\n<ol>\n<li>主从模式：读写分离，备份，一个Master可以有多个Slaves。</li>\n<li>哨兵entinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。</li>\n<li>集群Cluster：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。</li>\n</ol>\n<h3 id=\"6-Redis-Cluster集群\"><a href=\"#6-Redis-Cluster集群\" class=\"headerlink\" title=\"6. Redis Cluster集群\"></a>6. Redis Cluster集群</h3><p>Redis Cluster，是Redis 3.0开始引入的分布式存储方案。<br>集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。</p>\n<ul>\n<li>集群的作用：<ol>\n<li>数据分区：数据分区(或称数据分片)是集群最核心的功能。</li>\n<li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"6-1-Redis-Cluster集群的搭建可以分为四步：\"><a href=\"#6-1-Redis-Cluster集群的搭建可以分为四步：\" class=\"headerlink\" title=\"6.1 Redis Cluster集群的搭建可以分为四步：\"></a>6.1 Redis Cluster集群的搭建可以分为四步：</h4><ol>\n<li><strong>启动节点</strong>：将节点以集群模式启动，此时节点是独立的，并没有建立联系；</li>\n<li><strong>节点握手</strong>：让独立的节点连成一个网络；</li>\n<li><strong>分配槽</strong>：将16384个槽分配给主节点；</li>\n<li><strong>指定主从关系</strong>：为从节点指定主节点。</li>\n</ol>\n<h4 id=\"6-2-Redis-Cluster工作原理\"><a href=\"#6-2-Redis-Cluster工作原理\" class=\"headerlink\" title=\"6.2 Redis Cluster工作原理\"></a>6.2 Redis Cluster工作原理</h4><ul>\n<li>客户端与Redis节点直连,不需要中间Proxy层，直接连接任意一个Master节点</li>\n<li>根据公式<code>HASH_SLOT=CRC16(key) mod 16384</code>，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         CRC16(key)    |  0~5460   | &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class=\"line\">         mode 16384    |</span><br><span class=\"line\">Client --------------&gt; | 5461~10922| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class=\"line\">                       |</span><br><span class=\"line\">                       |10923~10383| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"6-3-Redis-Cluster优点\"><a href=\"#6-3-Redis-Cluster优点\" class=\"headerlink\" title=\"6.3 Redis Cluster优点:\"></a>6.3 Redis Cluster优点:</h4><ol>\n<li>无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master</li>\n<li>可以进行水平扩容</li>\n<li>支持自动化迁移，当出现某个Slave宕机了，那么就只有Master了，这时候的高可用性就无法很好的保证了，万一master也宕机了，咋办呢？ 针对这种情况，如果说其他Master有多余的Slave ，集群自动把多余的Slave迁移到没有Slave的Master 中。</li>\n</ol>\n<h4 id=\"6-4-Redis-Cluster缺点\"><a href=\"#6-4-Redis-Cluster缺点\" class=\"headerlink\" title=\"6.4 Redis Cluster缺点:\"></a>6.4 Redis Cluster缺点:</h4><ol>\n<li>批量操作是个坑（不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通）</li>\n<li>资源隔离性较差，容易出现相互影响的情况。</li>\n</ol>\n<h4 id=\"6-5-Redis-Cluster总结：\"><a href=\"#6-5-Redis-Cluster总结：\" class=\"headerlink\" title=\"6.5 Redis Cluster总结：\"></a>6.5 Redis Cluster总结：</h4><ol>\n<li>Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效。</li>\n<li>单机下的redis可以支持16个数据库（db0 ~ db15），在Redis Cluster集群架构下只有一个数据库空间，即db0。</li>\n<li>不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通。</li>\n<li>如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上。</li>\n<li>Redis集群模式下进行批量操作：如果执行的key数量比较少，就用串行get操作； 如果需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。</li>\n<li>Redis Cluster的架构，是属于分片集群的架构，不做读写分离，因为redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<p>Redis本质上是一个Key-Value类型的<strong>内存数据库</strong>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。","more":"Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB。另外Redis也可以对存入的Key-Value设置expire时间。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>\n<h3 id=\"1-Redis数据结构及命令操作\"><a href=\"#1-Redis数据结构及命令操作\" class=\"headerlink\" title=\"1. Redis数据结构及命令操作\"></a>1. Redis数据结构及命令操作</h3><h4 id=\"1-1-基本概念及操作\"><a href=\"#1-1-基本概念及操作\" class=\"headerlink\" title=\"1.1 基本概念及操作\"></a>1.1 基本概念及操作</h4><ul>\n<li>默认16个数据库，类似数组下表从零开始，初始默认使用零号库；</li>\n<li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379；</li>\n<li>select命令切换数据库：select 0-15；</li>\n<li>dbsize：查看当前数据库的key的数量；</li>\n<li>flushdb：清空当前库；</li>\n<li>flushall；通杀全部库；</li>\n</ul>\n<h4 id=\"1-2-Redis数据结构\"><a href=\"#1-2-Redis数据结构\" class=\"headerlink\" title=\"1.2 Redis数据结构\"></a>1.2 Redis数据结构</h4><p>redis存储的是：key-value格式的数据，其中key都是字符串，value有5种不同的数据结构:String、Hash、List、Set、Zset(Sorted Set)</p>\n<ol>\n<li>String：set, get, del, append, strlen</li>\n<li>Hash：hset, hget, hdel, hmset(批量设值), hmget, hgetall</li>\n<li>List：lpush, rpush, lrange, lpop(删除), rpop, lindex</li>\n<li>Set：sadd, smembers, srem(根据可以移除member), sismember(判断是否为key的成员)</li>\n<li>ZSet：zadd, zrange, zrem</li>\n</ol>\n<h4 id=\"1-3-Redis键-key-–常用命令介绍\"><a href=\"#1-3-Redis键-key-–常用命令介绍\" class=\"headerlink\" title=\"1.3 Redis键(key)–常用命令介绍\"></a>1.3 Redis键(key)–常用命令介绍</h4><ul>\n<li>keys *：查看所有 key ；</li>\n<li>exists key的名字：判断某个 key 是否存在；</li>\n<li>move key dbID（0-15）： 当前库就没有了，被移除了；</li>\n<li>expire key 秒钟： 为给定的 key 设置过期时间；</li>\n<li>ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期；</li>\n<li>type key： 查看你的 key 是什么类型；</li>\n</ul>\n<h3 id=\"2-Redis持久化\"><a href=\"#2-Redis持久化\" class=\"headerlink\" title=\"2. Redis持久化\"></a>2. Redis持久化</h3><p>Redis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，为了避免内存中数据丢失，Redis提供了RDB和AOF两种不同的数据持久化方式。</p>\n<h4 id=\"2-1-RDB（Redis-DataBase）\"><a href=\"#2-1-RDB（Redis-DataBase）\" class=\"headerlink\" title=\"2.1 RDB（Redis DataBase）\"></a>2.1 RDB（Redis DataBase）</h4><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p>\n<ul>\n<li>开启RDB持久化方式一：save命令，或bgsave(异步)</li>\n<li>开启方式二：在Redis配置文件redis.conf配置，配置完后启动时加载：<code>redis-server redis.conf</code></li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save <span class=\"number\">900</span> <span class=\"number\">1</span>     # <span class=\"number\">900</span>s内至少达到一条写命令</span><br><span class=\"line\">save <span class=\"number\">300</span> <span class=\"number\">10</span>    # <span class=\"number\">300</span>s内至少达至<span class=\"number\">10</span>条写命令</span><br><span class=\"line\">save <span class=\"number\">60</span> <span class=\"number\">10000</span>  # <span class=\"number\">60</span>s内至少达到<span class=\"number\">10000</span>条写命令</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>RDB的几个优点</p>\n<ul>\n<li>与AOF方式相比，通过rdb文件恢复数据比较快。</li>\n<li>rdb文件非常紧凑，适合于数据备份。</li>\n<li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li>\n</ul>\n</li>\n<li><p>RDB的几个缺点</p>\n<ul>\n<li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li>\n<li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li>\n<li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-AOF-Append-only-file\"><a href=\"#2-2-AOF-Append-only-file\" class=\"headerlink\" title=\"2.2 AOF(Append-only file)\"></a>2.2 AOF(Append-only file)</h4><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令（以日志的形式），并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p>\n<ul>\n<li>开启方式：在Redis配置文件redis.conf配置</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendonly yes                  # 开启aof机制</span><br><span class=\"line\">appendfilename <span class=\"string\">&quot;appendonly.aof&quot;</span> # aof文件名</span><br><span class=\"line\"># 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec(每秒写入一次)或no(操作系统处理)</span><br><span class=\"line\">appendfsync always</span><br><span class=\"line\">no-appendfsync-on-rewrite no    # 默认不重写aof文件</span><br><span class=\"line\">dir ~/redis/                    # 保存目录</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决，Redis通过重写aof，可以生成一个恢复当前数据的最少命令集，两种方式：配置no-appendfsync-on-rewrite(默认no)，或者客户端向服务器发送bgrewriteaof命令</li>\n</ul>\n<ul>\n<li>AOF的优点：AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li>\n<li>AOF的缺点：AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。恢复数据的速度比RDB慢。</li>\n<li>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</li>\n</ul>\n<h5 id=\"2-2-1-AOF文件修复\"><a href=\"#2-2-1-AOF文件修复\" class=\"headerlink\" title=\"2.2.1 AOF文件修复\"></a>2.2.1 AOF文件修复</h5><ol>\n<li>备份被写坏的AOF文件</li>\n<li>运行redis-check-aof –fix进行修复</li>\n<li>用diff -u来看下两个文件的差异，确认问题点</li>\n<li>重启redis，加载修复后的AOF文件</li>\n</ol>\n<h3 id=\"3-Redis的高并发和快速原因\"><a href=\"#3-Redis的高并发和快速原因\" class=\"headerlink\" title=\"3. Redis的高并发和快速原因\"></a>3. Redis的高并发和快速原因</h3><ol>\n<li>redis是基于内存的，内存的读写速度非常快；</li>\n<li>redis是单线程的，省去了很多上下文切换线程的时间；</li>\n<li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</li>\n<li>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</li>\n<li>还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li>\n</ol>\n<h3 id=\"4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用\"><a href=\"#4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用\" class=\"headerlink\" title=\"4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用\"></a>4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用</h3><ol>\n<li>哨兵(Sentinel)：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。<ol>\n<li>集群监控：负责监控Redis master和slave进程是否正常工作</li>\n<li>消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li>\n<li>故障转移：如果master node挂掉了，会自动转移到slave node上</li>\n<li>配置中心：如果故障转移发生了，通知client客户端新的master地址</li>\n</ol>\n</li>\n<li>复制(Replication)：则是负责让一个Redis服务器可以配备多个备份的服务器。<ol>\n<li>从数据库向主数据库发送sync(数据同步)命令。</li>\n<li>主数据库接收同步命令后，会保存快照，创建一个RDB文件。</li>\n<li>当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。</li>\n<li>主数据库将缓冲区的所有写命令发给从服务器执行。</li>\n<li>以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5-Redis-主从复制、哨兵和集群这三个有什么区别\"><a href=\"#5-Redis-主从复制、哨兵和集群这三个有什么区别\" class=\"headerlink\" title=\"5. Redis 主从复制、哨兵和集群这三个有什么区别\"></a>5. Redis 主从复制、哨兵和集群这三个有什么区别</h3><p>主从复制是为了数据备份，哨兵是为了高可用，Redis主服务器挂了哨兵可以切换，集群则是因为单实例能力有限，搞多个分散压力。</p>\n<ol>\n<li>主从模式：读写分离，备份，一个Master可以有多个Slaves。</li>\n<li>哨兵entinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。</li>\n<li>集群Cluster：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。</li>\n</ol>\n<h3 id=\"6-Redis-Cluster集群\"><a href=\"#6-Redis-Cluster集群\" class=\"headerlink\" title=\"6. Redis Cluster集群\"></a>6. Redis Cluster集群</h3><p>Redis Cluster，是Redis 3.0开始引入的分布式存储方案。<br>集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。</p>\n<ul>\n<li>集群的作用：<ol>\n<li>数据分区：数据分区(或称数据分片)是集群最核心的功能。</li>\n<li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"6-1-Redis-Cluster集群的搭建可以分为四步：\"><a href=\"#6-1-Redis-Cluster集群的搭建可以分为四步：\" class=\"headerlink\" title=\"6.1 Redis Cluster集群的搭建可以分为四步：\"></a>6.1 Redis Cluster集群的搭建可以分为四步：</h4><ol>\n<li><strong>启动节点</strong>：将节点以集群模式启动，此时节点是独立的，并没有建立联系；</li>\n<li><strong>节点握手</strong>：让独立的节点连成一个网络；</li>\n<li><strong>分配槽</strong>：将16384个槽分配给主节点；</li>\n<li><strong>指定主从关系</strong>：为从节点指定主节点。</li>\n</ol>\n<h4 id=\"6-2-Redis-Cluster工作原理\"><a href=\"#6-2-Redis-Cluster工作原理\" class=\"headerlink\" title=\"6.2 Redis Cluster工作原理\"></a>6.2 Redis Cluster工作原理</h4><ul>\n<li>客户端与Redis节点直连,不需要中间Proxy层，直接连接任意一个Master节点</li>\n<li>根据公式<code>HASH_SLOT=CRC16(key) mod 16384</code>，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         CRC16(key)    |  0~5460   | &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class=\"line\">         mode 16384    |</span><br><span class=\"line\">Client --------------&gt; | 5461~10922| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class=\"line\">                       |</span><br><span class=\"line\">                       |10923~10383| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"6-3-Redis-Cluster优点\"><a href=\"#6-3-Redis-Cluster优点\" class=\"headerlink\" title=\"6.3 Redis Cluster优点:\"></a>6.3 Redis Cluster优点:</h4><ol>\n<li>无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master</li>\n<li>可以进行水平扩容</li>\n<li>支持自动化迁移，当出现某个Slave宕机了，那么就只有Master了，这时候的高可用性就无法很好的保证了，万一master也宕机了，咋办呢？ 针对这种情况，如果说其他Master有多余的Slave ，集群自动把多余的Slave迁移到没有Slave的Master 中。</li>\n</ol>\n<h4 id=\"6-4-Redis-Cluster缺点\"><a href=\"#6-4-Redis-Cluster缺点\" class=\"headerlink\" title=\"6.4 Redis Cluster缺点:\"></a>6.4 Redis Cluster缺点:</h4><ol>\n<li>批量操作是个坑（不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通）</li>\n<li>资源隔离性较差，容易出现相互影响的情况。</li>\n</ol>\n<h4 id=\"6-5-Redis-Cluster总结：\"><a href=\"#6-5-Redis-Cluster总结：\" class=\"headerlink\" title=\"6.5 Redis Cluster总结：\"></a>6.5 Redis Cluster总结：</h4><ol>\n<li>Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效。</li>\n<li>单机下的redis可以支持16个数据库（db0 ~ db15），在Redis Cluster集群架构下只有一个数据库空间，即db0。</li>\n<li>不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通。</li>\n<li>如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上。</li>\n<li>Redis集群模式下进行批量操作：如果执行的key数量比较少，就用串行get操作； 如果需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。</li>\n<li>Redis Cluster的架构，是属于分片集群的架构，不做读写分离，因为redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。</li>\n</ol>"},{"title":"【安全认证】JSON Web Token 入门","date":"2019-08-06T07:50:53.000Z","_content":"\n\n## JSON Web Token\nJSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。\n<!-- more -->\n- JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。\n- 此后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。\n- 服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n\n### 1. JWT数据结构\n它是一个很长的字符串，中间用点（.）分隔成三个部分。\n- 例如：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`.`eyJhdWQiOiJjaGFvIiwidWlkIjoyOSwiZXhwIjoxNTY3OTM2NzgwfQ`.`6zvimBNs_MCiov4MOkkUodgKmRFBS2dVhmhIb1MV6m4。\n\nJWT 的三个部分(`Header.Payload.Signature`)依次如下:\n1. Header（头部）\n2. Payload（负载）\n3. Signature（签名）\n\n#### 1.1 Header（头部）\nHeader 部分是一个 JSON 对象，描述 JWT 的元数据。\n``` json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n- `alg`：签名的算法（algorithm），默认是 HMAC SHA256（写成`HS256`）\n- `typ`：表示这个令牌（token）的类型（type），JWT令牌统一写为`JWT`。\n\n最后，将上面的 JSON 对象使用 `Base64URL算法`转成字符串。\n\n#### 1.2 Payload（负载）\nPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段(Reserved claims)，供选用。标准中建议使用这些字段，但不强制。\n+ iss (issuer)：签发人\n+ exp (expiration time)：过期时间\n+ sub (subject)：主题\n+ aud (audience)：受众\n+ nbf (Not Before)：生效时间\n+ iat (Issued At)：签发时间\n+ jti (JWT ID)：编号，JWT唯一标识，能用于防止JWT重复使用\n\n除了官方字段，还有公共声明的字段（见：[http://www.iana.org/assignments/jwt/jwt.xhtml](http://www.iana.org/assignments/jwt/jwt.xhtml)）也可以定义私有字段，如：\n``` json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n> 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。\n\n这个 JSON 对象也要使用 `Base64URL算法`转成字符串。\n\n\n#### 1.3 Signature（签名）\nSignature 部分是对前两部分的签名，防止数据篡改。该签名信息是通过header和payload，加上secret，通过算法加密生成。\n- 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。\n    + `HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)`\n- 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用\"点\"（.）分隔，就可以返回给用户。\n\n\n### 2. Base64URL算法\n前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。\n\nJWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符`+`、`/`和`=`，在 URL 里面有特殊含义，所以要被替换掉：`=`被省略、`+`替换成`-`，`/`替换成`_` 。这就是 Base64URL 算法。\n\n\n### 3. JWT 的使用方式及特点\n1. 认证原理：\n    + 客户端向服务器申请授权，服务器认证以后，生成一个token字符串并返回给客户端，此后客户端在请求受保护的资源时携带这个token，服务端进行验证再从这个token中解析出用户的身份信息。\n2. JWT的使用方式：\n    - 客户端收到服务器返回的JWT，存储在浏览器（Cookie或localStorage）\n    - 此后，客户端每次与服务器通信，都要带上这个JWT。\n        1. 一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：\n            + `Authorization: <token>`\n            + 需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *\n        2. 另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。\n\n3. 对JWT实现token续签的做法：\n    1. 额外生成一个refreshToken用于获取新token，refreshToken需存储于服务端，其过期时间比JWT的过期时间要稍长。\n    2. 用户携带refreshToken参数请求token刷新接口，服务端在判断refreshToken未过期后，取出关联的用户信息和当前token。\n    3. 使用当前用户信息重新生成token，并将旧的token置于黑名单中，返回新的token。\n\n4. JWT 的几个特点\n    1. JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。\n    2. JWT 不加密的情况下，不能将秘密数据写入JWT。\n    3. JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。\n    4. JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n    5. JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。\n    6. 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。\n\n\n### 4. Java中JWT的使用\njava-jwt工具包提供了**JWT算法的封装**\n1. 导入java-jwt，选择一种算法（HMAC256为例）\n    + **`Algorithm algorithm = Algorithm.HMAC256(\"secret\");`**\n    + 算法定义了一个令牌是如何被签名和验证的。\n2. 创建一个签名的`JWT token`（通过调用jwt.create()创建一个JWTCreator实例）\n    + **`String token = JWT.create().withIssuer(\"auth0\").sign(algorithm);`**\n    + *如果Claim不能转换为JSON，或者在签名过程中使用的密钥无效，那么将会抛出**JWTCreationException**异常*\n3. 验证令牌（调用jwt.require()和传递算法实例来创建一个JWTVerifier实例。方法build()返回的实例是可重用的，因此可以定义一次，并使用它来验证不同的标记。最后调用verifier.verify()来验证token）\n    + **`JWTVerifier verifier = JWT.require(algorithm).withIssuer(\"auth0\").build();`**\n    + **`verifier.verify(token);`**\n    + *如果令牌有一个无效的签名，或者没有满足Claim要求，那么将会抛出**JWTVerificationException**异常*\n4. jwt时间的验证（当验证一个令牌时，时间验证会自动发生；JWT令牌可能包括可用于验证的DateNumber字段）\n    + `\"iat\" < TODAY`：这个令牌发布了一个过期的时间\n    + `\"exp\" > TODAY`：这个令牌还没过期\n    + `\"nbf\" > TODAY`：这个令牌已经被使用了\n5. 解码一个jwt令牌\n    + `DecodedJWT jwt = JWT.decode(token);`\n    + `jwt.getAlgorithm();`:返回jwt的算法值,如果没有定义则返回null\n    + `jwt.getType();`:返回jwt的类型值，如果没有定义则返回null（多数情况类型值为jwt）\n    + *如果令牌有无效的语法，或者消息头或有效负载不是JSONs，那么将会抛出**JWTDecodeException**异常*\n\n\n### 5. Java中JWT的使用实例\n封装一个JWT工具类：\n``` java\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.auth0.jwt.JWT; //导入java-jwt\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport com.auth0.jwt.interfaces.JWTVerifier;\n\nimport com.entity.User; //引入User实体类\n\npublic class JwtUtil {\n    //设置过期时间，这里设置15分钟\n    private static final long EXPIRE_TIME = 15 * 60 * 1000;\n    //服务端的私钥secret,在任何场景都不应该流露出去\n    private static final String TOKEN_SECRET = \"zhengchao\";\n    /**\n     * 生成签名 \n     * @param **User**\n     * @param **password**\n     * @return\n     */\n    public static String createToken(User user) {\n        try {\n            // 设置过期时间\n            Date date = new Date(System.currentTimeMillis() + EXPIRE_TIME);\n            // 私钥和加密算法\n            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);\n            // 设置头部信息\n            Map<String, Object> header = new HashMap<>(2);\n            header.put(\"typ\", \"JWT\");\n            header.put(\"alg\", \"HS256\");\n            // 返回token字符串\n            return JWT.create()\n                    .withHeader(header)\n                    .withClaim(\"aud\", user.getName())\n                    .withClaim(\"uid\", user.getId())\n                    .withExpiresAt(date)\n                    .sign(algorithm);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    /**\n     * 检验token是否正确\n     * @param **token**\n     * @return\n     */\n    public static boolean isVerify(String token){\n        try {\n            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);\n            JWTVerifier verifier = JWT.require(algorithm).build();\n            verifier.verify(token);\n            return true;\n        } catch (Exception e){\n            return false;\n        }\n    }\n    /**\n     *从token解析出uid信息,用户ID\n     * @param token\n     * @param key\n     * @return\n     */\n    public static int parseTokenUid(String token) {\n        DecodedJWT jwt = JWT.decode(token);\n        return jwt.getClaim(\"uid\").asInt();\n    }\n    /**\n     *从token解析出aud信息,用户名\n     * @param token\n     * @param key\n     * @return\n     */\n    public static String parseTokenAud(String token) {\n        DecodedJWT jwt = JWT.decode(token);\n        return jwt.getClaim(\"aud\").asString();\n    }\n}\n```\n\n登录成功后，生成token给浏览器，存储在浏览器（Cookie或localStorage）\n``` java\nString token = JwtUtil.createToken(user);\n```\n\n此后，客户端每次与服务器通信（需权限的资源），都要带上这个JWT。\n1. 一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：\n    + `Authorization: <token>`\n    + 需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *\n2. 另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。\n\n\n> jwt 适合做简单的 restful api 认证，颁发一个固定有效期的 jwt，降低 jwt 暴露的风险，尽量不要对 jwt 做服务端的状态管理，这样才能体现出 jwt 无状态的优势。\n\n\n### 附：java-jwt已经实现的算法\n|JWS\t|算法\t\t|介绍\t\t\t\t\t\t\t\t|\n|-------|-----------|-----------------------------------|\n|HS256\t|HMAC256\t|HMAC with SHA-256\t\t\t\t\t|\n|HS384\t|HMAC384\t|HMAC with SHA-384\t\t\t\t\t|\n|HS512\t|HMAC512\t|HMAC with SHA-512\t\t\t\t\t|\n|RS256\t|RSA256\t\t|RSASSA-PKCS1-v1_5 with SHA-256\t\t|\n|RS384\t|RSA384\t\t|RSASSA-PKCS1-v1_5 with SHA-384\t\t|\n|RS512\t|RSA512\t\t|RSASSA-PKCS1-v1_5 with SHA-512\t\t|\n|ES256\t|ECDSA256\t|ECDSA with curve P-256 and SHA-256\t|\n|ES384\t|ECDSA384\t|ECDSA with curve P-384 and SHA-384\t|\n|ES512\t|ECDSA512\t|ECDSA with curve P-521 and SHA-512\t|\n\n","source":"_posts/【安全认证】JSON Web Token 入门.md","raw":"---\ntitle: 【安全认证】JSON Web Token 入门\ndate: 2019-08-06 15:50:53\ntags: [后端开发, 安全认证]\ncategories: 安全认证\n---\n\n\n## JSON Web Token\nJSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。\n<!-- more -->\n- JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。\n- 此后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。\n- 服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n\n### 1. JWT数据结构\n它是一个很长的字符串，中间用点（.）分隔成三个部分。\n- 例如：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`.`eyJhdWQiOiJjaGFvIiwidWlkIjoyOSwiZXhwIjoxNTY3OTM2NzgwfQ`.`6zvimBNs_MCiov4MOkkUodgKmRFBS2dVhmhIb1MV6m4。\n\nJWT 的三个部分(`Header.Payload.Signature`)依次如下:\n1. Header（头部）\n2. Payload（负载）\n3. Signature（签名）\n\n#### 1.1 Header（头部）\nHeader 部分是一个 JSON 对象，描述 JWT 的元数据。\n``` json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n- `alg`：签名的算法（algorithm），默认是 HMAC SHA256（写成`HS256`）\n- `typ`：表示这个令牌（token）的类型（type），JWT令牌统一写为`JWT`。\n\n最后，将上面的 JSON 对象使用 `Base64URL算法`转成字符串。\n\n#### 1.2 Payload（负载）\nPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段(Reserved claims)，供选用。标准中建议使用这些字段，但不强制。\n+ iss (issuer)：签发人\n+ exp (expiration time)：过期时间\n+ sub (subject)：主题\n+ aud (audience)：受众\n+ nbf (Not Before)：生效时间\n+ iat (Issued At)：签发时间\n+ jti (JWT ID)：编号，JWT唯一标识，能用于防止JWT重复使用\n\n除了官方字段，还有公共声明的字段（见：[http://www.iana.org/assignments/jwt/jwt.xhtml](http://www.iana.org/assignments/jwt/jwt.xhtml)）也可以定义私有字段，如：\n``` json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n> 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。\n\n这个 JSON 对象也要使用 `Base64URL算法`转成字符串。\n\n\n#### 1.3 Signature（签名）\nSignature 部分是对前两部分的签名，防止数据篡改。该签名信息是通过header和payload，加上secret，通过算法加密生成。\n- 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。\n    + `HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)`\n- 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用\"点\"（.）分隔，就可以返回给用户。\n\n\n### 2. Base64URL算法\n前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。\n\nJWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符`+`、`/`和`=`，在 URL 里面有特殊含义，所以要被替换掉：`=`被省略、`+`替换成`-`，`/`替换成`_` 。这就是 Base64URL 算法。\n\n\n### 3. JWT 的使用方式及特点\n1. 认证原理：\n    + 客户端向服务器申请授权，服务器认证以后，生成一个token字符串并返回给客户端，此后客户端在请求受保护的资源时携带这个token，服务端进行验证再从这个token中解析出用户的身份信息。\n2. JWT的使用方式：\n    - 客户端收到服务器返回的JWT，存储在浏览器（Cookie或localStorage）\n    - 此后，客户端每次与服务器通信，都要带上这个JWT。\n        1. 一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：\n            + `Authorization: <token>`\n            + 需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *\n        2. 另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。\n\n3. 对JWT实现token续签的做法：\n    1. 额外生成一个refreshToken用于获取新token，refreshToken需存储于服务端，其过期时间比JWT的过期时间要稍长。\n    2. 用户携带refreshToken参数请求token刷新接口，服务端在判断refreshToken未过期后，取出关联的用户信息和当前token。\n    3. 使用当前用户信息重新生成token，并将旧的token置于黑名单中，返回新的token。\n\n4. JWT 的几个特点\n    1. JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。\n    2. JWT 不加密的情况下，不能将秘密数据写入JWT。\n    3. JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。\n    4. JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n    5. JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。\n    6. 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。\n\n\n### 4. Java中JWT的使用\njava-jwt工具包提供了**JWT算法的封装**\n1. 导入java-jwt，选择一种算法（HMAC256为例）\n    + **`Algorithm algorithm = Algorithm.HMAC256(\"secret\");`**\n    + 算法定义了一个令牌是如何被签名和验证的。\n2. 创建一个签名的`JWT token`（通过调用jwt.create()创建一个JWTCreator实例）\n    + **`String token = JWT.create().withIssuer(\"auth0\").sign(algorithm);`**\n    + *如果Claim不能转换为JSON，或者在签名过程中使用的密钥无效，那么将会抛出**JWTCreationException**异常*\n3. 验证令牌（调用jwt.require()和传递算法实例来创建一个JWTVerifier实例。方法build()返回的实例是可重用的，因此可以定义一次，并使用它来验证不同的标记。最后调用verifier.verify()来验证token）\n    + **`JWTVerifier verifier = JWT.require(algorithm).withIssuer(\"auth0\").build();`**\n    + **`verifier.verify(token);`**\n    + *如果令牌有一个无效的签名，或者没有满足Claim要求，那么将会抛出**JWTVerificationException**异常*\n4. jwt时间的验证（当验证一个令牌时，时间验证会自动发生；JWT令牌可能包括可用于验证的DateNumber字段）\n    + `\"iat\" < TODAY`：这个令牌发布了一个过期的时间\n    + `\"exp\" > TODAY`：这个令牌还没过期\n    + `\"nbf\" > TODAY`：这个令牌已经被使用了\n5. 解码一个jwt令牌\n    + `DecodedJWT jwt = JWT.decode(token);`\n    + `jwt.getAlgorithm();`:返回jwt的算法值,如果没有定义则返回null\n    + `jwt.getType();`:返回jwt的类型值，如果没有定义则返回null（多数情况类型值为jwt）\n    + *如果令牌有无效的语法，或者消息头或有效负载不是JSONs，那么将会抛出**JWTDecodeException**异常*\n\n\n### 5. Java中JWT的使用实例\n封装一个JWT工具类：\n``` java\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.auth0.jwt.JWT; //导入java-jwt\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport com.auth0.jwt.interfaces.JWTVerifier;\n\nimport com.entity.User; //引入User实体类\n\npublic class JwtUtil {\n    //设置过期时间，这里设置15分钟\n    private static final long EXPIRE_TIME = 15 * 60 * 1000;\n    //服务端的私钥secret,在任何场景都不应该流露出去\n    private static final String TOKEN_SECRET = \"zhengchao\";\n    /**\n     * 生成签名 \n     * @param **User**\n     * @param **password**\n     * @return\n     */\n    public static String createToken(User user) {\n        try {\n            // 设置过期时间\n            Date date = new Date(System.currentTimeMillis() + EXPIRE_TIME);\n            // 私钥和加密算法\n            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);\n            // 设置头部信息\n            Map<String, Object> header = new HashMap<>(2);\n            header.put(\"typ\", \"JWT\");\n            header.put(\"alg\", \"HS256\");\n            // 返回token字符串\n            return JWT.create()\n                    .withHeader(header)\n                    .withClaim(\"aud\", user.getName())\n                    .withClaim(\"uid\", user.getId())\n                    .withExpiresAt(date)\n                    .sign(algorithm);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    /**\n     * 检验token是否正确\n     * @param **token**\n     * @return\n     */\n    public static boolean isVerify(String token){\n        try {\n            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);\n            JWTVerifier verifier = JWT.require(algorithm).build();\n            verifier.verify(token);\n            return true;\n        } catch (Exception e){\n            return false;\n        }\n    }\n    /**\n     *从token解析出uid信息,用户ID\n     * @param token\n     * @param key\n     * @return\n     */\n    public static int parseTokenUid(String token) {\n        DecodedJWT jwt = JWT.decode(token);\n        return jwt.getClaim(\"uid\").asInt();\n    }\n    /**\n     *从token解析出aud信息,用户名\n     * @param token\n     * @param key\n     * @return\n     */\n    public static String parseTokenAud(String token) {\n        DecodedJWT jwt = JWT.decode(token);\n        return jwt.getClaim(\"aud\").asString();\n    }\n}\n```\n\n登录成功后，生成token给浏览器，存储在浏览器（Cookie或localStorage）\n``` java\nString token = JwtUtil.createToken(user);\n```\n\n此后，客户端每次与服务器通信（需权限的资源），都要带上这个JWT。\n1. 一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：\n    + `Authorization: <token>`\n    + 需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *\n2. 另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。\n\n\n> jwt 适合做简单的 restful api 认证，颁发一个固定有效期的 jwt，降低 jwt 暴露的风险，尽量不要对 jwt 做服务端的状态管理，这样才能体现出 jwt 无状态的优势。\n\n\n### 附：java-jwt已经实现的算法\n|JWS\t|算法\t\t|介绍\t\t\t\t\t\t\t\t|\n|-------|-----------|-----------------------------------|\n|HS256\t|HMAC256\t|HMAC with SHA-256\t\t\t\t\t|\n|HS384\t|HMAC384\t|HMAC with SHA-384\t\t\t\t\t|\n|HS512\t|HMAC512\t|HMAC with SHA-512\t\t\t\t\t|\n|RS256\t|RSA256\t\t|RSASSA-PKCS1-v1_5 with SHA-256\t\t|\n|RS384\t|RSA384\t\t|RSASSA-PKCS1-v1_5 with SHA-384\t\t|\n|RS512\t|RSA512\t\t|RSASSA-PKCS1-v1_5 with SHA-512\t\t|\n|ES256\t|ECDSA256\t|ECDSA with curve P-256 and SHA-256\t|\n|ES384\t|ECDSA384\t|ECDSA with curve P-384 and SHA-384\t|\n|ES512\t|ECDSA512\t|ECDSA with curve P-521 and SHA-512\t|\n\n","slug":"【安全认证】JSON Web Token 入门","published":1,"updated":"2021-12-12T02:50:23.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6v1000dvcuehove0kwk","content":"<h2 id=\"JSON-Web-Token\"><a href=\"#JSON-Web-Token\" class=\"headerlink\" title=\"JSON Web Token\"></a>JSON Web Token</h2><p>JSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。</p>\n<span id=\"more\"></span>\n<ul>\n<li>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。</li>\n<li>此后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</li>\n<li>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</li>\n</ul>\n<h3 id=\"1-JWT数据结构\"><a href=\"#1-JWT数据结构\" class=\"headerlink\" title=\"1. JWT数据结构\"></a>1. JWT数据结构</h3><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。</p>\n<ul>\n<li>例如：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<code>.</code>eyJhdWQiOiJjaGFvIiwidWlkIjoyOSwiZXhwIjoxNTY3OTM2NzgwfQ<code>.</code>6zvimBNs_MCiov4MOkkUodgKmRFBS2dVhmhIb1MV6m4。</li>\n</ul>\n<p>JWT 的三个部分(<code>Header.Payload.Signature</code>)依次如下:</p>\n<ol>\n<li>Header（头部）</li>\n<li>Payload（负载）</li>\n<li>Signature（签名）</li>\n</ol>\n<h4 id=\"1-1-Header（头部）\"><a href=\"#1-1-Header（头部）\" class=\"headerlink\" title=\"1.1 Header（头部）\"></a>1.1 Header（头部）</h4><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;alg&quot;</span>: <span class=\"string\">&quot;HS256&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;typ&quot;</span>: <span class=\"string\">&quot;JWT&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>alg</code>：签名的算法（algorithm），默认是 HMAC SHA256（写成<code>HS256</code>）</li>\n<li><code>typ</code>：表示这个令牌（token）的类型（type），JWT令牌统一写为<code>JWT</code>。</li>\n</ul>\n<p>最后，将上面的 JSON 对象使用 <code>Base64URL算法</code>转成字符串。</p>\n<h4 id=\"1-2-Payload（负载）\"><a href=\"#1-2-Payload（负载）\" class=\"headerlink\" title=\"1.2 Payload（负载）\"></a>1.2 Payload（负载）</h4><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段(Reserved claims)，供选用。标准中建议使用这些字段，但不强制。</p>\n<ul>\n<li>iss (issuer)：签发人</li>\n<li>exp (expiration time)：过期时间</li>\n<li>sub (subject)：主题</li>\n<li>aud (audience)：受众</li>\n<li>nbf (Not Before)：生效时间</li>\n<li>iat (Issued At)：签发时间</li>\n<li>jti (JWT ID)：编号，JWT唯一标识，能用于防止JWT重复使用</li>\n</ul>\n<p>除了官方字段，还有公共声明的字段（见：<a href=\"http://www.iana.org/assignments/jwt/jwt.xhtml\">http://www.iana.org/assignments/jwt/jwt.xhtml</a>）也可以定义私有字段，如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;sub&quot;</span>: <span class=\"string\">&quot;1234567890&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;John Doe&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;admin&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>\n</blockquote>\n<p>这个 JSON 对象也要使用 <code>Base64URL算法</code>转成字符串。</p>\n<h4 id=\"1-3-Signature（签名）\"><a href=\"#1-3-Signature（签名）\" class=\"headerlink\" title=\"1.3 Signature（签名）\"></a>1.3 Signature（签名）</h4><p>Signature 部分是对前两部分的签名，防止数据篡改。该签名信息是通过header和payload，加上secret，通过算法加密生成。</p>\n<ul>\n<li>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<ul>\n<li><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></li>\n</ul>\n</li>\n<li>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</li>\n</ul>\n<h3 id=\"2-Base64URL算法\"><a href=\"#2-Base64URL算法\" class=\"headerlink\" title=\"2. Base64URL算法\"></a>2. Base64URL算法</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p>\n<p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>\n<h3 id=\"3-JWT-的使用方式及特点\"><a href=\"#3-JWT-的使用方式及特点\" class=\"headerlink\" title=\"3. JWT 的使用方式及特点\"></a>3. JWT 的使用方式及特点</h3><ol>\n<li><p>认证原理：</p>\n<ul>\n<li>客户端向服务器申请授权，服务器认证以后，生成一个token字符串并返回给客户端，此后客户端在请求受保护的资源时携带这个token，服务端进行验证再从这个token中解析出用户的身份信息。</li>\n</ul>\n</li>\n<li><p>JWT的使用方式：</p>\n<ul>\n<li>客户端收到服务器返回的JWT，存储在浏览器（Cookie或localStorage）</li>\n<li>此后，客户端每次与服务器通信，都要带上这个JWT。<ol>\n<li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul>\n<li><code>Authorization: &lt;token&gt;</code></li>\n<li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li>\n</ul>\n</li>\n<li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>对JWT实现token续签的做法：</p>\n<ol>\n<li>额外生成一个refreshToken用于获取新token，refreshToken需存储于服务端，其过期时间比JWT的过期时间要稍长。</li>\n<li>用户携带refreshToken参数请求token刷新接口，服务端在判断refreshToken未过期后，取出关联的用户信息和当前token。</li>\n<li>使用当前用户信息重新生成token，并将旧的token置于黑名单中，返回新的token。</li>\n</ol>\n</li>\n<li><p>JWT 的几个特点</p>\n<ol>\n<li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>\n<li>JWT 不加密的情况下，不能将秘密数据写入JWT。</li>\n<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>\n<li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li>\n<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>\n<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-Java中JWT的使用\"><a href=\"#4-Java中JWT的使用\" class=\"headerlink\" title=\"4. Java中JWT的使用\"></a>4. Java中JWT的使用</h3><p>java-jwt工具包提供了<strong>JWT算法的封装</strong></p>\n<ol>\n<li>导入java-jwt，选择一种算法（HMAC256为例）<ul>\n<li><strong><code>Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);</code></strong></li>\n<li>算法定义了一个令牌是如何被签名和验证的。</li>\n</ul>\n</li>\n<li>创建一个签名的<code>JWT token</code>（通过调用jwt.create()创建一个JWTCreator实例）<ul>\n<li><strong><code>String token = JWT.create().withIssuer(&quot;auth0&quot;).sign(algorithm);</code></strong></li>\n<li><em>如果Claim不能转换为JSON，或者在签名过程中使用的密钥无效，那么将会抛出<strong>JWTCreationException</strong>异常</em></li>\n</ul>\n</li>\n<li>验证令牌（调用jwt.require()和传递算法实例来创建一个JWTVerifier实例。方法build()返回的实例是可重用的，因此可以定义一次，并使用它来验证不同的标记。最后调用verifier.verify()来验证token）<ul>\n<li><strong><code>JWTVerifier verifier = JWT.require(algorithm).withIssuer(&quot;auth0&quot;).build();</code></strong></li>\n<li><strong><code>verifier.verify(token);</code></strong></li>\n<li><em>如果令牌有一个无效的签名，或者没有满足Claim要求，那么将会抛出<strong>JWTVerificationException</strong>异常</em></li>\n</ul>\n</li>\n<li>jwt时间的验证（当验证一个令牌时，时间验证会自动发生；JWT令牌可能包括可用于验证的DateNumber字段）<ul>\n<li><code>&quot;iat&quot; &lt; TODAY</code>：这个令牌发布了一个过期的时间</li>\n<li><code>&quot;exp&quot; &gt; TODAY</code>：这个令牌还没过期</li>\n<li><code>&quot;nbf&quot; &gt; TODAY</code>：这个令牌已经被使用了</li>\n</ul>\n</li>\n<li>解码一个jwt令牌<ul>\n<li><code>DecodedJWT jwt = JWT.decode(token);</code></li>\n<li><code>jwt.getAlgorithm();</code>:返回jwt的算法值,如果没有定义则返回null</li>\n<li><code>jwt.getType();</code>:返回jwt的类型值，如果没有定义则返回null（多数情况类型值为jwt）</li>\n<li><em>如果令牌有无效的语法，或者消息头或有效负载不是JSONs，那么将会抛出<strong>JWTDecodeException</strong>异常</em></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-Java中JWT的使用实例\"><a href=\"#5-Java中JWT的使用实例\" class=\"headerlink\" title=\"5. Java中JWT的使用实例\"></a>5. Java中JWT的使用实例</h3><p>封装一个JWT工具类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.auth0.jwt.JWT; <span class=\"comment\">//导入java-jwt</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.auth0.jwt.interfaces.JWTVerifier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.entity.User; <span class=\"comment\">//引入User实体类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JwtUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置过期时间，这里设置15分钟</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> EXPIRE_TIME = <span class=\"number\">15</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"comment\">//服务端的私钥secret,在任何场景都不应该流露出去</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TOKEN_SECRET = <span class=\"string\">&quot;zhengchao&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成签名 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> **User**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> **password**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">createToken</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 设置过期时间</span></span><br><span class=\"line\">            Date date = <span class=\"keyword\">new</span> Date(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class=\"line\">            <span class=\"comment\">// 私钥和加密算法</span></span><br><span class=\"line\">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class=\"line\">            <span class=\"comment\">// 设置头部信息</span></span><br><span class=\"line\">            Map&lt;String, Object&gt; header = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">            header.put(<span class=\"string\">&quot;typ&quot;</span>, <span class=\"string\">&quot;JWT&quot;</span>);</span><br><span class=\"line\">            header.put(<span class=\"string\">&quot;alg&quot;</span>, <span class=\"string\">&quot;HS256&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 返回token字符串</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> JWT.create()</span><br><span class=\"line\">                    .withHeader(header)</span><br><span class=\"line\">                    .withClaim(<span class=\"string\">&quot;aud&quot;</span>, user.getName())</span><br><span class=\"line\">                    .withClaim(<span class=\"string\">&quot;uid&quot;</span>, user.getId())</span><br><span class=\"line\">                    .withExpiresAt(date)</span><br><span class=\"line\">                    .sign(algorithm);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检验token是否正确</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> **token**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isVerify</span><span class=\"params\">(String token)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class=\"line\">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class=\"line\">            verifier.verify(token);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *从token解析出uid信息,用户ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> token</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parseTokenUid</span><span class=\"params\">(String token)</span> </span>&#123;</span><br><span class=\"line\">        DecodedJWT jwt = JWT.decode(token);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jwt.getClaim(<span class=\"string\">&quot;uid&quot;</span>).asInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *从token解析出aud信息,用户名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> token</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseTokenAud</span><span class=\"params\">(String token)</span> </span>&#123;</span><br><span class=\"line\">        DecodedJWT jwt = JWT.decode(token);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jwt.getClaim(<span class=\"string\">&quot;aud&quot;</span>).asString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>登录成功后，生成token给浏览器，存储在浏览器（Cookie或localStorage）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String token = JwtUtil.createToken(user);</span><br></pre></td></tr></table></figure>\n\n<p>此后，客户端每次与服务器通信（需权限的资源），都要带上这个JWT。</p>\n<ol>\n<li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul>\n<li><code>Authorization: &lt;token&gt;</code></li>\n<li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li>\n</ul>\n</li>\n<li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li>\n</ol>\n<blockquote>\n<p>jwt 适合做简单的 restful api 认证，颁发一个固定有效期的 jwt，降低 jwt 暴露的风险，尽量不要对 jwt 做服务端的状态管理，这样才能体现出 jwt 无状态的优势。</p>\n</blockquote>\n<h3 id=\"附：java-jwt已经实现的算法\"><a href=\"#附：java-jwt已经实现的算法\" class=\"headerlink\" title=\"附：java-jwt已经实现的算法\"></a>附：java-jwt已经实现的算法</h3><table>\n<thead>\n<tr>\n<th>JWS</th>\n<th>算法</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HS256</td>\n<td>HMAC256</td>\n<td>HMAC with SHA-256</td>\n</tr>\n<tr>\n<td>HS384</td>\n<td>HMAC384</td>\n<td>HMAC with SHA-384</td>\n</tr>\n<tr>\n<td>HS512</td>\n<td>HMAC512</td>\n<td>HMAC with SHA-512</td>\n</tr>\n<tr>\n<td>RS256</td>\n<td>RSA256</td>\n<td>RSASSA-PKCS1-v1_5 with SHA-256</td>\n</tr>\n<tr>\n<td>RS384</td>\n<td>RSA384</td>\n<td>RSASSA-PKCS1-v1_5 with SHA-384</td>\n</tr>\n<tr>\n<td>RS512</td>\n<td>RSA512</td>\n<td>RSASSA-PKCS1-v1_5 with SHA-512</td>\n</tr>\n<tr>\n<td>ES256</td>\n<td>ECDSA256</td>\n<td>ECDSA with curve P-256 and SHA-256</td>\n</tr>\n<tr>\n<td>ES384</td>\n<td>ECDSA384</td>\n<td>ECDSA with curve P-384 and SHA-384</td>\n</tr>\n<tr>\n<td>ES512</td>\n<td>ECDSA512</td>\n<td>ECDSA with curve P-521 and SHA-512</td>\n</tr>\n</tbody></table>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h2 id=\"JSON-Web-Token\"><a href=\"#JSON-Web-Token\" class=\"headerlink\" title=\"JSON Web Token\"></a>JSON Web Token</h2><p>JSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。</p>","more":"<ul>\n<li>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。</li>\n<li>此后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</li>\n<li>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</li>\n</ul>\n<h3 id=\"1-JWT数据结构\"><a href=\"#1-JWT数据结构\" class=\"headerlink\" title=\"1. JWT数据结构\"></a>1. JWT数据结构</h3><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。</p>\n<ul>\n<li>例如：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<code>.</code>eyJhdWQiOiJjaGFvIiwidWlkIjoyOSwiZXhwIjoxNTY3OTM2NzgwfQ<code>.</code>6zvimBNs_MCiov4MOkkUodgKmRFBS2dVhmhIb1MV6m4。</li>\n</ul>\n<p>JWT 的三个部分(<code>Header.Payload.Signature</code>)依次如下:</p>\n<ol>\n<li>Header（头部）</li>\n<li>Payload（负载）</li>\n<li>Signature（签名）</li>\n</ol>\n<h4 id=\"1-1-Header（头部）\"><a href=\"#1-1-Header（头部）\" class=\"headerlink\" title=\"1.1 Header（头部）\"></a>1.1 Header（头部）</h4><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;alg&quot;</span>: <span class=\"string\">&quot;HS256&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;typ&quot;</span>: <span class=\"string\">&quot;JWT&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>alg</code>：签名的算法（algorithm），默认是 HMAC SHA256（写成<code>HS256</code>）</li>\n<li><code>typ</code>：表示这个令牌（token）的类型（type），JWT令牌统一写为<code>JWT</code>。</li>\n</ul>\n<p>最后，将上面的 JSON 对象使用 <code>Base64URL算法</code>转成字符串。</p>\n<h4 id=\"1-2-Payload（负载）\"><a href=\"#1-2-Payload（负载）\" class=\"headerlink\" title=\"1.2 Payload（负载）\"></a>1.2 Payload（负载）</h4><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段(Reserved claims)，供选用。标准中建议使用这些字段，但不强制。</p>\n<ul>\n<li>iss (issuer)：签发人</li>\n<li>exp (expiration time)：过期时间</li>\n<li>sub (subject)：主题</li>\n<li>aud (audience)：受众</li>\n<li>nbf (Not Before)：生效时间</li>\n<li>iat (Issued At)：签发时间</li>\n<li>jti (JWT ID)：编号，JWT唯一标识，能用于防止JWT重复使用</li>\n</ul>\n<p>除了官方字段，还有公共声明的字段（见：<a href=\"http://www.iana.org/assignments/jwt/jwt.xhtml\">http://www.iana.org/assignments/jwt/jwt.xhtml</a>）也可以定义私有字段，如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;sub&quot;</span>: <span class=\"string\">&quot;1234567890&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;John Doe&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;admin&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>\n</blockquote>\n<p>这个 JSON 对象也要使用 <code>Base64URL算法</code>转成字符串。</p>\n<h4 id=\"1-3-Signature（签名）\"><a href=\"#1-3-Signature（签名）\" class=\"headerlink\" title=\"1.3 Signature（签名）\"></a>1.3 Signature（签名）</h4><p>Signature 部分是对前两部分的签名，防止数据篡改。该签名信息是通过header和payload，加上secret，通过算法加密生成。</p>\n<ul>\n<li>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<ul>\n<li><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></li>\n</ul>\n</li>\n<li>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</li>\n</ul>\n<h3 id=\"2-Base64URL算法\"><a href=\"#2-Base64URL算法\" class=\"headerlink\" title=\"2. Base64URL算法\"></a>2. Base64URL算法</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p>\n<p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>\n<h3 id=\"3-JWT-的使用方式及特点\"><a href=\"#3-JWT-的使用方式及特点\" class=\"headerlink\" title=\"3. JWT 的使用方式及特点\"></a>3. JWT 的使用方式及特点</h3><ol>\n<li><p>认证原理：</p>\n<ul>\n<li>客户端向服务器申请授权，服务器认证以后，生成一个token字符串并返回给客户端，此后客户端在请求受保护的资源时携带这个token，服务端进行验证再从这个token中解析出用户的身份信息。</li>\n</ul>\n</li>\n<li><p>JWT的使用方式：</p>\n<ul>\n<li>客户端收到服务器返回的JWT，存储在浏览器（Cookie或localStorage）</li>\n<li>此后，客户端每次与服务器通信，都要带上这个JWT。<ol>\n<li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul>\n<li><code>Authorization: &lt;token&gt;</code></li>\n<li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li>\n</ul>\n</li>\n<li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>对JWT实现token续签的做法：</p>\n<ol>\n<li>额外生成一个refreshToken用于获取新token，refreshToken需存储于服务端，其过期时间比JWT的过期时间要稍长。</li>\n<li>用户携带refreshToken参数请求token刷新接口，服务端在判断refreshToken未过期后，取出关联的用户信息和当前token。</li>\n<li>使用当前用户信息重新生成token，并将旧的token置于黑名单中，返回新的token。</li>\n</ol>\n</li>\n<li><p>JWT 的几个特点</p>\n<ol>\n<li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>\n<li>JWT 不加密的情况下，不能将秘密数据写入JWT。</li>\n<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>\n<li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li>\n<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>\n<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-Java中JWT的使用\"><a href=\"#4-Java中JWT的使用\" class=\"headerlink\" title=\"4. Java中JWT的使用\"></a>4. Java中JWT的使用</h3><p>java-jwt工具包提供了<strong>JWT算法的封装</strong></p>\n<ol>\n<li>导入java-jwt，选择一种算法（HMAC256为例）<ul>\n<li><strong><code>Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);</code></strong></li>\n<li>算法定义了一个令牌是如何被签名和验证的。</li>\n</ul>\n</li>\n<li>创建一个签名的<code>JWT token</code>（通过调用jwt.create()创建一个JWTCreator实例）<ul>\n<li><strong><code>String token = JWT.create().withIssuer(&quot;auth0&quot;).sign(algorithm);</code></strong></li>\n<li><em>如果Claim不能转换为JSON，或者在签名过程中使用的密钥无效，那么将会抛出<strong>JWTCreationException</strong>异常</em></li>\n</ul>\n</li>\n<li>验证令牌（调用jwt.require()和传递算法实例来创建一个JWTVerifier实例。方法build()返回的实例是可重用的，因此可以定义一次，并使用它来验证不同的标记。最后调用verifier.verify()来验证token）<ul>\n<li><strong><code>JWTVerifier verifier = JWT.require(algorithm).withIssuer(&quot;auth0&quot;).build();</code></strong></li>\n<li><strong><code>verifier.verify(token);</code></strong></li>\n<li><em>如果令牌有一个无效的签名，或者没有满足Claim要求，那么将会抛出<strong>JWTVerificationException</strong>异常</em></li>\n</ul>\n</li>\n<li>jwt时间的验证（当验证一个令牌时，时间验证会自动发生；JWT令牌可能包括可用于验证的DateNumber字段）<ul>\n<li><code>&quot;iat&quot; &lt; TODAY</code>：这个令牌发布了一个过期的时间</li>\n<li><code>&quot;exp&quot; &gt; TODAY</code>：这个令牌还没过期</li>\n<li><code>&quot;nbf&quot; &gt; TODAY</code>：这个令牌已经被使用了</li>\n</ul>\n</li>\n<li>解码一个jwt令牌<ul>\n<li><code>DecodedJWT jwt = JWT.decode(token);</code></li>\n<li><code>jwt.getAlgorithm();</code>:返回jwt的算法值,如果没有定义则返回null</li>\n<li><code>jwt.getType();</code>:返回jwt的类型值，如果没有定义则返回null（多数情况类型值为jwt）</li>\n<li><em>如果令牌有无效的语法，或者消息头或有效负载不是JSONs，那么将会抛出<strong>JWTDecodeException</strong>异常</em></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-Java中JWT的使用实例\"><a href=\"#5-Java中JWT的使用实例\" class=\"headerlink\" title=\"5. Java中JWT的使用实例\"></a>5. Java中JWT的使用实例</h3><p>封装一个JWT工具类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.auth0.jwt.JWT; <span class=\"comment\">//导入java-jwt</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.auth0.jwt.interfaces.JWTVerifier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.entity.User; <span class=\"comment\">//引入User实体类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JwtUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置过期时间，这里设置15分钟</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> EXPIRE_TIME = <span class=\"number\">15</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"comment\">//服务端的私钥secret,在任何场景都不应该流露出去</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TOKEN_SECRET = <span class=\"string\">&quot;zhengchao&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成签名 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> **User**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> **password**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">createToken</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 设置过期时间</span></span><br><span class=\"line\">            Date date = <span class=\"keyword\">new</span> Date(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class=\"line\">            <span class=\"comment\">// 私钥和加密算法</span></span><br><span class=\"line\">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class=\"line\">            <span class=\"comment\">// 设置头部信息</span></span><br><span class=\"line\">            Map&lt;String, Object&gt; header = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">            header.put(<span class=\"string\">&quot;typ&quot;</span>, <span class=\"string\">&quot;JWT&quot;</span>);</span><br><span class=\"line\">            header.put(<span class=\"string\">&quot;alg&quot;</span>, <span class=\"string\">&quot;HS256&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 返回token字符串</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> JWT.create()</span><br><span class=\"line\">                    .withHeader(header)</span><br><span class=\"line\">                    .withClaim(<span class=\"string\">&quot;aud&quot;</span>, user.getName())</span><br><span class=\"line\">                    .withClaim(<span class=\"string\">&quot;uid&quot;</span>, user.getId())</span><br><span class=\"line\">                    .withExpiresAt(date)</span><br><span class=\"line\">                    .sign(algorithm);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检验token是否正确</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> **token**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isVerify</span><span class=\"params\">(String token)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class=\"line\">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class=\"line\">            verifier.verify(token);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *从token解析出uid信息,用户ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> token</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parseTokenUid</span><span class=\"params\">(String token)</span> </span>&#123;</span><br><span class=\"line\">        DecodedJWT jwt = JWT.decode(token);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jwt.getClaim(<span class=\"string\">&quot;uid&quot;</span>).asInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *从token解析出aud信息,用户名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> token</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseTokenAud</span><span class=\"params\">(String token)</span> </span>&#123;</span><br><span class=\"line\">        DecodedJWT jwt = JWT.decode(token);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jwt.getClaim(<span class=\"string\">&quot;aud&quot;</span>).asString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>登录成功后，生成token给浏览器，存储在浏览器（Cookie或localStorage）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String token = JwtUtil.createToken(user);</span><br></pre></td></tr></table></figure>\n\n<p>此后，客户端每次与服务器通信（需权限的资源），都要带上这个JWT。</p>\n<ol>\n<li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul>\n<li><code>Authorization: &lt;token&gt;</code></li>\n<li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li>\n</ul>\n</li>\n<li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li>\n</ol>\n<blockquote>\n<p>jwt 适合做简单的 restful api 认证，颁发一个固定有效期的 jwt，降低 jwt 暴露的风险，尽量不要对 jwt 做服务端的状态管理，这样才能体现出 jwt 无状态的优势。</p>\n</blockquote>\n<h3 id=\"附：java-jwt已经实现的算法\"><a href=\"#附：java-jwt已经实现的算法\" class=\"headerlink\" title=\"附：java-jwt已经实现的算法\"></a>附：java-jwt已经实现的算法</h3><table>\n<thead>\n<tr>\n<th>JWS</th>\n<th>算法</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HS256</td>\n<td>HMAC256</td>\n<td>HMAC with SHA-256</td>\n</tr>\n<tr>\n<td>HS384</td>\n<td>HMAC384</td>\n<td>HMAC with SHA-384</td>\n</tr>\n<tr>\n<td>HS512</td>\n<td>HMAC512</td>\n<td>HMAC with SHA-512</td>\n</tr>\n<tr>\n<td>RS256</td>\n<td>RSA256</td>\n<td>RSASSA-PKCS1-v1_5 with SHA-256</td>\n</tr>\n<tr>\n<td>RS384</td>\n<td>RSA384</td>\n<td>RSASSA-PKCS1-v1_5 with SHA-384</td>\n</tr>\n<tr>\n<td>RS512</td>\n<td>RSA512</td>\n<td>RSASSA-PKCS1-v1_5 with SHA-512</td>\n</tr>\n<tr>\n<td>ES256</td>\n<td>ECDSA256</td>\n<td>ECDSA with curve P-256 and SHA-256</td>\n</tr>\n<tr>\n<td>ES384</td>\n<td>ECDSA384</td>\n<td>ECDSA with curve P-384 and SHA-384</td>\n</tr>\n<tr>\n<td>ES512</td>\n<td>ECDSA512</td>\n<td>ECDSA with curve P-521 and SHA-512</td>\n</tr>\n</tbody></table>"},{"title":"【安全认证】MD5算法加盐实现用户密码加密","date":"2019-07-28T13:49:28.000Z","_content":"\n\n### 1. MD5加密算法介绍\nMD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被\"压缩\"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。\n<!-- more --> \n\n### 2. MD5加密算法特点：\n1. 压缩性：任意长度的数据，算出的MD5值长度都是固定的。\n2. 容易计算：从原数据计算出MD5值很容易。\n3. 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。\n4. 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。\n\n### 3. 盐（Salt）\n在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。\n\n### 4. java.security.MessageDigest类\nJDK中的java.security.MessageDigest用于为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。\n- MessageDigest 通过其getInstance系列静态函数来进行实例化和初始化。\n- MessageDigest 对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算并返回结果。\n- 对于给定数量的更新数据，digest 方法只能被调用一次。digest 方法被调用后，MessageDigest  对象被重新设置成其初始状态。\n\n### 5. 封装一个MD5加密工具类\n``` java\nimport java.security.MessageDigest;\nimport java.util.UUID;\npublic class MD5Util {\n    /**\n     * md5加密\n     * @param s：待加密字符串\n     * @return 加密后16进制字符串\n     */\n    public static String md5(String s) {\n        try {\n            //实例化MessageDigest的MD5算法对象\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            //通过digest方法返回哈希计算后的字节数组\n            byte[] bytes = md.digest(s.getBytes(\"utf-8\"));\n            //将字节数组转换为16进制字符串并返回\n            return toHex(bytes);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n    /**\n     * 获取随即盐\n     * @return\n     */\n    public static String salt(){\n        //利用UUID生成随机盐\n        UUID uuid = UUID.randomUUID();\n        //返回a2c64597-232f-4782-ab2d-9dfeb9d76932\n        String[] arr = uuid.toString().split(\"-\");\n        return arr[0];\n    }\n    /**\n     * 字节数组转换为16进制字符串\n     * @param bytes数组\n     * @return 16进制字符串\n     */\n    private static String toHex(byte[] bytes) {\n        final char[] HEX_DIGITS = \"0123456789ABCDEF\".toCharArray();\n        StringBuilder ret = new StringBuilder(bytes.length * 2);\n        for (int i=0; i<bytes.length; i++) {\n            ret.append(HEX_DIGITS[(bytes[i] >> 4) & 0x0f]);\n            ret.append(HEX_DIGITS[bytes[i] & 0x0f]);\n        }\n        return ret.toString();\n    }\n}\n```\n\n\n### 6. 使用封装的MD5工具类完成用户注册(主要代码)\n``` java\npublic Object register(String name, String password) {\n    //添加用户信息\n    user = new User();\n    //设置用户名\n    user.setName(name);\n    //密码加密后再保存\n    String salt = MD5Util.salt();\n    String md5Password = MD5Util.md5(password+salt);\n    //存入MD5加密后的密码\n    user.setPassword(md5Password);\n    //随机盐存入数据库，用于登录校验\n    user.setSalt(salt);\n    //最后将用户数据数据存入数据库\n    int row = userDao.insert(user);\n    return ...\n}\n```\n\n\n### 7. 使用封装的MD5工具类完成用户登录(主要代码)\n``` java\npublic Object login(String name, String password) {\n    //根据用户名在数据库查找用户\n    User user = userDao.selectByName(name);\n    //取出用户信息比对\n    String dbPassword = user.getPassword();\n    String  salt = user.getSalt();\n    //通过密码+盐 重新生成 MD5密码\n    String md5Password = MD5Util.md5(password+salt);\n    if(md5Password.equals(dbPassword)) {\n        //登录成功\n    }\n}\n```\n\n\n### 8. 扩展：MessageDigest类常用方法\n#### 8.1 构造方法摘要\n`MessageDigest(String algorithm)` --创建具有指定算法名称的MessageDigest 实例对象。\n- MessageDigest类是一个工厂类，其构造器是受保护的，不允许直接使用new MessageDigist( )来创建对象，而必须通过其静态方法getInstance( )生成MessageDigest对象。其中传入的参数指定计算消息摘要所使用的算法，常用的有\"MD5\"，\"SHA\"等。\n\n#### 8.2 成员方法摘要：\n| 返回值 |   方法名  | 描述          |\n|---------|--------------|---------|\n| Object  | `clone()`    | 如果实现是可复制的，则返回一个副本。|\n|byte[]   | `digest()`   | 通过执行诸如填充之类的最终操作完成哈希计算。|\n|byte[]   |`digest(byte[] input)`| 使用指定的字节数组对摘要进行最后更新，然后完成摘要计算。|\n| int     |`digest(byte[] buf, int offset, int len)`|通过执行诸如填充之类的最终操作完成哈希计算。|\n| String  |`getAlgorithm()`|返回标识算法的独立于实现细节的字符串。|\n| int     |`getDigestLength()`|返回以字节为单位的摘要长度，如果提供程序不支持此操作并且实现是不可复制的，则返回 0。|\n|static MessageDigest|`getInstance(String algorithm)`|生成实现指定摘要算法的 MessageDigest 对象。|\n|static MessageDigest|`getInstance(String algorithm, Provider provider)`|生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。|\n|static MessageDigest|`getInstance(String algorithm, String provider)`|生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。|\n| Provider|`getProvider()`|返回此信息摘要对象的提供程序。|\n|static boolean|`isEqual(byte[] digesta, byte[] digestb)`|比较两个摘要的相等性。|\n| void   |`reset()`|重置摘要以供再次使用。|\n| String |`toString()`|返回此信息摘要对象的字符串表示形式。|\n| void   |`update(byte input)`|使用指定的字节更新摘要。|\n| void   |`update(byte[] input)`|使用指定的字节数组更新摘要。|\n| void   |`update(byte[] input, int offset, int len)`|使用指定的字节数组，从指定的偏移量开始更新摘要。|\n| void   |`update(ByteBuffer input)`|使用指定的 ByteBuffer 更新摘要。|\n\n\n> ★ 编程思路：java.security包中的MessageDigest类提供了计算消息摘要（即生成散列码）的方法，首先生成对象，执行其update( )方法可以将原始数据传递给该对象，然后执行其digest( )方法即可得到消息摘要。\n","source":"_posts/【安全认证】MD5算法加盐实现用户密码加密.md","raw":"---\ntitle: 【安全认证】MD5算法加盐实现用户密码加密\ndate: 2019-07-28 21:49:28\ntags: [后端开发, 安全认证]\ncategories: 安全认证\n---\n\n\n### 1. MD5加密算法介绍\nMD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被\"压缩\"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。\n<!-- more --> \n\n### 2. MD5加密算法特点：\n1. 压缩性：任意长度的数据，算出的MD5值长度都是固定的。\n2. 容易计算：从原数据计算出MD5值很容易。\n3. 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。\n4. 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。\n\n### 3. 盐（Salt）\n在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。\n\n### 4. java.security.MessageDigest类\nJDK中的java.security.MessageDigest用于为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。\n- MessageDigest 通过其getInstance系列静态函数来进行实例化和初始化。\n- MessageDigest 对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算并返回结果。\n- 对于给定数量的更新数据，digest 方法只能被调用一次。digest 方法被调用后，MessageDigest  对象被重新设置成其初始状态。\n\n### 5. 封装一个MD5加密工具类\n``` java\nimport java.security.MessageDigest;\nimport java.util.UUID;\npublic class MD5Util {\n    /**\n     * md5加密\n     * @param s：待加密字符串\n     * @return 加密后16进制字符串\n     */\n    public static String md5(String s) {\n        try {\n            //实例化MessageDigest的MD5算法对象\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            //通过digest方法返回哈希计算后的字节数组\n            byte[] bytes = md.digest(s.getBytes(\"utf-8\"));\n            //将字节数组转换为16进制字符串并返回\n            return toHex(bytes);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n    /**\n     * 获取随即盐\n     * @return\n     */\n    public static String salt(){\n        //利用UUID生成随机盐\n        UUID uuid = UUID.randomUUID();\n        //返回a2c64597-232f-4782-ab2d-9dfeb9d76932\n        String[] arr = uuid.toString().split(\"-\");\n        return arr[0];\n    }\n    /**\n     * 字节数组转换为16进制字符串\n     * @param bytes数组\n     * @return 16进制字符串\n     */\n    private static String toHex(byte[] bytes) {\n        final char[] HEX_DIGITS = \"0123456789ABCDEF\".toCharArray();\n        StringBuilder ret = new StringBuilder(bytes.length * 2);\n        for (int i=0; i<bytes.length; i++) {\n            ret.append(HEX_DIGITS[(bytes[i] >> 4) & 0x0f]);\n            ret.append(HEX_DIGITS[bytes[i] & 0x0f]);\n        }\n        return ret.toString();\n    }\n}\n```\n\n\n### 6. 使用封装的MD5工具类完成用户注册(主要代码)\n``` java\npublic Object register(String name, String password) {\n    //添加用户信息\n    user = new User();\n    //设置用户名\n    user.setName(name);\n    //密码加密后再保存\n    String salt = MD5Util.salt();\n    String md5Password = MD5Util.md5(password+salt);\n    //存入MD5加密后的密码\n    user.setPassword(md5Password);\n    //随机盐存入数据库，用于登录校验\n    user.setSalt(salt);\n    //最后将用户数据数据存入数据库\n    int row = userDao.insert(user);\n    return ...\n}\n```\n\n\n### 7. 使用封装的MD5工具类完成用户登录(主要代码)\n``` java\npublic Object login(String name, String password) {\n    //根据用户名在数据库查找用户\n    User user = userDao.selectByName(name);\n    //取出用户信息比对\n    String dbPassword = user.getPassword();\n    String  salt = user.getSalt();\n    //通过密码+盐 重新生成 MD5密码\n    String md5Password = MD5Util.md5(password+salt);\n    if(md5Password.equals(dbPassword)) {\n        //登录成功\n    }\n}\n```\n\n\n### 8. 扩展：MessageDigest类常用方法\n#### 8.1 构造方法摘要\n`MessageDigest(String algorithm)` --创建具有指定算法名称的MessageDigest 实例对象。\n- MessageDigest类是一个工厂类，其构造器是受保护的，不允许直接使用new MessageDigist( )来创建对象，而必须通过其静态方法getInstance( )生成MessageDigest对象。其中传入的参数指定计算消息摘要所使用的算法，常用的有\"MD5\"，\"SHA\"等。\n\n#### 8.2 成员方法摘要：\n| 返回值 |   方法名  | 描述          |\n|---------|--------------|---------|\n| Object  | `clone()`    | 如果实现是可复制的，则返回一个副本。|\n|byte[]   | `digest()`   | 通过执行诸如填充之类的最终操作完成哈希计算。|\n|byte[]   |`digest(byte[] input)`| 使用指定的字节数组对摘要进行最后更新，然后完成摘要计算。|\n| int     |`digest(byte[] buf, int offset, int len)`|通过执行诸如填充之类的最终操作完成哈希计算。|\n| String  |`getAlgorithm()`|返回标识算法的独立于实现细节的字符串。|\n| int     |`getDigestLength()`|返回以字节为单位的摘要长度，如果提供程序不支持此操作并且实现是不可复制的，则返回 0。|\n|static MessageDigest|`getInstance(String algorithm)`|生成实现指定摘要算法的 MessageDigest 对象。|\n|static MessageDigest|`getInstance(String algorithm, Provider provider)`|生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。|\n|static MessageDigest|`getInstance(String algorithm, String provider)`|生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。|\n| Provider|`getProvider()`|返回此信息摘要对象的提供程序。|\n|static boolean|`isEqual(byte[] digesta, byte[] digestb)`|比较两个摘要的相等性。|\n| void   |`reset()`|重置摘要以供再次使用。|\n| String |`toString()`|返回此信息摘要对象的字符串表示形式。|\n| void   |`update(byte input)`|使用指定的字节更新摘要。|\n| void   |`update(byte[] input)`|使用指定的字节数组更新摘要。|\n| void   |`update(byte[] input, int offset, int len)`|使用指定的字节数组，从指定的偏移量开始更新摘要。|\n| void   |`update(ByteBuffer input)`|使用指定的 ByteBuffer 更新摘要。|\n\n\n> ★ 编程思路：java.security包中的MessageDigest类提供了计算消息摘要（即生成散列码）的方法，首先生成对象，执行其update( )方法可以将原始数据传递给该对象，然后执行其digest( )方法即可得到消息摘要。\n","slug":"【安全认证】MD5算法加盐实现用户密码加密","published":1,"updated":"2021-12-12T02:50:23.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6v5000hvcuefp7mg157","content":"<h3 id=\"1-MD5加密算法介绍\"><a href=\"#1-MD5加密算法介绍\" class=\"headerlink\" title=\"1. MD5加密算法介绍\"></a>1. MD5加密算法介绍</h3><p>MD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。</p>\n<span id=\"more\"></span> \n\n<h3 id=\"2-MD5加密算法特点：\"><a href=\"#2-MD5加密算法特点：\" class=\"headerlink\" title=\"2. MD5加密算法特点：\"></a>2. MD5加密算法特点：</h3><ol>\n<li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li>\n<li>容易计算：从原数据计算出MD5值很容易。</li>\n<li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li>\n<li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li>\n</ol>\n<h3 id=\"3-盐（Salt）\"><a href=\"#3-盐（Salt）\" class=\"headerlink\" title=\"3. 盐（Salt）\"></a>3. 盐（Salt）</h3><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p>\n<h3 id=\"4-java-security-MessageDigest类\"><a href=\"#4-java-security-MessageDigest类\" class=\"headerlink\" title=\"4. java.security.MessageDigest类\"></a>4. java.security.MessageDigest类</h3><p>JDK中的java.security.MessageDigest用于为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。</p>\n<ul>\n<li>MessageDigest 通过其getInstance系列静态函数来进行实例化和初始化。</li>\n<li>MessageDigest 对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算并返回结果。</li>\n<li>对于给定数量的更新数据，digest 方法只能被调用一次。digest 方法被调用后，MessageDigest  对象被重新设置成其初始状态。</li>\n</ul>\n<h3 id=\"5-封装一个MD5加密工具类\"><a href=\"#5-封装一个MD5加密工具类\" class=\"headerlink\" title=\"5. 封装一个MD5加密工具类\"></a>5. 封装一个MD5加密工具类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.security.MessageDigest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MD5Util</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * md5加密</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> s：待加密字符串</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 加密后16进制字符串</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">md5</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//实例化MessageDigest的MD5算法对象</span></span><br><span class=\"line\">            MessageDigest md = MessageDigest.getInstance(<span class=\"string\">&quot;MD5&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//通过digest方法返回哈希计算后的字节数组</span></span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = md.digest(s.getBytes(<span class=\"string\">&quot;utf-8&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">//将字节数组转换为16进制字符串并返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> toHex(bytes);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取随即盐</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">salt</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//利用UUID生成随机盐</span></span><br><span class=\"line\">        UUID uuid = UUID.randomUUID();</span><br><span class=\"line\">        <span class=\"comment\">//返回a2c64597-232f-4782-ab2d-9dfeb9d76932</span></span><br><span class=\"line\">        String[] arr = uuid.toString().split(<span class=\"string\">&quot;-&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 字节数组转换为16进制字符串</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bytes数组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 16进制字符串</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">toHex</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bytes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] HEX_DIGITS = <span class=\"string\">&quot;0123456789ABCDEF&quot;</span>.toCharArray();</span><br><span class=\"line\">        StringBuilder ret = <span class=\"keyword\">new</span> StringBuilder(bytes.length * <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;bytes.length; i++) &#123;</span><br><span class=\"line\">            ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">0x0f</span>]);</span><br><span class=\"line\">            ret.append(HEX_DIGITS[bytes[i] &amp; <span class=\"number\">0x0f</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"6-使用封装的MD5工具类完成用户注册-主要代码\"><a href=\"#6-使用封装的MD5工具类完成用户注册-主要代码\" class=\"headerlink\" title=\"6. 使用封装的MD5工具类完成用户注册(主要代码)\"></a>6. 使用封装的MD5工具类完成用户注册(主要代码)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">register</span><span class=\"params\">(String name, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加用户信息</span></span><br><span class=\"line\">    user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    <span class=\"comment\">//设置用户名</span></span><br><span class=\"line\">    user.setName(name);</span><br><span class=\"line\">    <span class=\"comment\">//密码加密后再保存</span></span><br><span class=\"line\">    String salt = MD5Util.salt();</span><br><span class=\"line\">    String md5Password = MD5Util.md5(password+salt);</span><br><span class=\"line\">    <span class=\"comment\">//存入MD5加密后的密码</span></span><br><span class=\"line\">    user.setPassword(md5Password);</span><br><span class=\"line\">    <span class=\"comment\">//随机盐存入数据库，用于登录校验</span></span><br><span class=\"line\">    user.setSalt(salt);</span><br><span class=\"line\">    <span class=\"comment\">//最后将用户数据数据存入数据库</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> row = userDao.insert(user);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"7-使用封装的MD5工具类完成用户登录-主要代码\"><a href=\"#7-使用封装的MD5工具类完成用户登录-主要代码\" class=\"headerlink\" title=\"7. 使用封装的MD5工具类完成用户登录(主要代码)\"></a>7. 使用封装的MD5工具类完成用户登录(主要代码)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">login</span><span class=\"params\">(String name, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//根据用户名在数据库查找用户</span></span><br><span class=\"line\">    User user = userDao.selectByName(name);</span><br><span class=\"line\">    <span class=\"comment\">//取出用户信息比对</span></span><br><span class=\"line\">    String dbPassword = user.getPassword();</span><br><span class=\"line\">    String  salt = user.getSalt();</span><br><span class=\"line\">    <span class=\"comment\">//通过密码+盐 重新生成 MD5密码</span></span><br><span class=\"line\">    String md5Password = MD5Util.md5(password+salt);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//登录成功</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"8-扩展：MessageDigest类常用方法\"><a href=\"#8-扩展：MessageDigest类常用方法\" class=\"headerlink\" title=\"8. 扩展：MessageDigest类常用方法\"></a>8. 扩展：MessageDigest类常用方法</h3><h4 id=\"8-1-构造方法摘要\"><a href=\"#8-1-构造方法摘要\" class=\"headerlink\" title=\"8.1 构造方法摘要\"></a>8.1 构造方法摘要</h4><p><code>MessageDigest(String algorithm)</code> –创建具有指定算法名称的MessageDigest 实例对象。</p>\n<ul>\n<li>MessageDigest类是一个工厂类，其构造器是受保护的，不允许直接使用new MessageDigist( )来创建对象，而必须通过其静态方法getInstance( )生成MessageDigest对象。其中传入的参数指定计算消息摘要所使用的算法，常用的有”MD5”，”SHA”等。</li>\n</ul>\n<h4 id=\"8-2-成员方法摘要：\"><a href=\"#8-2-成员方法摘要：\" class=\"headerlink\" title=\"8.2 成员方法摘要：\"></a>8.2 成员方法摘要：</h4><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Object</td>\n<td><code>clone()</code></td>\n<td>如果实现是可复制的，则返回一个副本。</td>\n</tr>\n<tr>\n<td>byte[]</td>\n<td><code>digest()</code></td>\n<td>通过执行诸如填充之类的最终操作完成哈希计算。</td>\n</tr>\n<tr>\n<td>byte[]</td>\n<td><code>digest(byte[] input)</code></td>\n<td>使用指定的字节数组对摘要进行最后更新，然后完成摘要计算。</td>\n</tr>\n<tr>\n<td>int</td>\n<td><code>digest(byte[] buf, int offset, int len)</code></td>\n<td>通过执行诸如填充之类的最终操作完成哈希计算。</td>\n</tr>\n<tr>\n<td>String</td>\n<td><code>getAlgorithm()</code></td>\n<td>返回标识算法的独立于实现细节的字符串。</td>\n</tr>\n<tr>\n<td>int</td>\n<td><code>getDigestLength()</code></td>\n<td>返回以字节为单位的摘要长度，如果提供程序不支持此操作并且实现是不可复制的，则返回 0。</td>\n</tr>\n<tr>\n<td>static MessageDigest</td>\n<td><code>getInstance(String algorithm)</code></td>\n<td>生成实现指定摘要算法的 MessageDigest 对象。</td>\n</tr>\n<tr>\n<td>static MessageDigest</td>\n<td><code>getInstance(String algorithm, Provider provider)</code></td>\n<td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td>\n</tr>\n<tr>\n<td>static MessageDigest</td>\n<td><code>getInstance(String algorithm, String provider)</code></td>\n<td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td>\n</tr>\n<tr>\n<td>Provider</td>\n<td><code>getProvider()</code></td>\n<td>返回此信息摘要对象的提供程序。</td>\n</tr>\n<tr>\n<td>static boolean</td>\n<td><code>isEqual(byte[] digesta, byte[] digestb)</code></td>\n<td>比较两个摘要的相等性。</td>\n</tr>\n<tr>\n<td>void</td>\n<td><code>reset()</code></td>\n<td>重置摘要以供再次使用。</td>\n</tr>\n<tr>\n<td>String</td>\n<td><code>toString()</code></td>\n<td>返回此信息摘要对象的字符串表示形式。</td>\n</tr>\n<tr>\n<td>void</td>\n<td><code>update(byte input)</code></td>\n<td>使用指定的字节更新摘要。</td>\n</tr>\n<tr>\n<td>void</td>\n<td><code>update(byte[] input)</code></td>\n<td>使用指定的字节数组更新摘要。</td>\n</tr>\n<tr>\n<td>void</td>\n<td><code>update(byte[] input, int offset, int len)</code></td>\n<td>使用指定的字节数组，从指定的偏移量开始更新摘要。</td>\n</tr>\n<tr>\n<td>void</td>\n<td><code>update(ByteBuffer input)</code></td>\n<td>使用指定的 ByteBuffer 更新摘要。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>★ 编程思路：java.security包中的MessageDigest类提供了计算消息摘要（即生成散列码）的方法，首先生成对象，执行其update( )方法可以将原始数据传递给该对象，然后执行其digest( )方法即可得到消息摘要。</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h3 id=\"1-MD5加密算法介绍\"><a href=\"#1-MD5加密算法介绍\" class=\"headerlink\" title=\"1. MD5加密算法介绍\"></a>1. MD5加密算法介绍</h3><p>MD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。</p>","more":"<h3 id=\"2-MD5加密算法特点：\"><a href=\"#2-MD5加密算法特点：\" class=\"headerlink\" title=\"2. MD5加密算法特点：\"></a>2. MD5加密算法特点：</h3><ol>\n<li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li>\n<li>容易计算：从原数据计算出MD5值很容易。</li>\n<li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li>\n<li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li>\n</ol>\n<h3 id=\"3-盐（Salt）\"><a href=\"#3-盐（Salt）\" class=\"headerlink\" title=\"3. 盐（Salt）\"></a>3. 盐（Salt）</h3><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p>\n<h3 id=\"4-java-security-MessageDigest类\"><a href=\"#4-java-security-MessageDigest类\" class=\"headerlink\" title=\"4. java.security.MessageDigest类\"></a>4. java.security.MessageDigest类</h3><p>JDK中的java.security.MessageDigest用于为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。</p>\n<ul>\n<li>MessageDigest 通过其getInstance系列静态函数来进行实例化和初始化。</li>\n<li>MessageDigest 对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算并返回结果。</li>\n<li>对于给定数量的更新数据，digest 方法只能被调用一次。digest 方法被调用后，MessageDigest  对象被重新设置成其初始状态。</li>\n</ul>\n<h3 id=\"5-封装一个MD5加密工具类\"><a href=\"#5-封装一个MD5加密工具类\" class=\"headerlink\" title=\"5. 封装一个MD5加密工具类\"></a>5. 封装一个MD5加密工具类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.security.MessageDigest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MD5Util</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * md5加密</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> s：待加密字符串</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 加密后16进制字符串</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">md5</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//实例化MessageDigest的MD5算法对象</span></span><br><span class=\"line\">            MessageDigest md = MessageDigest.getInstance(<span class=\"string\">&quot;MD5&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//通过digest方法返回哈希计算后的字节数组</span></span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = md.digest(s.getBytes(<span class=\"string\">&quot;utf-8&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">//将字节数组转换为16进制字符串并返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> toHex(bytes);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取随即盐</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">salt</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//利用UUID生成随机盐</span></span><br><span class=\"line\">        UUID uuid = UUID.randomUUID();</span><br><span class=\"line\">        <span class=\"comment\">//返回a2c64597-232f-4782-ab2d-9dfeb9d76932</span></span><br><span class=\"line\">        String[] arr = uuid.toString().split(<span class=\"string\">&quot;-&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 字节数组转换为16进制字符串</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bytes数组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 16进制字符串</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">toHex</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bytes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] HEX_DIGITS = <span class=\"string\">&quot;0123456789ABCDEF&quot;</span>.toCharArray();</span><br><span class=\"line\">        StringBuilder ret = <span class=\"keyword\">new</span> StringBuilder(bytes.length * <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;bytes.length; i++) &#123;</span><br><span class=\"line\">            ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">0x0f</span>]);</span><br><span class=\"line\">            ret.append(HEX_DIGITS[bytes[i] &amp; <span class=\"number\">0x0f</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"6-使用封装的MD5工具类完成用户注册-主要代码\"><a href=\"#6-使用封装的MD5工具类完成用户注册-主要代码\" class=\"headerlink\" title=\"6. 使用封装的MD5工具类完成用户注册(主要代码)\"></a>6. 使用封装的MD5工具类完成用户注册(主要代码)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">register</span><span class=\"params\">(String name, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加用户信息</span></span><br><span class=\"line\">    user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    <span class=\"comment\">//设置用户名</span></span><br><span class=\"line\">    user.setName(name);</span><br><span class=\"line\">    <span class=\"comment\">//密码加密后再保存</span></span><br><span class=\"line\">    String salt = MD5Util.salt();</span><br><span class=\"line\">    String md5Password = MD5Util.md5(password+salt);</span><br><span class=\"line\">    <span class=\"comment\">//存入MD5加密后的密码</span></span><br><span class=\"line\">    user.setPassword(md5Password);</span><br><span class=\"line\">    <span class=\"comment\">//随机盐存入数据库，用于登录校验</span></span><br><span class=\"line\">    user.setSalt(salt);</span><br><span class=\"line\">    <span class=\"comment\">//最后将用户数据数据存入数据库</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> row = userDao.insert(user);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"7-使用封装的MD5工具类完成用户登录-主要代码\"><a href=\"#7-使用封装的MD5工具类完成用户登录-主要代码\" class=\"headerlink\" title=\"7. 使用封装的MD5工具类完成用户登录(主要代码)\"></a>7. 使用封装的MD5工具类完成用户登录(主要代码)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">login</span><span class=\"params\">(String name, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//根据用户名在数据库查找用户</span></span><br><span class=\"line\">    User user = userDao.selectByName(name);</span><br><span class=\"line\">    <span class=\"comment\">//取出用户信息比对</span></span><br><span class=\"line\">    String dbPassword = user.getPassword();</span><br><span class=\"line\">    String  salt = user.getSalt();</span><br><span class=\"line\">    <span class=\"comment\">//通过密码+盐 重新生成 MD5密码</span></span><br><span class=\"line\">    String md5Password = MD5Util.md5(password+salt);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//登录成功</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"8-扩展：MessageDigest类常用方法\"><a href=\"#8-扩展：MessageDigest类常用方法\" class=\"headerlink\" title=\"8. 扩展：MessageDigest类常用方法\"></a>8. 扩展：MessageDigest类常用方法</h3><h4 id=\"8-1-构造方法摘要\"><a href=\"#8-1-构造方法摘要\" class=\"headerlink\" title=\"8.1 构造方法摘要\"></a>8.1 构造方法摘要</h4><p><code>MessageDigest(String algorithm)</code> –创建具有指定算法名称的MessageDigest 实例对象。</p>\n<ul>\n<li>MessageDigest类是一个工厂类，其构造器是受保护的，不允许直接使用new MessageDigist( )来创建对象，而必须通过其静态方法getInstance( )生成MessageDigest对象。其中传入的参数指定计算消息摘要所使用的算法，常用的有”MD5”，”SHA”等。</li>\n</ul>\n<h4 id=\"8-2-成员方法摘要：\"><a href=\"#8-2-成员方法摘要：\" class=\"headerlink\" title=\"8.2 成员方法摘要：\"></a>8.2 成员方法摘要：</h4><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Object</td>\n<td><code>clone()</code></td>\n<td>如果实现是可复制的，则返回一个副本。</td>\n</tr>\n<tr>\n<td>byte[]</td>\n<td><code>digest()</code></td>\n<td>通过执行诸如填充之类的最终操作完成哈希计算。</td>\n</tr>\n<tr>\n<td>byte[]</td>\n<td><code>digest(byte[] input)</code></td>\n<td>使用指定的字节数组对摘要进行最后更新，然后完成摘要计算。</td>\n</tr>\n<tr>\n<td>int</td>\n<td><code>digest(byte[] buf, int offset, int len)</code></td>\n<td>通过执行诸如填充之类的最终操作完成哈希计算。</td>\n</tr>\n<tr>\n<td>String</td>\n<td><code>getAlgorithm()</code></td>\n<td>返回标识算法的独立于实现细节的字符串。</td>\n</tr>\n<tr>\n<td>int</td>\n<td><code>getDigestLength()</code></td>\n<td>返回以字节为单位的摘要长度，如果提供程序不支持此操作并且实现是不可复制的，则返回 0。</td>\n</tr>\n<tr>\n<td>static MessageDigest</td>\n<td><code>getInstance(String algorithm)</code></td>\n<td>生成实现指定摘要算法的 MessageDigest 对象。</td>\n</tr>\n<tr>\n<td>static MessageDigest</td>\n<td><code>getInstance(String algorithm, Provider provider)</code></td>\n<td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td>\n</tr>\n<tr>\n<td>static MessageDigest</td>\n<td><code>getInstance(String algorithm, String provider)</code></td>\n<td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td>\n</tr>\n<tr>\n<td>Provider</td>\n<td><code>getProvider()</code></td>\n<td>返回此信息摘要对象的提供程序。</td>\n</tr>\n<tr>\n<td>static boolean</td>\n<td><code>isEqual(byte[] digesta, byte[] digestb)</code></td>\n<td>比较两个摘要的相等性。</td>\n</tr>\n<tr>\n<td>void</td>\n<td><code>reset()</code></td>\n<td>重置摘要以供再次使用。</td>\n</tr>\n<tr>\n<td>String</td>\n<td><code>toString()</code></td>\n<td>返回此信息摘要对象的字符串表示形式。</td>\n</tr>\n<tr>\n<td>void</td>\n<td><code>update(byte input)</code></td>\n<td>使用指定的字节更新摘要。</td>\n</tr>\n<tr>\n<td>void</td>\n<td><code>update(byte[] input)</code></td>\n<td>使用指定的字节数组更新摘要。</td>\n</tr>\n<tr>\n<td>void</td>\n<td><code>update(byte[] input, int offset, int len)</code></td>\n<td>使用指定的字节数组，从指定的偏移量开始更新摘要。</td>\n</tr>\n<tr>\n<td>void</td>\n<td><code>update(ByteBuffer input)</code></td>\n<td>使用指定的 ByteBuffer 更新摘要。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>★ 编程思路：java.security包中的MessageDigest类提供了计算消息摘要（即生成散列码）的方法，首先生成对象，执行其update( )方法可以将原始数据传递给该对象，然后执行其digest( )方法即可得到消息摘要。</p>\n</blockquote>"},{"title":"【数据库】MongoDB学习笔记","date":"2016-07-30T10:20:16.000Z","_content":"\n## part1 安装配置\n\n### 一、安装：\n\n在mongodb官网下载对应自己电脑系统的安装包，地址为： [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)。\n<!-- more --> \n1、以Windows64bit为例，下载.msi文件双击安装。\n2、安装过程中，点击 \"Custom(自定义)\" 按钮来设置安装目录(D:\\MongoDB\\bin)。\n3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。\n4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod --dbpath D:\\MongoDB\\data\\db)\n``` bash\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --dbpath D:\\MongoDB\\data\\db\n```\n5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)\n``` bash\n  MongoDB shell version: 3.2.4  //mongodb版本\n  connecting to: test  //默认shell连接的是本机localhost 上面的test库\n```\n此时就可以操作数据库了。\n\n### 二、将MongoDB服务器作为Windows服务运行\n\n1、在D:\\MongoDB目录下创建mongodb.config,写入如下：\n``` bash\n  ## 数据库文件目录\n  dbpath=D:/MongoDB/data\n  ## 日志目录\n  logpath=D:/MongoDB/log/mongo.log\n  diaglog=3\n```\n2、常规命令(cmd管理员):\n```\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --config D:\\MongoDB\\mongodb.config \n```\n3、若常规方式失败，则sc方式(cmd管理员)：\n```\n  D:\n  cd D:\\MongoDB\\bin\n  sc create mongodb binPath= \"D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config\" \n```\n访问地址：localhost:27017测试是否启动成功\n\n\n## part2 CRUD操作(Creat,Read,Update,Delete)\n\n### 一、基础：\n\n1、document(文档)\n\nMongoDB把所有数据存放在类似于JSON数据结构的文档内：\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.2\" }\n```\n\n2、collection(集合)\n\n集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.1\" }\n  { \"item\": \"pencil2\", \"qty\": 550, \"type\": \"no.2\" }\n  { \"item\": \"pencil3\", \"qty\": 800, \"type\": \"no.3\" }\n```\n\n3、database(数据库)\n\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。\n\n### 二、数据库操作：\n\n连接及运行mongoDB\n\"`show dbs`\"命令可以显示所有的数据的列表\n\"`db`\"命令可以显示当前数据库对象或集合\n\"`use`\"命令可以连接到一个指定的数据库\n数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。\n  1.不能是空字符串（\"\")。\n  2.不得含有' '（空格)、.、$、/、\\和\\0 (空宇符)。\n  3.应全部小写。\n  4.最多64字节。\n\n1、创建数据库：`use Database_Name`\n``` bash\n  use test  ##创建名为test的数据库\n```\n2、删除当前数据库：\n``` bash\n  db.dropDatabase()\n```\n\n### 三、文档操作（以 Collection_Name = col 为例）\n\n#### 1、插入：\n``` bash\n  db.col.insert(Document)     ##插入一条或多组数据\n  db.col.insertOne(Document)  ##插入一条数据\n  db.col.insertMany(Document) ##插入多条数据\n  ##例如：\n      db.col.insertOne({ \"item\": \"pencil\", \"type\": \"no.1\" })\n      db.col.insertMany([\n      { \"item\": \"dog\", \"type\": \"no.2\" },\n      { \"item\": \"apple\", \"type\": \"no.3\" },\n      { \"item\": \"orange\", \"type\": \"no.4\" }\n      ])\n```\n\n#### 2、删除：\n``` bash\n  db.col.remove({})                    ##删除所有数据\n  db.col.remove(query <,options>)\n      #  query: 查询条件(数据索引或名字)\n      #  ptions:两个可选参数\n      #      {justOne: <boolean>,     //默认false，删除所有匹配到的。\n      #       writeConcern: <document>//抛出异常的级别。\n      #      }\n  db.col.deleteOne(query <,options>)   ##同上，无justOne参数，只删除第一条\n  db.col.deleteMany(query <,options>)  ##同上，无justOne参数，只删除多条\n```\n\n### 3、更新：\n``` bash\n  db.col.update(query, update <,options>)\n      #  query:  查询条件(数据索引或名字)\n      #  update: 更新的内容，语法：{$set:query}\n      #  options:三个可选参数\n      #      {upsert: <boolean>,      //如果不存在update的记录，是否插入新数据，默认:false。\n      #       multi: <boolean>,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。\n      #       writeConcern: <document>//#抛出异常的级别。\n      #      }\n  ##例如：\n      db.col.update(\n          {\"type\": \"no.1\"}, \n          {$set: {\"item\": \"human\"}}, \n          {upsert: true, multi: true}\n          )\n  db.col.updateOne()                    ##同上，无multi参数，只更新第一条\n  db.col.updateMany()                   ##同上，无multi参数\n  db.col.replaceOne()                   ##同updateOne\n  db.col.save(document <,writeConcern>) ##通过传入的文档整个替换\n```\n##### insert 与 save的区别\n如果插入的数据的_id相同,save将会更新该文档,而insert将会报错\n\n##### update常用操作符\n``` bash\n  $set         ##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.\n  $unset       ##删除文档中的一个字段.\n  $rename      ##重命名某个列\n  $inc         ##增长某个列\n  $setOnInsert ##当upsert为true时,并且发生了insert操作时,可以补充的字段\n  $push        ##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.\n  $pushAll     ##将多个数值一次存入数组.上面的push只能一个一个的存入\n  $addToSet    ##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.\n  $pop         ##删除数组最后一个元素\n  $pull        ##删除数组中的指定的元素,如果删除的字段不是数组,会报错\n  $pullAll     ##删除数组中的多个值,跟pushAll与push的关系类似.\n```\n\n### 4、查询\n``` bash\n  db.col.find({})          ##查询所有文档\n  db.col.find().pretty()   ##以易读的方式来读取数据\n  db.collection.find(query, projection)\n      #  query：查询条件(数据索引或名字)\n      #  projection：可选。指定返回的字段。\n```\n\n#### 4.1、深入查询表达式\n``` bash\n  db.col.find()##查询所有\n  db.col.find({filed: value})                              ##等值查询\n  db.col.find({filed: {$ne: value}})                       ##不等于 $ne\n  db.col.find({filed: {$nin: [value1, value2, ...]}})      ##不能包含给定的值 $nin\n  db.col.find({filed: {$all: [value1, value2, ...]}})      ##必须包含所有给定的值 $all\n  db.col.find({filed: {$in: [value1, value2, ...]}})       ##只要包含一个或多个给定的值 $in\n  db.col.find({filed: {$exists:1}})                        ##存在filed字段的\n  db.col.find({filed: {$exists:0}})                        ##不存在filed字段的\n  db.col.find({filed: {$mod:[3,1]}})                       ##模三余一，$mod(取模操作)\n  db.col.find({$or: [{filed1: vulue1}, {filed2: vulue2}]}) ##或 $or\n  db.col.find({$nor: [{filed1: vulue1}, {filed2: vulue2}]})##排除 $nor\n  db.col.find({filed: {$size: 3}})                         ##返回值得数组是给定的长度(3) $size\n  db.col.find({$where: function(){return ...}})            ##回调，隐式迭代，符合条件才返回\n  db.col.find({$where: '...'}})                            ##同上\n  db.col.find({age: {$lt: 5}}).limit(3)                    ##查询age的值小于5，限制3条\n      #范围查询：\n      #    $lt  （小于）\n      #    $gt  （大于）\n      #    $lte （小于等于）\n      #    $gte （大于等于）\n      #    limit（限制显示）\n  db.col.find().skip(2).limit(3)                           ##跳过前两个文档查询后面三个\n      #  skip(num):表示跳过前面num个文档\n  db.col.find().sort({age: 1})                             ##查询后以age升序排列显示\n      #  sort():排序，这里 1 代表升序, -1 代表降序.\n  db.col.find({filed: /user.*/i})                          ##正则，查询filed以user开头不区分大小写（正则效率低）\n  db.col.find({filed: {$type: 1}})                         ##查找filed为双精度的文档\n      # 根据数据类型查询 $type\n      #      |类型　　　　　　　　|编号|\n      #      |双精度　　　　　　　|1 　|\n      #      |字符串　　　　　　　|2 　|\n      #      |对象　　　　　　　　|3   |\n      #      |数组　　　　　　　　|4   |\n      #      |二进制数据　　　　　|5   |\n      #      |对象ID　　　　　　　|7   |\n      #      |布尔值　　　　　　　|8   |\n      #      |日期　　　　　　　　|9   |\n      #      |空　　　　　　　　　|10  |\n      #      |正则表达式　　　　　|11  |\n      #      |JavaScript　　　　|13  |\n      #      |符号　　　　　　　　|14  |\n      #      |JavaScript(带范围)|15  |\n      #      |32位整数　　　　　　|16  |\n      #      |时间戳　　　　　　　|17  |\n      #      |64位整数　　　　　　|18  |\n      #      |最小键　　　　　　　|255 |\n      #      |最大键　　　　　　　|127 |\n```\n\n#### 4.2、group分组查询\ngroup做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。\n``` bash\n  group({\n    key:{字段:1},\n    initial:{变量:初始值},\n    $reduce:function(doc,prev){函数代码}\n  })\n```\n其中key下的字段代表,需要按哪个字段分组.\ninitial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.\n$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.\n\n栗子：如下我们按年龄分组,同级不同年龄的用户的多少:\n``` bash\n  db.user.find()\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.group({\n      key:{age:1},\n      initial:{count:0},\n      $reduce:function(doc,prev){\n          prev.count++\n      }\n  }); \n      [\n          {\"age\": 0, \"count\": 1},\n          {\"age\": 1, \"count\": 3},\n          {\"age\": 2, \"count\": 2}\n      ]\n\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      }\n  });\n    [\n        {\"age\": 0, \"users\": [\"user0\"]},\n        {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n        {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n    ]\n```\n\n另外本函数还有两个可选参数 condition 和 finalize\ncondition就是分组的条件筛选类似mysql中的having\n``` bash\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      $reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      },\n      condition:{age:{$gt:0}}})\n　##筛选出age大于0的:\n  [\n      {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n      {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n  ]\n```\n\n#### 4.3、count统计\n``` bash\n  db.goods.count()            ##统计该集合总数\n  db.goods.count({cat_id: 3}) ##统计cat_id=3的总数\n```\n\n#### 4.4、distinct排重\n``` bash\n db.user.find()\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.distinct(\"age\") ## 特殊,传入的参数直接是字符串,而不是对象;\n      [0, 1, 2]\n```\n#### 4.5、子文档查询$elemMatch\n\nelemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。\n注意：\n(1)数组中元素是内嵌文档。\n(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。\n假设集合school有如下数据：\n``` bash\n{\n _id: 1,\n zipcode: 63109,\n students: [\n              { name: \"john\", school: 102, age: 10 },\n              { name: \"jess\", school: 102, age: 11 },\n              { name: \"jeff\", school: 108, age: 15 }\n           ]\n}\n{\n _id: 2,\n zipcode: 63110,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 3,\n zipcode: 63109,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 4,\n zipcode: 63109,\n students: [\n              { name: \"barney\", school: 102, age: 7 },\n           ]\n}\n```\n下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。\n``` bash\n  db.school.find({zipcode: 63109 },{ students: { $elemMatch: { school: 102 } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"john\", \"school\":102, \"age\":10}]}\n  {\"_id\": 3}\n  {\"_id\": 4, \"students\": [{\"name\":\"barney\", \"school\":102, \"age\":7}]}\n```\n查询结果说明：\n`_id为1的文档`，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。\n`_id为3的文档`，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含\"students\"字段。\n\n$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。\n``` bash\ndb.school.find( { zipcode: 63109 },{ students: { $elemMatch: { school: 102, age: { $gt: 10} } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"jess\", \"school\":102, \"age\":11}]}\n  {\"_id\": 3}\n  {\"_id\": 4}\n```\n","source":"_posts/【数据库】MongoDB学习笔记.md","raw":"---\ntitle: 【数据库】MongoDB学习笔记\ndate: 2016-07-30 18:20:16\ntags: [数据库, mongodb]\ncategories: 数据库\n---\n\n## part1 安装配置\n\n### 一、安装：\n\n在mongodb官网下载对应自己电脑系统的安装包，地址为： [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)。\n<!-- more --> \n1、以Windows64bit为例，下载.msi文件双击安装。\n2、安装过程中，点击 \"Custom(自定义)\" 按钮来设置安装目录(D:\\MongoDB\\bin)。\n3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。\n4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod --dbpath D:\\MongoDB\\data\\db)\n``` bash\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --dbpath D:\\MongoDB\\data\\db\n```\n5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)\n``` bash\n  MongoDB shell version: 3.2.4  //mongodb版本\n  connecting to: test  //默认shell连接的是本机localhost 上面的test库\n```\n此时就可以操作数据库了。\n\n### 二、将MongoDB服务器作为Windows服务运行\n\n1、在D:\\MongoDB目录下创建mongodb.config,写入如下：\n``` bash\n  ## 数据库文件目录\n  dbpath=D:/MongoDB/data\n  ## 日志目录\n  logpath=D:/MongoDB/log/mongo.log\n  diaglog=3\n```\n2、常规命令(cmd管理员):\n```\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --config D:\\MongoDB\\mongodb.config \n```\n3、若常规方式失败，则sc方式(cmd管理员)：\n```\n  D:\n  cd D:\\MongoDB\\bin\n  sc create mongodb binPath= \"D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config\" \n```\n访问地址：localhost:27017测试是否启动成功\n\n\n## part2 CRUD操作(Creat,Read,Update,Delete)\n\n### 一、基础：\n\n1、document(文档)\n\nMongoDB把所有数据存放在类似于JSON数据结构的文档内：\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.2\" }\n```\n\n2、collection(集合)\n\n集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.1\" }\n  { \"item\": \"pencil2\", \"qty\": 550, \"type\": \"no.2\" }\n  { \"item\": \"pencil3\", \"qty\": 800, \"type\": \"no.3\" }\n```\n\n3、database(数据库)\n\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。\n\n### 二、数据库操作：\n\n连接及运行mongoDB\n\"`show dbs`\"命令可以显示所有的数据的列表\n\"`db`\"命令可以显示当前数据库对象或集合\n\"`use`\"命令可以连接到一个指定的数据库\n数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。\n  1.不能是空字符串（\"\")。\n  2.不得含有' '（空格)、.、$、/、\\和\\0 (空宇符)。\n  3.应全部小写。\n  4.最多64字节。\n\n1、创建数据库：`use Database_Name`\n``` bash\n  use test  ##创建名为test的数据库\n```\n2、删除当前数据库：\n``` bash\n  db.dropDatabase()\n```\n\n### 三、文档操作（以 Collection_Name = col 为例）\n\n#### 1、插入：\n``` bash\n  db.col.insert(Document)     ##插入一条或多组数据\n  db.col.insertOne(Document)  ##插入一条数据\n  db.col.insertMany(Document) ##插入多条数据\n  ##例如：\n      db.col.insertOne({ \"item\": \"pencil\", \"type\": \"no.1\" })\n      db.col.insertMany([\n      { \"item\": \"dog\", \"type\": \"no.2\" },\n      { \"item\": \"apple\", \"type\": \"no.3\" },\n      { \"item\": \"orange\", \"type\": \"no.4\" }\n      ])\n```\n\n#### 2、删除：\n``` bash\n  db.col.remove({})                    ##删除所有数据\n  db.col.remove(query <,options>)\n      #  query: 查询条件(数据索引或名字)\n      #  ptions:两个可选参数\n      #      {justOne: <boolean>,     //默认false，删除所有匹配到的。\n      #       writeConcern: <document>//抛出异常的级别。\n      #      }\n  db.col.deleteOne(query <,options>)   ##同上，无justOne参数，只删除第一条\n  db.col.deleteMany(query <,options>)  ##同上，无justOne参数，只删除多条\n```\n\n### 3、更新：\n``` bash\n  db.col.update(query, update <,options>)\n      #  query:  查询条件(数据索引或名字)\n      #  update: 更新的内容，语法：{$set:query}\n      #  options:三个可选参数\n      #      {upsert: <boolean>,      //如果不存在update的记录，是否插入新数据，默认:false。\n      #       multi: <boolean>,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。\n      #       writeConcern: <document>//#抛出异常的级别。\n      #      }\n  ##例如：\n      db.col.update(\n          {\"type\": \"no.1\"}, \n          {$set: {\"item\": \"human\"}}, \n          {upsert: true, multi: true}\n          )\n  db.col.updateOne()                    ##同上，无multi参数，只更新第一条\n  db.col.updateMany()                   ##同上，无multi参数\n  db.col.replaceOne()                   ##同updateOne\n  db.col.save(document <,writeConcern>) ##通过传入的文档整个替换\n```\n##### insert 与 save的区别\n如果插入的数据的_id相同,save将会更新该文档,而insert将会报错\n\n##### update常用操作符\n``` bash\n  $set         ##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.\n  $unset       ##删除文档中的一个字段.\n  $rename      ##重命名某个列\n  $inc         ##增长某个列\n  $setOnInsert ##当upsert为true时,并且发生了insert操作时,可以补充的字段\n  $push        ##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.\n  $pushAll     ##将多个数值一次存入数组.上面的push只能一个一个的存入\n  $addToSet    ##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.\n  $pop         ##删除数组最后一个元素\n  $pull        ##删除数组中的指定的元素,如果删除的字段不是数组,会报错\n  $pullAll     ##删除数组中的多个值,跟pushAll与push的关系类似.\n```\n\n### 4、查询\n``` bash\n  db.col.find({})          ##查询所有文档\n  db.col.find().pretty()   ##以易读的方式来读取数据\n  db.collection.find(query, projection)\n      #  query：查询条件(数据索引或名字)\n      #  projection：可选。指定返回的字段。\n```\n\n#### 4.1、深入查询表达式\n``` bash\n  db.col.find()##查询所有\n  db.col.find({filed: value})                              ##等值查询\n  db.col.find({filed: {$ne: value}})                       ##不等于 $ne\n  db.col.find({filed: {$nin: [value1, value2, ...]}})      ##不能包含给定的值 $nin\n  db.col.find({filed: {$all: [value1, value2, ...]}})      ##必须包含所有给定的值 $all\n  db.col.find({filed: {$in: [value1, value2, ...]}})       ##只要包含一个或多个给定的值 $in\n  db.col.find({filed: {$exists:1}})                        ##存在filed字段的\n  db.col.find({filed: {$exists:0}})                        ##不存在filed字段的\n  db.col.find({filed: {$mod:[3,1]}})                       ##模三余一，$mod(取模操作)\n  db.col.find({$or: [{filed1: vulue1}, {filed2: vulue2}]}) ##或 $or\n  db.col.find({$nor: [{filed1: vulue1}, {filed2: vulue2}]})##排除 $nor\n  db.col.find({filed: {$size: 3}})                         ##返回值得数组是给定的长度(3) $size\n  db.col.find({$where: function(){return ...}})            ##回调，隐式迭代，符合条件才返回\n  db.col.find({$where: '...'}})                            ##同上\n  db.col.find({age: {$lt: 5}}).limit(3)                    ##查询age的值小于5，限制3条\n      #范围查询：\n      #    $lt  （小于）\n      #    $gt  （大于）\n      #    $lte （小于等于）\n      #    $gte （大于等于）\n      #    limit（限制显示）\n  db.col.find().skip(2).limit(3)                           ##跳过前两个文档查询后面三个\n      #  skip(num):表示跳过前面num个文档\n  db.col.find().sort({age: 1})                             ##查询后以age升序排列显示\n      #  sort():排序，这里 1 代表升序, -1 代表降序.\n  db.col.find({filed: /user.*/i})                          ##正则，查询filed以user开头不区分大小写（正则效率低）\n  db.col.find({filed: {$type: 1}})                         ##查找filed为双精度的文档\n      # 根据数据类型查询 $type\n      #      |类型　　　　　　　　|编号|\n      #      |双精度　　　　　　　|1 　|\n      #      |字符串　　　　　　　|2 　|\n      #      |对象　　　　　　　　|3   |\n      #      |数组　　　　　　　　|4   |\n      #      |二进制数据　　　　　|5   |\n      #      |对象ID　　　　　　　|7   |\n      #      |布尔值　　　　　　　|8   |\n      #      |日期　　　　　　　　|9   |\n      #      |空　　　　　　　　　|10  |\n      #      |正则表达式　　　　　|11  |\n      #      |JavaScript　　　　|13  |\n      #      |符号　　　　　　　　|14  |\n      #      |JavaScript(带范围)|15  |\n      #      |32位整数　　　　　　|16  |\n      #      |时间戳　　　　　　　|17  |\n      #      |64位整数　　　　　　|18  |\n      #      |最小键　　　　　　　|255 |\n      #      |最大键　　　　　　　|127 |\n```\n\n#### 4.2、group分组查询\ngroup做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。\n``` bash\n  group({\n    key:{字段:1},\n    initial:{变量:初始值},\n    $reduce:function(doc,prev){函数代码}\n  })\n```\n其中key下的字段代表,需要按哪个字段分组.\ninitial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.\n$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.\n\n栗子：如下我们按年龄分组,同级不同年龄的用户的多少:\n``` bash\n  db.user.find()\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.group({\n      key:{age:1},\n      initial:{count:0},\n      $reduce:function(doc,prev){\n          prev.count++\n      }\n  }); \n      [\n          {\"age\": 0, \"count\": 1},\n          {\"age\": 1, \"count\": 3},\n          {\"age\": 2, \"count\": 2}\n      ]\n\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      }\n  });\n    [\n        {\"age\": 0, \"users\": [\"user0\"]},\n        {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n        {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n    ]\n```\n\n另外本函数还有两个可选参数 condition 和 finalize\ncondition就是分组的条件筛选类似mysql中的having\n``` bash\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      $reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      },\n      condition:{age:{$gt:0}}})\n　##筛选出age大于0的:\n  [\n      {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n      {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n  ]\n```\n\n#### 4.3、count统计\n``` bash\n  db.goods.count()            ##统计该集合总数\n  db.goods.count({cat_id: 3}) ##统计cat_id=3的总数\n```\n\n#### 4.4、distinct排重\n``` bash\n db.user.find()\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.distinct(\"age\") ## 特殊,传入的参数直接是字符串,而不是对象;\n      [0, 1, 2]\n```\n#### 4.5、子文档查询$elemMatch\n\nelemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。\n注意：\n(1)数组中元素是内嵌文档。\n(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。\n假设集合school有如下数据：\n``` bash\n{\n _id: 1,\n zipcode: 63109,\n students: [\n              { name: \"john\", school: 102, age: 10 },\n              { name: \"jess\", school: 102, age: 11 },\n              { name: \"jeff\", school: 108, age: 15 }\n           ]\n}\n{\n _id: 2,\n zipcode: 63110,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 3,\n zipcode: 63109,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 4,\n zipcode: 63109,\n students: [\n              { name: \"barney\", school: 102, age: 7 },\n           ]\n}\n```\n下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。\n``` bash\n  db.school.find({zipcode: 63109 },{ students: { $elemMatch: { school: 102 } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"john\", \"school\":102, \"age\":10}]}\n  {\"_id\": 3}\n  {\"_id\": 4, \"students\": [{\"name\":\"barney\", \"school\":102, \"age\":7}]}\n```\n查询结果说明：\n`_id为1的文档`，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。\n`_id为3的文档`，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含\"students\"字段。\n\n$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。\n``` bash\ndb.school.find( { zipcode: 63109 },{ students: { $elemMatch: { school: 102, age: { $gt: 10} } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"jess\", \"school\":102, \"age\":11}]}\n  {\"_id\": 3}\n  {\"_id\": 4}\n```\n","slug":"【数据库】MongoDB学习笔记","published":1,"updated":"2021-12-12T02:50:23.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6v7000jvcuedid2ddy6","content":"<h2 id=\"part1-安装配置\"><a href=\"#part1-安装配置\" class=\"headerlink\" title=\"part1 安装配置\"></a>part1 安装配置</h2><h3 id=\"一、安装：\"><a href=\"#一、安装：\" class=\"headerlink\" title=\"一、安装：\"></a>一、安装：</h3><p>在mongodb官网下载对应自己电脑系统的安装包，地址为： <a href=\"http://www.mongodb.org/downloads\">http://www.mongodb.org/downloads</a>。</p>\n<span id=\"more\"></span> \n<p>1、以Windows64bit为例，下载.msi文件双击安装。<br>2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\\MongoDB\\bin)。<br>3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。<br>4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod –dbpath D:\\MongoDB\\data\\db)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\"><span class=\"built_in\">cd</span> D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --dbpath D:\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure>\n<p>5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoDB shell version: 3.2.4  //mongodb版本</span><br><span class=\"line\">connecting to: <span class=\"built_in\">test</span>  //默认shell连接的是本机localhost 上面的<span class=\"built_in\">test</span>库</span><br></pre></td></tr></table></figure>\n<p>此时就可以操作数据库了。</p>\n<h3 id=\"二、将MongoDB服务器作为Windows服务运行\"><a href=\"#二、将MongoDB服务器作为Windows服务运行\" class=\"headerlink\" title=\"二、将MongoDB服务器作为Windows服务运行\"></a>二、将MongoDB服务器作为Windows服务运行</h3><p>1、在D:\\MongoDB目录下创建mongodb.config,写入如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 数据库文件目录</span></span><br><span class=\"line\">dbpath=D:/MongoDB/data</span><br><span class=\"line\"><span class=\"comment\">## 日志目录</span></span><br><span class=\"line\">logpath=D:/MongoDB/<span class=\"built_in\">log</span>/mongo.log</span><br><span class=\"line\">diaglog=3</span><br></pre></td></tr></table></figure>\n<p>2、常规命令(cmd管理员):</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --config D:\\MongoDB\\mongodb.config </span><br></pre></td></tr></table></figure>\n<p>3、若常规方式失败，则sc方式(cmd管理员)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">sc create mongodb binPath= &quot;D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config&quot; </span><br></pre></td></tr></table></figure>\n<p>访问地址：localhost:27017测试是否启动成功</p>\n<h2 id=\"part2-CRUD操作-Creat-Read-Update-Delete\"><a href=\"#part2-CRUD操作-Creat-Read-Update-Delete\" class=\"headerlink\" title=\"part2 CRUD操作(Creat,Read,Update,Delete)\"></a>part2 CRUD操作(Creat,Read,Update,Delete)</h2><h3 id=\"一、基础：\"><a href=\"#一、基础：\" class=\"headerlink\" title=\"一、基础：\"></a>一、基础：</h3><p>1、document(文档)</p>\n<p>MongoDB把所有数据存放在类似于JSON数据结构的文档内：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">&quot;item&quot;</span>: <span class=\"string\">&quot;pencil&quot;</span>, <span class=\"attr\">&quot;qty&quot;</span>: <span class=\"number\">500</span>, <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.2&quot;</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、collection(集合)</p>\n<p>集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">&quot;item&quot;</span>: <span class=\"string\">&quot;pencil&quot;</span>, <span class=\"attr\">&quot;qty&quot;</span>: <span class=\"number\">500</span>, <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.1&quot;</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">&quot;item&quot;</span>: <span class=\"string\">&quot;pencil2&quot;</span>, <span class=\"attr\">&quot;qty&quot;</span>: <span class=\"number\">550</span>, <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.2&quot;</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">&quot;item&quot;</span>: <span class=\"string\">&quot;pencil3&quot;</span>, <span class=\"attr\">&quot;qty&quot;</span>: <span class=\"number\">800</span>, <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.3&quot;</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、database(数据库)</p>\n<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。</p>\n<h3 id=\"二、数据库操作：\"><a href=\"#二、数据库操作：\" class=\"headerlink\" title=\"二、数据库操作：\"></a>二、数据库操作：</h3><p>连接及运行mongoDB<br>“<code>show dbs</code>“命令可以显示所有的数据的列表<br>“<code>db</code>“命令可以显示当前数据库对象或集合<br>“<code>use</code>“命令可以连接到一个指定的数据库<br>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。<br>  1.不能是空字符串（””)。<br>  2.不得含有’ ‘（空格)、.、$、/、\\和\\0 (空宇符)。<br>  3.应全部小写。<br>  4.最多64字节。</p>\n<p>1、创建数据库：<code>use Database_Name</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use <span class=\"built_in\">test</span>  <span class=\"comment\">##创建名为test的数据库</span></span><br></pre></td></tr></table></figure>\n<p>2、删除当前数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.dropDatabase()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、文档操作（以-Collection-Name-col-为例）\"><a href=\"#三、文档操作（以-Collection-Name-col-为例）\" class=\"headerlink\" title=\"三、文档操作（以 Collection_Name = col 为例）\"></a>三、文档操作（以 Collection_Name = col 为例）</h3><h4 id=\"1、插入：\"><a href=\"#1、插入：\" class=\"headerlink\" title=\"1、插入：\"></a>1、插入：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.insert(Document)     <span class=\"comment\">##插入一条或多组数据</span></span><br><span class=\"line\">db.col.insertOne(Document)  <span class=\"comment\">##插入一条数据</span></span><br><span class=\"line\">db.col.insertMany(Document) <span class=\"comment\">##插入多条数据</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.insertOne(&#123; <span class=\"string\">&quot;item&quot;</span>: <span class=\"string\">&quot;pencil&quot;</span>, <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.1&quot;</span> &#125;)</span><br><span class=\"line\">    db.col.insertMany([</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;item&quot;</span>: <span class=\"string\">&quot;dog&quot;</span>, <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.2&quot;</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;item&quot;</span>: <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.3&quot;</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;item&quot;</span>: <span class=\"string\">&quot;orange&quot;</span>, <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.4&quot;</span> &#125;</span><br><span class=\"line\">    ])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、删除：\"><a href=\"#2、删除：\" class=\"headerlink\" title=\"2、删除：\"></a>2、删除：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.remove(&#123;&#125;)                    <span class=\"comment\">##删除所有数据</span></span><br><span class=\"line\">db.col.remove(query &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query: 查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  ptions:两个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;justOne: &lt;boolean&gt;,     //默认false，删除所有匹配到的。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\">db.col.deleteOne(query &lt;,options&gt;)   <span class=\"comment\">##同上，无justOne参数，只删除第一条</span></span><br><span class=\"line\">db.col.deleteMany(query &lt;,options&gt;)  <span class=\"comment\">##同上，无justOne参数，只删除多条</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、更新：\"><a href=\"#3、更新：\" class=\"headerlink\" title=\"3、更新：\"></a>3、更新：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.update(query, update &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query:  查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  update: 更新的内容，语法：&#123;$set:query&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#  options:三个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;upsert: &lt;boolean&gt;,      //如果不存在update的记录，是否插入新数据，默认:false。</span></span><br><span class=\"line\">    <span class=\"comment\">#       multi: &lt;boolean&gt;,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//#抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.update(</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.1&quot;</span>&#125;, </span><br><span class=\"line\">        &#123;<span class=\"variable\">$set</span>: &#123;<span class=\"string\">&quot;item&quot;</span>: <span class=\"string\">&quot;human&quot;</span>&#125;&#125;, </span><br><span class=\"line\">        &#123;upsert: <span class=\"literal\">true</span>, multi: <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">db.col.updateOne()                    <span class=\"comment\">##同上，无multi参数，只更新第一条</span></span><br><span class=\"line\">db.col.updateMany()                   <span class=\"comment\">##同上，无multi参数</span></span><br><span class=\"line\">db.col.replaceOne()                   <span class=\"comment\">##同updateOne</span></span><br><span class=\"line\">db.col.save(document &lt;,writeConcern&gt;) <span class=\"comment\">##通过传入的文档整个替换</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"insert-与-save的区别\"><a href=\"#insert-与-save的区别\" class=\"headerlink\" title=\"insert 与 save的区别\"></a>insert 与 save的区别</h5><p>如果插入的数据的_id相同,save将会更新该文档,而insert将会报错</p>\n<h5 id=\"update常用操作符\"><a href=\"#update常用操作符\" class=\"headerlink\" title=\"update常用操作符\"></a>update常用操作符</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$set</span>         <span class=\"comment\">##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$unset</span>       <span class=\"comment\">##删除文档中的一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$rename</span>      <span class=\"comment\">##重命名某个列</span></span><br><span class=\"line\"><span class=\"variable\">$inc</span>         <span class=\"comment\">##增长某个列</span></span><br><span class=\"line\"><span class=\"variable\">$setOnInsert</span> <span class=\"comment\">##当upsert为true时,并且发生了insert操作时,可以补充的字段</span></span><br><span class=\"line\"><span class=\"variable\">$push</span>        <span class=\"comment\">##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.</span></span><br><span class=\"line\"><span class=\"variable\">$pushAll</span>     <span class=\"comment\">##将多个数值一次存入数组.上面的push只能一个一个的存入</span></span><br><span class=\"line\"><span class=\"variable\">$addToSet</span>    <span class=\"comment\">##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.</span></span><br><span class=\"line\"><span class=\"variable\">$pop</span>         <span class=\"comment\">##删除数组最后一个元素</span></span><br><span class=\"line\"><span class=\"variable\">$pull</span>        <span class=\"comment\">##删除数组中的指定的元素,如果删除的字段不是数组,会报错</span></span><br><span class=\"line\"><span class=\"variable\">$pullAll</span>     <span class=\"comment\">##删除数组中的多个值,跟pushAll与push的关系类似.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、查询\"><a href=\"#4、查询\" class=\"headerlink\" title=\"4、查询\"></a>4、查询</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(&#123;&#125;)          <span class=\"comment\">##查询所有文档</span></span><br><span class=\"line\">db.col.find().pretty()   <span class=\"comment\">##以易读的方式来读取数据</span></span><br><span class=\"line\">db.collection.find(query, projection)</span><br><span class=\"line\">    <span class=\"comment\">#  query：查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  projection：可选。指定返回的字段。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1、深入查询表达式\"><a href=\"#4-1、深入查询表达式\" class=\"headerlink\" title=\"4.1、深入查询表达式\"></a>4.1、深入查询表达式</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find()<span class=\"comment\">##查询所有</span></span><br><span class=\"line\">db.col.find(&#123;filed: value&#125;)                              <span class=\"comment\">##等值查询</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$ne</span>: value&#125;&#125;)                       <span class=\"comment\">##不等于 $ne</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$nin</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##不能包含给定的值 $nin</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$all</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##必须包含所有给定的值 $all</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$in</span>: [value1, value2, ...]&#125;&#125;)       <span class=\"comment\">##只要包含一个或多个给定的值 $in</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:1&#125;&#125;)                        <span class=\"comment\">##存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:0&#125;&#125;)                        <span class=\"comment\">##不存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$mod</span>:[3,1]&#125;&#125;)                       <span class=\"comment\">##模三余一，$mod(取模操作)</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$or</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) <span class=\"comment\">##或 $or</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$nor</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)<span class=\"comment\">##排除 $nor</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$size</span>: 3&#125;&#125;)                         <span class=\"comment\">##返回值得数组是给定的长度(3) $size</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;<span class=\"built_in\">return</span> ...&#125;&#125;)            <span class=\"comment\">##回调，隐式迭代，符合条件才返回</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"string\">&#x27;...&#x27;</span>&#125;&#125;)                            <span class=\"comment\">##同上</span></span><br><span class=\"line\">db.col.find(&#123;age: &#123;<span class=\"variable\">$lt</span>: 5&#125;&#125;).<span class=\"built_in\">limit</span>(3)                    <span class=\"comment\">##查询age的值小于5，限制3条</span></span><br><span class=\"line\">    <span class=\"comment\">#范围查询：</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lt  （小于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gt  （大于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lte （小于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gte （大于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    limit（限制显示）</span></span><br><span class=\"line\">db.col.find().skip(2).<span class=\"built_in\">limit</span>(3)                           <span class=\"comment\">##跳过前两个文档查询后面三个</span></span><br><span class=\"line\">    <span class=\"comment\">#  skip(num):表示跳过前面num个文档</span></span><br><span class=\"line\">db.col.find().sort(&#123;age: 1&#125;)                             <span class=\"comment\">##查询后以age升序排列显示</span></span><br><span class=\"line\">    <span class=\"comment\">#  sort():排序，这里 1 代表升序, -1 代表降序.</span></span><br><span class=\"line\">db.col.find(&#123;filed: /user.*/i&#125;)                          <span class=\"comment\">##正则，查询filed以user开头不区分大小写（正则效率低）</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$type</span>: 1&#125;&#125;)                         <span class=\"comment\">##查找filed为双精度的文档</span></span><br><span class=\"line\">    <span class=\"comment\"># 根据数据类型查询 $type</span></span><br><span class=\"line\">    <span class=\"comment\">#      |类型　　　　　　　　|编号|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |双精度　　　　　　　|1 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |字符串　　　　　　　|2 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象　　　　　　　　|3   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |数组　　　　　　　　|4   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |二进制数据　　　　　|5   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象ID　　　　　　　|7   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |布尔值　　　　　　　|8   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |日期　　　　　　　　|9   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |空　　　　　　　　　|10  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |正则表达式　　　　　|11  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript　　　　|13  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |符号　　　　　　　　|14  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript(带范围)|15  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |32位整数　　　　　　|16  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |时间戳　　　　　　　|17  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |64位整数　　　　　　|18  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最小键　　　　　　　|255 |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最大键　　　　　　　|127 |</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2、group分组查询\"><a href=\"#4-2、group分组查询\" class=\"headerlink\" title=\"4.2、group分组查询\"></a>4.2、group分组查询</h4><p>group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">group(&#123;</span><br><span class=\"line\">  key:&#123;字段:1&#125;,</span><br><span class=\"line\">  initial:&#123;变量:初始值&#125;,</span><br><span class=\"line\">  <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;函数代码&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>其中key下的字段代表,需要按哪个字段分组.<br>initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.<br>$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.</p>\n<p>栗子：如下我们按年龄分组,同级不同年龄的用户的多少:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.<span class=\"function\"><span class=\"title\">find</span></span>()</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b2&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user0&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 0 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b3&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user1&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b4&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user2&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 2 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b5&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user3&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b6&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user4&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b7&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user5&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;count:0&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">    [</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;age&quot;</span>: 0, <span class=\"string\">&quot;count&quot;</span>: 1&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;age&quot;</span>: 1, <span class=\"string\">&quot;count&quot;</span>: 3&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;age&quot;</span>: 2, <span class=\"string\">&quot;count&quot;</span>: 2&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    reduce:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  [</span><br><span class=\"line\">      &#123;<span class=\"string\">&quot;age&quot;</span>: 0, <span class=\"string\">&quot;users&quot;</span>: [<span class=\"string\">&quot;user0&quot;</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">&quot;age&quot;</span>: 1, <span class=\"string\">&quot;users&quot;</span>: [<span class=\"string\">&quot;user1&quot;</span>, <span class=\"string\">&quot;user3&quot;</span>, <span class=\"string\">&quot;user4&quot;</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">&quot;age&quot;</span>: 2, <span class=\"string\">&quot;users&quot;</span>: [<span class=\"string\">&quot;user2&quot;</span>, <span class=\"string\">&quot;user5&quot;</span>]&#125;</span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure>\n\n<p>另外本函数还有两个可选参数 condition 和 finalize<br>condition就是分组的条件筛选类似mysql中的having</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    condition:&#123;age:&#123;<span class=\"variable\">$gt</span>:0&#125;&#125;&#125;)</span><br><span class=\"line\">　<span class=\"comment\">##筛选出age大于0的:</span></span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;age&quot;</span>: 1, <span class=\"string\">&quot;users&quot;</span>: [<span class=\"string\">&quot;user1&quot;</span>, <span class=\"string\">&quot;user3&quot;</span>, <span class=\"string\">&quot;user4&quot;</span>]&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;age&quot;</span>: 2, <span class=\"string\">&quot;users&quot;</span>: [<span class=\"string\">&quot;user2&quot;</span>, <span class=\"string\">&quot;user5&quot;</span>]&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3、count统计\"><a href=\"#4-3、count统计\" class=\"headerlink\" title=\"4.3、count统计\"></a>4.3、count统计</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.goods.count()            <span class=\"comment\">##统计该集合总数</span></span><br><span class=\"line\">db.goods.count(&#123;cat_id: 3&#125;) <span class=\"comment\">##统计cat_id=3的总数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4、distinct排重\"><a href=\"#4-4、distinct排重\" class=\"headerlink\" title=\"4.4、distinct排重\"></a>4.4、distinct排重</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.<span class=\"function\"><span class=\"title\">find</span></span>()</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b2&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user0&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 0 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b3&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user1&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b4&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user2&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 2 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b5&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user3&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b6&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user4&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b7&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user5&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> db.user.distinct(<span class=\"string\">&quot;age&quot;</span>) <span class=\"comment\">## 特殊,传入的参数直接是字符串,而不是对象;</span></span><br><span class=\"line\">     [0, 1, 2]</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-5、子文档查询-elemMatch\"><a href=\"#4-5、子文档查询-elemMatch\" class=\"headerlink\" title=\"4.5、子文档查询$elemMatch\"></a>4.5、子文档查询$elemMatch</h4><p>elemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。<br>注意：<br>(1)数组中元素是内嵌文档。<br>(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。<br>假设集合school有如下数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 1,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;john&quot;</span>, school: 102, age: 10 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;jess&quot;</span>, school: 102, age: 11 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;jeff&quot;</span>, school: 108, age: 15 &#125;</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 2,</span><br><span class=\"line\"> zipcode: 63110,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;ajax&quot;</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;achilles&quot;</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 3,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;ajax&quot;</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;achilles&quot;</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 4,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;barney&quot;</span>, school: 102, age: 7 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102 &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;_id&quot;</span>: 1, <span class=\"string\">&quot;students&quot;</span>: [&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;john&quot;</span>, <span class=\"string\">&quot;school&quot;</span>:102, <span class=\"string\">&quot;age&quot;</span>:10&#125;]&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;_id&quot;</span>: 3&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;_id&quot;</span>: 4, <span class=\"string\">&quot;students&quot;</span>: [&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;barney&quot;</span>, <span class=\"string\">&quot;school&quot;</span>:102, <span class=\"string\">&quot;age&quot;</span>:7&#125;]&#125;</span><br></pre></td></tr></table></figure>\n<p>查询结果说明：<br><code>_id为1的文档</code>，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。<br><code>_id为3的文档</code>，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。</p>\n<p>$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102, age: &#123; <span class=\"variable\">$gt</span>: 10&#125; &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;<span class=\"string\">&quot;_id&quot;</span>: 1, <span class=\"string\">&quot;students&quot;</span>: [&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;jess&quot;</span>, <span class=\"string\">&quot;school&quot;</span>:102, <span class=\"string\">&quot;age&quot;</span>:11&#125;]&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">&quot;_id&quot;</span>: 3&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">&quot;_id&quot;</span>: 4&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h2 id=\"part1-安装配置\"><a href=\"#part1-安装配置\" class=\"headerlink\" title=\"part1 安装配置\"></a>part1 安装配置</h2><h3 id=\"一、安装：\"><a href=\"#一、安装：\" class=\"headerlink\" title=\"一、安装：\"></a>一、安装：</h3><p>在mongodb官网下载对应自己电脑系统的安装包，地址为： <a href=\"http://www.mongodb.org/downloads\">http://www.mongodb.org/downloads</a>。</p>","more":"<p>1、以Windows64bit为例，下载.msi文件双击安装。<br>2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\\MongoDB\\bin)。<br>3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。<br>4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod –dbpath D:\\MongoDB\\data\\db)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\"><span class=\"built_in\">cd</span> D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --dbpath D:\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure>\n<p>5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoDB shell version: 3.2.4  //mongodb版本</span><br><span class=\"line\">connecting to: <span class=\"built_in\">test</span>  //默认shell连接的是本机localhost 上面的<span class=\"built_in\">test</span>库</span><br></pre></td></tr></table></figure>\n<p>此时就可以操作数据库了。</p>\n<h3 id=\"二、将MongoDB服务器作为Windows服务运行\"><a href=\"#二、将MongoDB服务器作为Windows服务运行\" class=\"headerlink\" title=\"二、将MongoDB服务器作为Windows服务运行\"></a>二、将MongoDB服务器作为Windows服务运行</h3><p>1、在D:\\MongoDB目录下创建mongodb.config,写入如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 数据库文件目录</span></span><br><span class=\"line\">dbpath=D:/MongoDB/data</span><br><span class=\"line\"><span class=\"comment\">## 日志目录</span></span><br><span class=\"line\">logpath=D:/MongoDB/<span class=\"built_in\">log</span>/mongo.log</span><br><span class=\"line\">diaglog=3</span><br></pre></td></tr></table></figure>\n<p>2、常规命令(cmd管理员):</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --config D:\\MongoDB\\mongodb.config </span><br></pre></td></tr></table></figure>\n<p>3、若常规方式失败，则sc方式(cmd管理员)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">sc create mongodb binPath= &quot;D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config&quot; </span><br></pre></td></tr></table></figure>\n<p>访问地址：localhost:27017测试是否启动成功</p>\n<h2 id=\"part2-CRUD操作-Creat-Read-Update-Delete\"><a href=\"#part2-CRUD操作-Creat-Read-Update-Delete\" class=\"headerlink\" title=\"part2 CRUD操作(Creat,Read,Update,Delete)\"></a>part2 CRUD操作(Creat,Read,Update,Delete)</h2><h3 id=\"一、基础：\"><a href=\"#一、基础：\" class=\"headerlink\" title=\"一、基础：\"></a>一、基础：</h3><p>1、document(文档)</p>\n<p>MongoDB把所有数据存放在类似于JSON数据结构的文档内：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">&quot;item&quot;</span>: <span class=\"string\">&quot;pencil&quot;</span>, <span class=\"attr\">&quot;qty&quot;</span>: <span class=\"number\">500</span>, <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.2&quot;</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、collection(集合)</p>\n<p>集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">&quot;item&quot;</span>: <span class=\"string\">&quot;pencil&quot;</span>, <span class=\"attr\">&quot;qty&quot;</span>: <span class=\"number\">500</span>, <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.1&quot;</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">&quot;item&quot;</span>: <span class=\"string\">&quot;pencil2&quot;</span>, <span class=\"attr\">&quot;qty&quot;</span>: <span class=\"number\">550</span>, <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.2&quot;</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">&quot;item&quot;</span>: <span class=\"string\">&quot;pencil3&quot;</span>, <span class=\"attr\">&quot;qty&quot;</span>: <span class=\"number\">800</span>, <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.3&quot;</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、database(数据库)</p>\n<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。</p>\n<h3 id=\"二、数据库操作：\"><a href=\"#二、数据库操作：\" class=\"headerlink\" title=\"二、数据库操作：\"></a>二、数据库操作：</h3><p>连接及运行mongoDB<br>“<code>show dbs</code>“命令可以显示所有的数据的列表<br>“<code>db</code>“命令可以显示当前数据库对象或集合<br>“<code>use</code>“命令可以连接到一个指定的数据库<br>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。<br>  1.不能是空字符串（””)。<br>  2.不得含有’ ‘（空格)、.、$、/、\\和\\0 (空宇符)。<br>  3.应全部小写。<br>  4.最多64字节。</p>\n<p>1、创建数据库：<code>use Database_Name</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use <span class=\"built_in\">test</span>  <span class=\"comment\">##创建名为test的数据库</span></span><br></pre></td></tr></table></figure>\n<p>2、删除当前数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.dropDatabase()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、文档操作（以-Collection-Name-col-为例）\"><a href=\"#三、文档操作（以-Collection-Name-col-为例）\" class=\"headerlink\" title=\"三、文档操作（以 Collection_Name = col 为例）\"></a>三、文档操作（以 Collection_Name = col 为例）</h3><h4 id=\"1、插入：\"><a href=\"#1、插入：\" class=\"headerlink\" title=\"1、插入：\"></a>1、插入：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.insert(Document)     <span class=\"comment\">##插入一条或多组数据</span></span><br><span class=\"line\">db.col.insertOne(Document)  <span class=\"comment\">##插入一条数据</span></span><br><span class=\"line\">db.col.insertMany(Document) <span class=\"comment\">##插入多条数据</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.insertOne(&#123; <span class=\"string\">&quot;item&quot;</span>: <span class=\"string\">&quot;pencil&quot;</span>, <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.1&quot;</span> &#125;)</span><br><span class=\"line\">    db.col.insertMany([</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;item&quot;</span>: <span class=\"string\">&quot;dog&quot;</span>, <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.2&quot;</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;item&quot;</span>: <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.3&quot;</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;item&quot;</span>: <span class=\"string\">&quot;orange&quot;</span>, <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.4&quot;</span> &#125;</span><br><span class=\"line\">    ])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、删除：\"><a href=\"#2、删除：\" class=\"headerlink\" title=\"2、删除：\"></a>2、删除：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.remove(&#123;&#125;)                    <span class=\"comment\">##删除所有数据</span></span><br><span class=\"line\">db.col.remove(query &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query: 查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  ptions:两个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;justOne: &lt;boolean&gt;,     //默认false，删除所有匹配到的。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\">db.col.deleteOne(query &lt;,options&gt;)   <span class=\"comment\">##同上，无justOne参数，只删除第一条</span></span><br><span class=\"line\">db.col.deleteMany(query &lt;,options&gt;)  <span class=\"comment\">##同上，无justOne参数，只删除多条</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、更新：\"><a href=\"#3、更新：\" class=\"headerlink\" title=\"3、更新：\"></a>3、更新：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.update(query, update &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query:  查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  update: 更新的内容，语法：&#123;$set:query&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#  options:三个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;upsert: &lt;boolean&gt;,      //如果不存在update的记录，是否插入新数据，默认:false。</span></span><br><span class=\"line\">    <span class=\"comment\">#       multi: &lt;boolean&gt;,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//#抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.update(</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;no.1&quot;</span>&#125;, </span><br><span class=\"line\">        &#123;<span class=\"variable\">$set</span>: &#123;<span class=\"string\">&quot;item&quot;</span>: <span class=\"string\">&quot;human&quot;</span>&#125;&#125;, </span><br><span class=\"line\">        &#123;upsert: <span class=\"literal\">true</span>, multi: <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">db.col.updateOne()                    <span class=\"comment\">##同上，无multi参数，只更新第一条</span></span><br><span class=\"line\">db.col.updateMany()                   <span class=\"comment\">##同上，无multi参数</span></span><br><span class=\"line\">db.col.replaceOne()                   <span class=\"comment\">##同updateOne</span></span><br><span class=\"line\">db.col.save(document &lt;,writeConcern&gt;) <span class=\"comment\">##通过传入的文档整个替换</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"insert-与-save的区别\"><a href=\"#insert-与-save的区别\" class=\"headerlink\" title=\"insert 与 save的区别\"></a>insert 与 save的区别</h5><p>如果插入的数据的_id相同,save将会更新该文档,而insert将会报错</p>\n<h5 id=\"update常用操作符\"><a href=\"#update常用操作符\" class=\"headerlink\" title=\"update常用操作符\"></a>update常用操作符</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$set</span>         <span class=\"comment\">##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$unset</span>       <span class=\"comment\">##删除文档中的一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$rename</span>      <span class=\"comment\">##重命名某个列</span></span><br><span class=\"line\"><span class=\"variable\">$inc</span>         <span class=\"comment\">##增长某个列</span></span><br><span class=\"line\"><span class=\"variable\">$setOnInsert</span> <span class=\"comment\">##当upsert为true时,并且发生了insert操作时,可以补充的字段</span></span><br><span class=\"line\"><span class=\"variable\">$push</span>        <span class=\"comment\">##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.</span></span><br><span class=\"line\"><span class=\"variable\">$pushAll</span>     <span class=\"comment\">##将多个数值一次存入数组.上面的push只能一个一个的存入</span></span><br><span class=\"line\"><span class=\"variable\">$addToSet</span>    <span class=\"comment\">##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.</span></span><br><span class=\"line\"><span class=\"variable\">$pop</span>         <span class=\"comment\">##删除数组最后一个元素</span></span><br><span class=\"line\"><span class=\"variable\">$pull</span>        <span class=\"comment\">##删除数组中的指定的元素,如果删除的字段不是数组,会报错</span></span><br><span class=\"line\"><span class=\"variable\">$pullAll</span>     <span class=\"comment\">##删除数组中的多个值,跟pushAll与push的关系类似.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、查询\"><a href=\"#4、查询\" class=\"headerlink\" title=\"4、查询\"></a>4、查询</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(&#123;&#125;)          <span class=\"comment\">##查询所有文档</span></span><br><span class=\"line\">db.col.find().pretty()   <span class=\"comment\">##以易读的方式来读取数据</span></span><br><span class=\"line\">db.collection.find(query, projection)</span><br><span class=\"line\">    <span class=\"comment\">#  query：查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  projection：可选。指定返回的字段。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1、深入查询表达式\"><a href=\"#4-1、深入查询表达式\" class=\"headerlink\" title=\"4.1、深入查询表达式\"></a>4.1、深入查询表达式</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find()<span class=\"comment\">##查询所有</span></span><br><span class=\"line\">db.col.find(&#123;filed: value&#125;)                              <span class=\"comment\">##等值查询</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$ne</span>: value&#125;&#125;)                       <span class=\"comment\">##不等于 $ne</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$nin</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##不能包含给定的值 $nin</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$all</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##必须包含所有给定的值 $all</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$in</span>: [value1, value2, ...]&#125;&#125;)       <span class=\"comment\">##只要包含一个或多个给定的值 $in</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:1&#125;&#125;)                        <span class=\"comment\">##存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:0&#125;&#125;)                        <span class=\"comment\">##不存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$mod</span>:[3,1]&#125;&#125;)                       <span class=\"comment\">##模三余一，$mod(取模操作)</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$or</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) <span class=\"comment\">##或 $or</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$nor</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)<span class=\"comment\">##排除 $nor</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$size</span>: 3&#125;&#125;)                         <span class=\"comment\">##返回值得数组是给定的长度(3) $size</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;<span class=\"built_in\">return</span> ...&#125;&#125;)            <span class=\"comment\">##回调，隐式迭代，符合条件才返回</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"string\">&#x27;...&#x27;</span>&#125;&#125;)                            <span class=\"comment\">##同上</span></span><br><span class=\"line\">db.col.find(&#123;age: &#123;<span class=\"variable\">$lt</span>: 5&#125;&#125;).<span class=\"built_in\">limit</span>(3)                    <span class=\"comment\">##查询age的值小于5，限制3条</span></span><br><span class=\"line\">    <span class=\"comment\">#范围查询：</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lt  （小于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gt  （大于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lte （小于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gte （大于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    limit（限制显示）</span></span><br><span class=\"line\">db.col.find().skip(2).<span class=\"built_in\">limit</span>(3)                           <span class=\"comment\">##跳过前两个文档查询后面三个</span></span><br><span class=\"line\">    <span class=\"comment\">#  skip(num):表示跳过前面num个文档</span></span><br><span class=\"line\">db.col.find().sort(&#123;age: 1&#125;)                             <span class=\"comment\">##查询后以age升序排列显示</span></span><br><span class=\"line\">    <span class=\"comment\">#  sort():排序，这里 1 代表升序, -1 代表降序.</span></span><br><span class=\"line\">db.col.find(&#123;filed: /user.*/i&#125;)                          <span class=\"comment\">##正则，查询filed以user开头不区分大小写（正则效率低）</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$type</span>: 1&#125;&#125;)                         <span class=\"comment\">##查找filed为双精度的文档</span></span><br><span class=\"line\">    <span class=\"comment\"># 根据数据类型查询 $type</span></span><br><span class=\"line\">    <span class=\"comment\">#      |类型　　　　　　　　|编号|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |双精度　　　　　　　|1 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |字符串　　　　　　　|2 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象　　　　　　　　|3   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |数组　　　　　　　　|4   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |二进制数据　　　　　|5   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象ID　　　　　　　|7   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |布尔值　　　　　　　|8   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |日期　　　　　　　　|9   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |空　　　　　　　　　|10  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |正则表达式　　　　　|11  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript　　　　|13  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |符号　　　　　　　　|14  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript(带范围)|15  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |32位整数　　　　　　|16  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |时间戳　　　　　　　|17  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |64位整数　　　　　　|18  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最小键　　　　　　　|255 |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最大键　　　　　　　|127 |</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2、group分组查询\"><a href=\"#4-2、group分组查询\" class=\"headerlink\" title=\"4.2、group分组查询\"></a>4.2、group分组查询</h4><p>group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">group(&#123;</span><br><span class=\"line\">  key:&#123;字段:1&#125;,</span><br><span class=\"line\">  initial:&#123;变量:初始值&#125;,</span><br><span class=\"line\">  <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;函数代码&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>其中key下的字段代表,需要按哪个字段分组.<br>initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.<br>$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.</p>\n<p>栗子：如下我们按年龄分组,同级不同年龄的用户的多少:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.<span class=\"function\"><span class=\"title\">find</span></span>()</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b2&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user0&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 0 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b3&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user1&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b4&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user2&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 2 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b5&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user3&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b6&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user4&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b7&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user5&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;count:0&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">    [</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;age&quot;</span>: 0, <span class=\"string\">&quot;count&quot;</span>: 1&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;age&quot;</span>: 1, <span class=\"string\">&quot;count&quot;</span>: 3&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;age&quot;</span>: 2, <span class=\"string\">&quot;count&quot;</span>: 2&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    reduce:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  [</span><br><span class=\"line\">      &#123;<span class=\"string\">&quot;age&quot;</span>: 0, <span class=\"string\">&quot;users&quot;</span>: [<span class=\"string\">&quot;user0&quot;</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">&quot;age&quot;</span>: 1, <span class=\"string\">&quot;users&quot;</span>: [<span class=\"string\">&quot;user1&quot;</span>, <span class=\"string\">&quot;user3&quot;</span>, <span class=\"string\">&quot;user4&quot;</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">&quot;age&quot;</span>: 2, <span class=\"string\">&quot;users&quot;</span>: [<span class=\"string\">&quot;user2&quot;</span>, <span class=\"string\">&quot;user5&quot;</span>]&#125;</span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure>\n\n<p>另外本函数还有两个可选参数 condition 和 finalize<br>condition就是分组的条件筛选类似mysql中的having</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    condition:&#123;age:&#123;<span class=\"variable\">$gt</span>:0&#125;&#125;&#125;)</span><br><span class=\"line\">　<span class=\"comment\">##筛选出age大于0的:</span></span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;age&quot;</span>: 1, <span class=\"string\">&quot;users&quot;</span>: [<span class=\"string\">&quot;user1&quot;</span>, <span class=\"string\">&quot;user3&quot;</span>, <span class=\"string\">&quot;user4&quot;</span>]&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;age&quot;</span>: 2, <span class=\"string\">&quot;users&quot;</span>: [<span class=\"string\">&quot;user2&quot;</span>, <span class=\"string\">&quot;user5&quot;</span>]&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3、count统计\"><a href=\"#4-3、count统计\" class=\"headerlink\" title=\"4.3、count统计\"></a>4.3、count统计</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.goods.count()            <span class=\"comment\">##统计该集合总数</span></span><br><span class=\"line\">db.goods.count(&#123;cat_id: 3&#125;) <span class=\"comment\">##统计cat_id=3的总数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4、distinct排重\"><a href=\"#4-4、distinct排重\" class=\"headerlink\" title=\"4.4、distinct排重\"></a>4.4、distinct排重</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.<span class=\"function\"><span class=\"title\">find</span></span>()</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b2&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user0&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 0 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b3&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user1&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b4&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user2&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 2 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b5&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user3&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b6&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user4&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5198c286c686eb50e2c843b7&quot;</span>), <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;user5&quot;</span>, <span class=\"string\">&quot;age&quot;</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> db.user.distinct(<span class=\"string\">&quot;age&quot;</span>) <span class=\"comment\">## 特殊,传入的参数直接是字符串,而不是对象;</span></span><br><span class=\"line\">     [0, 1, 2]</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-5、子文档查询-elemMatch\"><a href=\"#4-5、子文档查询-elemMatch\" class=\"headerlink\" title=\"4.5、子文档查询$elemMatch\"></a>4.5、子文档查询$elemMatch</h4><p>elemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。<br>注意：<br>(1)数组中元素是内嵌文档。<br>(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。<br>假设集合school有如下数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 1,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;john&quot;</span>, school: 102, age: 10 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;jess&quot;</span>, school: 102, age: 11 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;jeff&quot;</span>, school: 108, age: 15 &#125;</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 2,</span><br><span class=\"line\"> zipcode: 63110,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;ajax&quot;</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;achilles&quot;</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 3,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;ajax&quot;</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;achilles&quot;</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 4,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">&quot;barney&quot;</span>, school: 102, age: 7 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102 &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;_id&quot;</span>: 1, <span class=\"string\">&quot;students&quot;</span>: [&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;john&quot;</span>, <span class=\"string\">&quot;school&quot;</span>:102, <span class=\"string\">&quot;age&quot;</span>:10&#125;]&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;_id&quot;</span>: 3&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;_id&quot;</span>: 4, <span class=\"string\">&quot;students&quot;</span>: [&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;barney&quot;</span>, <span class=\"string\">&quot;school&quot;</span>:102, <span class=\"string\">&quot;age&quot;</span>:7&#125;]&#125;</span><br></pre></td></tr></table></figure>\n<p>查询结果说明：<br><code>_id为1的文档</code>，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。<br><code>_id为3的文档</code>，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。</p>\n<p>$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102, age: &#123; <span class=\"variable\">$gt</span>: 10&#125; &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;<span class=\"string\">&quot;_id&quot;</span>: 1, <span class=\"string\">&quot;students&quot;</span>: [&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;jess&quot;</span>, <span class=\"string\">&quot;school&quot;</span>:102, <span class=\"string\">&quot;age&quot;</span>:11&#125;]&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">&quot;_id&quot;</span>: 3&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">&quot;_id&quot;</span>: 4&#125;</span><br></pre></td></tr></table></figure>"},{"title":"【数据库优化】MySQL索引的使用及优化","date":"2019-09-05T09:04:12.000Z","_content":"\n\n### 1. 索引的基本概念\n索引是为了加速对表中数据行的检索而创建的一种分散存储的**数据结构**。\n- 索引意义：\n    1. 索引能极大的减少存储引擎需要扫描的数据量\n    2. 索引可以把随机IO变成顺序IO\n    3. 索引可以帮助我们在进行分组、排序等操作时，避免使用临时表\n<!-- more -->\n- 增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，**过多的索引会不但会影响使用效率，同时会影响查询效率**，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引。\n\n### 2. 索引的适用场景\n#### 2.1 适合建索引的场景\n1. 表的主键自动建立唯一索引\n2. 表的字段唯一约束\n3. 直接条件查询的字段（在SQL中用于条件约束的字段）\n4. 查询中与其它表关联的字段\n5. 查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）\n6. 查询中统计或分组统计的字段\n7. 表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）\n8. 经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）\n9. 数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）\n10. 经常和主字段一块查询但主字段索引值比较多的表字段\n11. 对千万级MySQL数据库建立索引的事项及提高性能的手段\n\n\n#### 2.2 不适合建索引的场景\n1. 表记录太少（300万左右性能开始逐渐下降，虽然官方文档说撑得住5-8百万以上，但是根本也不能等到这个时候再去优化，性能肯定会受到影响）\n2. 经常增删改的表（why：提高了查询速度，同事却会降低了更新表的速度，入队表进行INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存下索引文件）。\n3. 数据重复切分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。注意，如果某个数据列包括许多重复的内容，为他建立索引就没有太大的实际效果了。（加入一个表有10万行的记录，有一个字段A只有True和False两个值，且每个值的分布概率大约为50%，那么对这种表的A字段建立索引一般不会提高数据库的查询速度。再比如对银行卡建立索引，毕竟银行卡没有重复的。索引的选择性是指索引列中不同值的数据与表中的记录数的比，如果一个表中有2000条记录，表索引列就有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。）\n\n### 3. MySQl中索引的结构（B+树）\n#### 3.1 基本概念：\n1. 二叉树：一个节点最多两个子节点，一个节点只存储一个关键字，等于则命中，小于走左节点，大于走右节点；\n2. B树：多路搜索树，每个节点存储M/2到M个关键字，所有关键字在整颗树中出现，且只出现一次，非叶子节点可以命中；\n3. B+树：在B树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现(有序)，叶子节点才命中；\n3. B*树：在B+树基础上，为非叶子节点也增加兄弟链表指针，将节点的最低利用率从1/2提高到2/3；\n\n#### 3.2 B+树的特性：\n1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；\n2. 不可能在非叶子结点命中；\n3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；\n4. 更适合文件索引系统；\n\n#### 3.3 B+树的三个特点：\n1. 关键字数和子树相同\n    + 在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。\n2. 非叶子节点仅用作索引，它的关键字和子节点有重复元素\n    + 除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。\n    + 根节点的最大关键字其实就表示整个 B+ 树的最大元素。\n3. 叶子节点用指针连在一起\n    + 叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。\n\n> 由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。\n> B+ 树的查找必会查到叶子节点，更加稳定。\n> 有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。\n\n#### 3.4 B+ 树的三个优点：\n+ 层级更低，IO 次数更少\n+ 每次都需要查询到叶子节点，查询性能稳定\n+ 叶子节点形成有序链表，范围查询方便\n\n### 4. 索引的优化\n#### 4.1 优化法则（口诀）：\n+ 全值匹配我最爱，最左前缀要遵守\n+ 带头大哥不能死，中间兄弟不能断\n+ 索引列上无计算，范围之后全失效\n+ like百分写最右，覆盖索引不写星\n+ 不等控制还有or，索引失效要少用\n+ var引号不能丢，SQL优化也不难\n\n#### 4.2 具体描述\n1. 全值匹配\n    + 怎么建索引就怎么用索引，where后面的条件越来越多精度越来越高，精度越来越高带来的就是长度和花费的代价也就越来越多\n2. 最佳左前缀法则\n    + 指的是查询从索引的最左前列开始并且不跳过索引中的列。\n    + 例如：复合索引`A->B->C`，如果把开头A去掉的话，B，C也就都失效了（带头大哥不能死）；如果把中间B去掉的话，则只会走索引A，而C就失效了（中间兄弟不能断）。\n3. 不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描\n4. 存储引擎不能使用索引中范围条件右面的列\n    + 例如：`select t from test where A=1 and B>2 and C=3`，那么B>2后的查询条件失效。\n5. 尽量使用覆盖索引————只访问索引的查询（索引列和查询列一致），减少 `SELECT *`。\n6. MySQL在使用不等于(`!=` 或`<>`)的时候无法使用索引会导致全表扫描\n7. `is null`，`is not null` 也无法使用索引\n8. like以通配符开头`('%abc...')`mysql索引失效回变成全表扫描的操作（使用覆盖索引可解决），只有通配符在右面`('abc...%')`的才能避免索引失效。\n9. 字符串不加单引号索引失效\n10. 少用or，用它来连接时会索引失效\n\n\n### 5. in 和 exists区别及应用场景\n#### 5.1 in 和 exists的区别: \n+ 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。\n+ 其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。\n+ in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。\n\n#### 5.2 not in 和not exists\n+ 如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；\n+ 而not extsts 的子查询依然能用到表上的索引。\n+ 所以无论那个表大，用not exists都比not in要快\n\n\n### 6. order by 和 group by 优化\n索引的主要作用就是查找和排序，ORDER BY 子句尽量使用Index方式排序，能避免使用FileSort方式排序，尽可能在索引列上外城排序操作，遵照索引键的最佳左前缀。\n\n#### 6.1 提高ORDER BY速度的技巧\n1. ORDER BY时不要使用SELECT *，只查需要的字段。\n2. 增大`sort_buffer_size`参数大小（根据系统能力去提高，因为这个参数是针对每个进程的）\n3. 增大`max_length_for_sort_data`参数大小\n\n#### 6.2 GROUP BY的优化\n1. GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。\n2. 当无法使用索引列，考虑增大`max_length_for_sort_data`和`sort_buffer_size`的参数设置。\n3. WHERE 高于 HAVING，能写在WHERE解决的条件就不要去HAVING限定了。\n\n> 注意：group by 表面上叫分组，但是分组之前比排序。所以说group by和order by两者排序的法则和索引优化的原则几乎是一致的。当然也有不一样的地方，group by 还有having的存在。如果group by错乱，会导致临时表的产生。(就是说group by的顺序不对，建好的索引我用不上，我内部使用了内排序产生了filesort，为了把这些数据挪出来内部建了一张临时表来进行分组)\n\n一般性建议：\n+ 对于单值索引，尽量选择针对query过滤性更好的索引\n+ 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段的顺序中，位置越靠左越好。\n+ 在选择组合索引的时候，尽量选择可能包含当前query中的where子句中更多字段的索引\n+ 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。\n\n\n\n> 参考链接：[https://www.zhihu.com/people/hen-six-49/activities](https://www.zhihu.com/people/hen-six-49/activities)","source":"_posts/【数据库优化】MySQL索引的使用及优化.md","raw":"---\ntitle: 【数据库优化】MySQL索引的使用及优化\ndate: 2019-09-05 17:04:12\ntags: [数据库, 后端开发]\ncategories: 数据库\n---\n\n\n### 1. 索引的基本概念\n索引是为了加速对表中数据行的检索而创建的一种分散存储的**数据结构**。\n- 索引意义：\n    1. 索引能极大的减少存储引擎需要扫描的数据量\n    2. 索引可以把随机IO变成顺序IO\n    3. 索引可以帮助我们在进行分组、排序等操作时，避免使用临时表\n<!-- more -->\n- 增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，**过多的索引会不但会影响使用效率，同时会影响查询效率**，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引。\n\n### 2. 索引的适用场景\n#### 2.1 适合建索引的场景\n1. 表的主键自动建立唯一索引\n2. 表的字段唯一约束\n3. 直接条件查询的字段（在SQL中用于条件约束的字段）\n4. 查询中与其它表关联的字段\n5. 查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）\n6. 查询中统计或分组统计的字段\n7. 表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）\n8. 经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）\n9. 数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）\n10. 经常和主字段一块查询但主字段索引值比较多的表字段\n11. 对千万级MySQL数据库建立索引的事项及提高性能的手段\n\n\n#### 2.2 不适合建索引的场景\n1. 表记录太少（300万左右性能开始逐渐下降，虽然官方文档说撑得住5-8百万以上，但是根本也不能等到这个时候再去优化，性能肯定会受到影响）\n2. 经常增删改的表（why：提高了查询速度，同事却会降低了更新表的速度，入队表进行INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存下索引文件）。\n3. 数据重复切分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。注意，如果某个数据列包括许多重复的内容，为他建立索引就没有太大的实际效果了。（加入一个表有10万行的记录，有一个字段A只有True和False两个值，且每个值的分布概率大约为50%，那么对这种表的A字段建立索引一般不会提高数据库的查询速度。再比如对银行卡建立索引，毕竟银行卡没有重复的。索引的选择性是指索引列中不同值的数据与表中的记录数的比，如果一个表中有2000条记录，表索引列就有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。）\n\n### 3. MySQl中索引的结构（B+树）\n#### 3.1 基本概念：\n1. 二叉树：一个节点最多两个子节点，一个节点只存储一个关键字，等于则命中，小于走左节点，大于走右节点；\n2. B树：多路搜索树，每个节点存储M/2到M个关键字，所有关键字在整颗树中出现，且只出现一次，非叶子节点可以命中；\n3. B+树：在B树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现(有序)，叶子节点才命中；\n3. B*树：在B+树基础上，为非叶子节点也增加兄弟链表指针，将节点的最低利用率从1/2提高到2/3；\n\n#### 3.2 B+树的特性：\n1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；\n2. 不可能在非叶子结点命中；\n3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；\n4. 更适合文件索引系统；\n\n#### 3.3 B+树的三个特点：\n1. 关键字数和子树相同\n    + 在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。\n2. 非叶子节点仅用作索引，它的关键字和子节点有重复元素\n    + 除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。\n    + 根节点的最大关键字其实就表示整个 B+ 树的最大元素。\n3. 叶子节点用指针连在一起\n    + 叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。\n\n> 由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。\n> B+ 树的查找必会查到叶子节点，更加稳定。\n> 有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。\n\n#### 3.4 B+ 树的三个优点：\n+ 层级更低，IO 次数更少\n+ 每次都需要查询到叶子节点，查询性能稳定\n+ 叶子节点形成有序链表，范围查询方便\n\n### 4. 索引的优化\n#### 4.1 优化法则（口诀）：\n+ 全值匹配我最爱，最左前缀要遵守\n+ 带头大哥不能死，中间兄弟不能断\n+ 索引列上无计算，范围之后全失效\n+ like百分写最右，覆盖索引不写星\n+ 不等控制还有or，索引失效要少用\n+ var引号不能丢，SQL优化也不难\n\n#### 4.2 具体描述\n1. 全值匹配\n    + 怎么建索引就怎么用索引，where后面的条件越来越多精度越来越高，精度越来越高带来的就是长度和花费的代价也就越来越多\n2. 最佳左前缀法则\n    + 指的是查询从索引的最左前列开始并且不跳过索引中的列。\n    + 例如：复合索引`A->B->C`，如果把开头A去掉的话，B，C也就都失效了（带头大哥不能死）；如果把中间B去掉的话，则只会走索引A，而C就失效了（中间兄弟不能断）。\n3. 不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描\n4. 存储引擎不能使用索引中范围条件右面的列\n    + 例如：`select t from test where A=1 and B>2 and C=3`，那么B>2后的查询条件失效。\n5. 尽量使用覆盖索引————只访问索引的查询（索引列和查询列一致），减少 `SELECT *`。\n6. MySQL在使用不等于(`!=` 或`<>`)的时候无法使用索引会导致全表扫描\n7. `is null`，`is not null` 也无法使用索引\n8. like以通配符开头`('%abc...')`mysql索引失效回变成全表扫描的操作（使用覆盖索引可解决），只有通配符在右面`('abc...%')`的才能避免索引失效。\n9. 字符串不加单引号索引失效\n10. 少用or，用它来连接时会索引失效\n\n\n### 5. in 和 exists区别及应用场景\n#### 5.1 in 和 exists的区别: \n+ 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。\n+ 其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。\n+ in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。\n\n#### 5.2 not in 和not exists\n+ 如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；\n+ 而not extsts 的子查询依然能用到表上的索引。\n+ 所以无论那个表大，用not exists都比not in要快\n\n\n### 6. order by 和 group by 优化\n索引的主要作用就是查找和排序，ORDER BY 子句尽量使用Index方式排序，能避免使用FileSort方式排序，尽可能在索引列上外城排序操作，遵照索引键的最佳左前缀。\n\n#### 6.1 提高ORDER BY速度的技巧\n1. ORDER BY时不要使用SELECT *，只查需要的字段。\n2. 增大`sort_buffer_size`参数大小（根据系统能力去提高，因为这个参数是针对每个进程的）\n3. 增大`max_length_for_sort_data`参数大小\n\n#### 6.2 GROUP BY的优化\n1. GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。\n2. 当无法使用索引列，考虑增大`max_length_for_sort_data`和`sort_buffer_size`的参数设置。\n3. WHERE 高于 HAVING，能写在WHERE解决的条件就不要去HAVING限定了。\n\n> 注意：group by 表面上叫分组，但是分组之前比排序。所以说group by和order by两者排序的法则和索引优化的原则几乎是一致的。当然也有不一样的地方，group by 还有having的存在。如果group by错乱，会导致临时表的产生。(就是说group by的顺序不对，建好的索引我用不上，我内部使用了内排序产生了filesort，为了把这些数据挪出来内部建了一张临时表来进行分组)\n\n一般性建议：\n+ 对于单值索引，尽量选择针对query过滤性更好的索引\n+ 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段的顺序中，位置越靠左越好。\n+ 在选择组合索引的时候，尽量选择可能包含当前query中的where子句中更多字段的索引\n+ 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。\n\n\n\n> 参考链接：[https://www.zhihu.com/people/hen-six-49/activities](https://www.zhihu.com/people/hen-six-49/activities)","slug":"【数据库优化】MySQL索引的使用及优化","published":1,"updated":"2021-12-12T02:50:23.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6v9000nvcuecnjbb7j6","content":"<h3 id=\"1-索引的基本概念\"><a href=\"#1-索引的基本概念\" class=\"headerlink\" title=\"1. 索引的基本概念\"></a>1. 索引的基本概念</h3><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p>\n<ul>\n<li>索引意义：<ol>\n<li>索引能极大的减少存储引擎需要扫描的数据量</li>\n<li>索引可以把随机IO变成顺序IO</li>\n<li>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表<span id=\"more\"></span></li>\n</ol>\n</li>\n<li>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引。</li>\n</ul>\n<h3 id=\"2-索引的适用场景\"><a href=\"#2-索引的适用场景\" class=\"headerlink\" title=\"2. 索引的适用场景\"></a>2. 索引的适用场景</h3><h4 id=\"2-1-适合建索引的场景\"><a href=\"#2-1-适合建索引的场景\" class=\"headerlink\" title=\"2.1 适合建索引的场景\"></a>2.1 适合建索引的场景</h4><ol>\n<li>表的主键自动建立唯一索引</li>\n<li>表的字段唯一约束</li>\n<li>直接条件查询的字段（在SQL中用于条件约束的字段）</li>\n<li>查询中与其它表关联的字段</li>\n<li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li>\n<li>查询中统计或分组统计的字段</li>\n<li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li>\n<li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li>\n<li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li>\n<li>经常和主字段一块查询但主字段索引值比较多的表字段</li>\n<li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li>\n</ol>\n<h4 id=\"2-2-不适合建索引的场景\"><a href=\"#2-2-不适合建索引的场景\" class=\"headerlink\" title=\"2.2 不适合建索引的场景\"></a>2.2 不适合建索引的场景</h4><ol>\n<li>表记录太少（300万左右性能开始逐渐下降，虽然官方文档说撑得住5-8百万以上，但是根本也不能等到这个时候再去优化，性能肯定会受到影响）</li>\n<li>经常增删改的表（why：提高了查询速度，同事却会降低了更新表的速度，入队表进行INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存下索引文件）。</li>\n<li>数据重复切分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。注意，如果某个数据列包括许多重复的内容，为他建立索引就没有太大的实际效果了。（加入一个表有10万行的记录，有一个字段A只有True和False两个值，且每个值的分布概率大约为50%，那么对这种表的A字段建立索引一般不会提高数据库的查询速度。再比如对银行卡建立索引，毕竟银行卡没有重复的。索引的选择性是指索引列中不同值的数据与表中的记录数的比，如果一个表中有2000条记录，表索引列就有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。）</li>\n</ol>\n<h3 id=\"3-MySQl中索引的结构（B-树）\"><a href=\"#3-MySQl中索引的结构（B-树）\" class=\"headerlink\" title=\"3. MySQl中索引的结构（B+树）\"></a>3. MySQl中索引的结构（B+树）</h3><h4 id=\"3-1-基本概念：\"><a href=\"#3-1-基本概念：\" class=\"headerlink\" title=\"3.1 基本概念：\"></a>3.1 基本概念：</h4><ol>\n<li>二叉树：一个节点最多两个子节点，一个节点只存储一个关键字，等于则命中，小于走左节点，大于走右节点；</li>\n<li>B树：多路搜索树，每个节点存储M/2到M个关键字，所有关键字在整颗树中出现，且只出现一次，非叶子节点可以命中；</li>\n<li>B+树：在B树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现(有序)，叶子节点才命中；</li>\n<li>B*树：在B+树基础上，为非叶子节点也增加兄弟链表指针，将节点的最低利用率从1/2提高到2/3；</li>\n</ol>\n<h4 id=\"3-2-B-树的特性：\"><a href=\"#3-2-B-树的特性：\" class=\"headerlink\" title=\"3.2 B+树的特性：\"></a>3.2 B+树的特性：</h4><ol>\n<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>\n<li>不可能在非叶子结点命中；</li>\n<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>\n<li>更适合文件索引系统；</li>\n</ol>\n<h4 id=\"3-3-B-树的三个特点：\"><a href=\"#3-3-B-树的三个特点：\" class=\"headerlink\" title=\"3.3 B+树的三个特点：\"></a>3.3 B+树的三个特点：</h4><ol>\n<li>关键字数和子树相同<ul>\n<li>在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。</li>\n</ul>\n</li>\n<li>非叶子节点仅用作索引，它的关键字和子节点有重复元素<ul>\n<li>除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。</li>\n<li>根节点的最大关键字其实就表示整个 B+ 树的最大元素。</li>\n</ul>\n</li>\n<li>叶子节点用指针连在一起<ul>\n<li>叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。<br>B+ 树的查找必会查到叶子节点，更加稳定。<br>有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。</p>\n</blockquote>\n<h4 id=\"3-4-B-树的三个优点：\"><a href=\"#3-4-B-树的三个优点：\" class=\"headerlink\" title=\"3.4 B+ 树的三个优点：\"></a>3.4 B+ 树的三个优点：</h4><ul>\n<li>层级更低，IO 次数更少</li>\n<li>每次都需要查询到叶子节点，查询性能稳定</li>\n<li>叶子节点形成有序链表，范围查询方便</li>\n</ul>\n<h3 id=\"4-索引的优化\"><a href=\"#4-索引的优化\" class=\"headerlink\" title=\"4. 索引的优化\"></a>4. 索引的优化</h3><h4 id=\"4-1-优化法则（口诀）：\"><a href=\"#4-1-优化法则（口诀）：\" class=\"headerlink\" title=\"4.1 优化法则（口诀）：\"></a>4.1 优化法则（口诀）：</h4><ul>\n<li>全值匹配我最爱，最左前缀要遵守</li>\n<li>带头大哥不能死，中间兄弟不能断</li>\n<li>索引列上无计算，范围之后全失效</li>\n<li>like百分写最右，覆盖索引不写星</li>\n<li>不等控制还有or，索引失效要少用</li>\n<li>var引号不能丢，SQL优化也不难</li>\n</ul>\n<h4 id=\"4-2-具体描述\"><a href=\"#4-2-具体描述\" class=\"headerlink\" title=\"4.2 具体描述\"></a>4.2 具体描述</h4><ol>\n<li>全值匹配<ul>\n<li>怎么建索引就怎么用索引，where后面的条件越来越多精度越来越高，精度越来越高带来的就是长度和花费的代价也就越来越多</li>\n</ul>\n</li>\n<li>最佳左前缀法则<ul>\n<li>指的是查询从索引的最左前列开始并且不跳过索引中的列。</li>\n<li>例如：复合索引<code>A-&gt;B-&gt;C</code>，如果把开头A去掉的话，B，C也就都失效了（带头大哥不能死）；如果把中间B去掉的话，则只会走索引A，而C就失效了（中间兄弟不能断）。</li>\n</ul>\n</li>\n<li>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</li>\n<li>存储引擎不能使用索引中范围条件右面的列<ul>\n<li>例如：<code>select t from test where A=1 and B&gt;2 and C=3</code>，那么B&gt;2后的查询条件失效。</li>\n</ul>\n</li>\n<li>尽量使用覆盖索引————只访问索引的查询（索引列和查询列一致），减少 <code>SELECT *</code>。</li>\n<li>MySQL在使用不等于(<code>!=</code> 或<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描</li>\n<li><code>is null</code>，<code>is not null</code> 也无法使用索引</li>\n<li>like以通配符开头<code>(&#39;%abc...&#39;)</code>mysql索引失效回变成全表扫描的操作（使用覆盖索引可解决），只有通配符在右面<code>(&#39;abc...%&#39;)</code>的才能避免索引失效。</li>\n<li>字符串不加单引号索引失效</li>\n<li>少用or，用它来连接时会索引失效</li>\n</ol>\n<h3 id=\"5-in-和-exists区别及应用场景\"><a href=\"#5-in-和-exists区别及应用场景\" class=\"headerlink\" title=\"5. in 和 exists区别及应用场景\"></a>5. in 和 exists区别及应用场景</h3><h4 id=\"5-1-in-和-exists的区别\"><a href=\"#5-1-in-和-exists的区别\" class=\"headerlink\" title=\"5.1 in 和 exists的区别:\"></a>5.1 in 和 exists的区别:</h4><ul>\n<li>如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。</li>\n<li>其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。</li>\n<li>in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。</li>\n</ul>\n<h4 id=\"5-2-not-in-和not-exists\"><a href=\"#5-2-not-in-和not-exists\" class=\"headerlink\" title=\"5.2 not in 和not exists\"></a>5.2 not in 和not exists</h4><ul>\n<li>如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；</li>\n<li>而not extsts 的子查询依然能用到表上的索引。</li>\n<li>所以无论那个表大，用not exists都比not in要快</li>\n</ul>\n<h3 id=\"6-order-by-和-group-by-优化\"><a href=\"#6-order-by-和-group-by-优化\" class=\"headerlink\" title=\"6. order by 和 group by 优化\"></a>6. order by 和 group by 优化</h3><p>索引的主要作用就是查找和排序，ORDER BY 子句尽量使用Index方式排序，能避免使用FileSort方式排序，尽可能在索引列上外城排序操作，遵照索引键的最佳左前缀。</p>\n<h4 id=\"6-1-提高ORDER-BY速度的技巧\"><a href=\"#6-1-提高ORDER-BY速度的技巧\" class=\"headerlink\" title=\"6.1 提高ORDER BY速度的技巧\"></a>6.1 提高ORDER BY速度的技巧</h4><ol>\n<li>ORDER BY时不要使用SELECT *，只查需要的字段。</li>\n<li>增大<code>sort_buffer_size</code>参数大小（根据系统能力去提高，因为这个参数是针对每个进程的）</li>\n<li>增大<code>max_length_for_sort_data</code>参数大小</li>\n</ol>\n<h4 id=\"6-2-GROUP-BY的优化\"><a href=\"#6-2-GROUP-BY的优化\" class=\"headerlink\" title=\"6.2 GROUP BY的优化\"></a>6.2 GROUP BY的优化</h4><ol>\n<li>GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。</li>\n<li>当无法使用索引列，考虑增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>的参数设置。</li>\n<li>WHERE 高于 HAVING，能写在WHERE解决的条件就不要去HAVING限定了。</li>\n</ol>\n<blockquote>\n<p>注意：group by 表面上叫分组，但是分组之前比排序。所以说group by和order by两者排序的法则和索引优化的原则几乎是一致的。当然也有不一样的地方，group by 还有having的存在。如果group by错乱，会导致临时表的产生。(就是说group by的顺序不对，建好的索引我用不上，我内部使用了内排序产生了filesort，为了把这些数据挪出来内部建了一张临时表来进行分组)</p>\n</blockquote>\n<p>一般性建议：</p>\n<ul>\n<li>对于单值索引，尽量选择针对query过滤性更好的索引</li>\n<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段的顺序中，位置越靠左越好。</li>\n<li>在选择组合索引的时候，尽量选择可能包含当前query中的where子句中更多字段的索引</li>\n<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</li>\n</ul>\n<blockquote>\n<p>参考链接：<a href=\"https://www.zhihu.com/people/hen-six-49/activities\">https://www.zhihu.com/people/hen-six-49/activities</a></p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h3 id=\"1-索引的基本概念\"><a href=\"#1-索引的基本概念\" class=\"headerlink\" title=\"1. 索引的基本概念\"></a>1. 索引的基本概念</h3><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p>\n<ul>\n<li>索引意义：<ol>\n<li>索引能极大的减少存储引擎需要扫描的数据量</li>\n<li>索引可以把随机IO变成顺序IO</li>\n<li>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表","more":"</li>\n</ol>\n</li>\n<li>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引。</li>\n</ul>\n<h3 id=\"2-索引的适用场景\"><a href=\"#2-索引的适用场景\" class=\"headerlink\" title=\"2. 索引的适用场景\"></a>2. 索引的适用场景</h3><h4 id=\"2-1-适合建索引的场景\"><a href=\"#2-1-适合建索引的场景\" class=\"headerlink\" title=\"2.1 适合建索引的场景\"></a>2.1 适合建索引的场景</h4><ol>\n<li>表的主键自动建立唯一索引</li>\n<li>表的字段唯一约束</li>\n<li>直接条件查询的字段（在SQL中用于条件约束的字段）</li>\n<li>查询中与其它表关联的字段</li>\n<li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li>\n<li>查询中统计或分组统计的字段</li>\n<li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li>\n<li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li>\n<li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li>\n<li>经常和主字段一块查询但主字段索引值比较多的表字段</li>\n<li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li>\n</ol>\n<h4 id=\"2-2-不适合建索引的场景\"><a href=\"#2-2-不适合建索引的场景\" class=\"headerlink\" title=\"2.2 不适合建索引的场景\"></a>2.2 不适合建索引的场景</h4><ol>\n<li>表记录太少（300万左右性能开始逐渐下降，虽然官方文档说撑得住5-8百万以上，但是根本也不能等到这个时候再去优化，性能肯定会受到影响）</li>\n<li>经常增删改的表（why：提高了查询速度，同事却会降低了更新表的速度，入队表进行INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存下索引文件）。</li>\n<li>数据重复切分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。注意，如果某个数据列包括许多重复的内容，为他建立索引就没有太大的实际效果了。（加入一个表有10万行的记录，有一个字段A只有True和False两个值，且每个值的分布概率大约为50%，那么对这种表的A字段建立索引一般不会提高数据库的查询速度。再比如对银行卡建立索引，毕竟银行卡没有重复的。索引的选择性是指索引列中不同值的数据与表中的记录数的比，如果一个表中有2000条记录，表索引列就有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。）</li>\n</ol>\n<h3 id=\"3-MySQl中索引的结构（B-树）\"><a href=\"#3-MySQl中索引的结构（B-树）\" class=\"headerlink\" title=\"3. MySQl中索引的结构（B+树）\"></a>3. MySQl中索引的结构（B+树）</h3><h4 id=\"3-1-基本概念：\"><a href=\"#3-1-基本概念：\" class=\"headerlink\" title=\"3.1 基本概念：\"></a>3.1 基本概念：</h4><ol>\n<li>二叉树：一个节点最多两个子节点，一个节点只存储一个关键字，等于则命中，小于走左节点，大于走右节点；</li>\n<li>B树：多路搜索树，每个节点存储M/2到M个关键字，所有关键字在整颗树中出现，且只出现一次，非叶子节点可以命中；</li>\n<li>B+树：在B树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现(有序)，叶子节点才命中；</li>\n<li>B*树：在B+树基础上，为非叶子节点也增加兄弟链表指针，将节点的最低利用率从1/2提高到2/3；</li>\n</ol>\n<h4 id=\"3-2-B-树的特性：\"><a href=\"#3-2-B-树的特性：\" class=\"headerlink\" title=\"3.2 B+树的特性：\"></a>3.2 B+树的特性：</h4><ol>\n<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>\n<li>不可能在非叶子结点命中；</li>\n<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>\n<li>更适合文件索引系统；</li>\n</ol>\n<h4 id=\"3-3-B-树的三个特点：\"><a href=\"#3-3-B-树的三个特点：\" class=\"headerlink\" title=\"3.3 B+树的三个特点：\"></a>3.3 B+树的三个特点：</h4><ol>\n<li>关键字数和子树相同<ul>\n<li>在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。</li>\n</ul>\n</li>\n<li>非叶子节点仅用作索引，它的关键字和子节点有重复元素<ul>\n<li>除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。</li>\n<li>根节点的最大关键字其实就表示整个 B+ 树的最大元素。</li>\n</ul>\n</li>\n<li>叶子节点用指针连在一起<ul>\n<li>叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。<br>B+ 树的查找必会查到叶子节点，更加稳定。<br>有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。</p>\n</blockquote>\n<h4 id=\"3-4-B-树的三个优点：\"><a href=\"#3-4-B-树的三个优点：\" class=\"headerlink\" title=\"3.4 B+ 树的三个优点：\"></a>3.4 B+ 树的三个优点：</h4><ul>\n<li>层级更低，IO 次数更少</li>\n<li>每次都需要查询到叶子节点，查询性能稳定</li>\n<li>叶子节点形成有序链表，范围查询方便</li>\n</ul>\n<h3 id=\"4-索引的优化\"><a href=\"#4-索引的优化\" class=\"headerlink\" title=\"4. 索引的优化\"></a>4. 索引的优化</h3><h4 id=\"4-1-优化法则（口诀）：\"><a href=\"#4-1-优化法则（口诀）：\" class=\"headerlink\" title=\"4.1 优化法则（口诀）：\"></a>4.1 优化法则（口诀）：</h4><ul>\n<li>全值匹配我最爱，最左前缀要遵守</li>\n<li>带头大哥不能死，中间兄弟不能断</li>\n<li>索引列上无计算，范围之后全失效</li>\n<li>like百分写最右，覆盖索引不写星</li>\n<li>不等控制还有or，索引失效要少用</li>\n<li>var引号不能丢，SQL优化也不难</li>\n</ul>\n<h4 id=\"4-2-具体描述\"><a href=\"#4-2-具体描述\" class=\"headerlink\" title=\"4.2 具体描述\"></a>4.2 具体描述</h4><ol>\n<li>全值匹配<ul>\n<li>怎么建索引就怎么用索引，where后面的条件越来越多精度越来越高，精度越来越高带来的就是长度和花费的代价也就越来越多</li>\n</ul>\n</li>\n<li>最佳左前缀法则<ul>\n<li>指的是查询从索引的最左前列开始并且不跳过索引中的列。</li>\n<li>例如：复合索引<code>A-&gt;B-&gt;C</code>，如果把开头A去掉的话，B，C也就都失效了（带头大哥不能死）；如果把中间B去掉的话，则只会走索引A，而C就失效了（中间兄弟不能断）。</li>\n</ul>\n</li>\n<li>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</li>\n<li>存储引擎不能使用索引中范围条件右面的列<ul>\n<li>例如：<code>select t from test where A=1 and B&gt;2 and C=3</code>，那么B&gt;2后的查询条件失效。</li>\n</ul>\n</li>\n<li>尽量使用覆盖索引————只访问索引的查询（索引列和查询列一致），减少 <code>SELECT *</code>。</li>\n<li>MySQL在使用不等于(<code>!=</code> 或<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描</li>\n<li><code>is null</code>，<code>is not null</code> 也无法使用索引</li>\n<li>like以通配符开头<code>(&#39;%abc...&#39;)</code>mysql索引失效回变成全表扫描的操作（使用覆盖索引可解决），只有通配符在右面<code>(&#39;abc...%&#39;)</code>的才能避免索引失效。</li>\n<li>字符串不加单引号索引失效</li>\n<li>少用or，用它来连接时会索引失效</li>\n</ol>\n<h3 id=\"5-in-和-exists区别及应用场景\"><a href=\"#5-in-和-exists区别及应用场景\" class=\"headerlink\" title=\"5. in 和 exists区别及应用场景\"></a>5. in 和 exists区别及应用场景</h3><h4 id=\"5-1-in-和-exists的区别\"><a href=\"#5-1-in-和-exists的区别\" class=\"headerlink\" title=\"5.1 in 和 exists的区别:\"></a>5.1 in 和 exists的区别:</h4><ul>\n<li>如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。</li>\n<li>其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。</li>\n<li>in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。</li>\n</ul>\n<h4 id=\"5-2-not-in-和not-exists\"><a href=\"#5-2-not-in-和not-exists\" class=\"headerlink\" title=\"5.2 not in 和not exists\"></a>5.2 not in 和not exists</h4><ul>\n<li>如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；</li>\n<li>而not extsts 的子查询依然能用到表上的索引。</li>\n<li>所以无论那个表大，用not exists都比not in要快</li>\n</ul>\n<h3 id=\"6-order-by-和-group-by-优化\"><a href=\"#6-order-by-和-group-by-优化\" class=\"headerlink\" title=\"6. order by 和 group by 优化\"></a>6. order by 和 group by 优化</h3><p>索引的主要作用就是查找和排序，ORDER BY 子句尽量使用Index方式排序，能避免使用FileSort方式排序，尽可能在索引列上外城排序操作，遵照索引键的最佳左前缀。</p>\n<h4 id=\"6-1-提高ORDER-BY速度的技巧\"><a href=\"#6-1-提高ORDER-BY速度的技巧\" class=\"headerlink\" title=\"6.1 提高ORDER BY速度的技巧\"></a>6.1 提高ORDER BY速度的技巧</h4><ol>\n<li>ORDER BY时不要使用SELECT *，只查需要的字段。</li>\n<li>增大<code>sort_buffer_size</code>参数大小（根据系统能力去提高，因为这个参数是针对每个进程的）</li>\n<li>增大<code>max_length_for_sort_data</code>参数大小</li>\n</ol>\n<h4 id=\"6-2-GROUP-BY的优化\"><a href=\"#6-2-GROUP-BY的优化\" class=\"headerlink\" title=\"6.2 GROUP BY的优化\"></a>6.2 GROUP BY的优化</h4><ol>\n<li>GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。</li>\n<li>当无法使用索引列，考虑增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>的参数设置。</li>\n<li>WHERE 高于 HAVING，能写在WHERE解决的条件就不要去HAVING限定了。</li>\n</ol>\n<blockquote>\n<p>注意：group by 表面上叫分组，但是分组之前比排序。所以说group by和order by两者排序的法则和索引优化的原则几乎是一致的。当然也有不一样的地方，group by 还有having的存在。如果group by错乱，会导致临时表的产生。(就是说group by的顺序不对，建好的索引我用不上，我内部使用了内排序产生了filesort，为了把这些数据挪出来内部建了一张临时表来进行分组)</p>\n</blockquote>\n<p>一般性建议：</p>\n<ul>\n<li>对于单值索引，尽量选择针对query过滤性更好的索引</li>\n<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段的顺序中，位置越靠左越好。</li>\n<li>在选择组合索引的时候，尽量选择可能包含当前query中的where子句中更多字段的索引</li>\n<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</li>\n</ul>\n<blockquote>\n<p>参考链接：<a href=\"https://www.zhihu.com/people/hen-six-49/activities\">https://www.zhihu.com/people/hen-six-49/activities</a></p>\n</blockquote>"},{"title":"【杂谈】对开源的理解","date":"2019-04-11T12:13:15.000Z","_content":"\n### 什么是开源\n所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。\n\n在IT领域来说的话，字面意思就是**开放源代码**，开源软件的源代码任何人都可以审查、修改和增强。\n<!-- more -->\n虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。\n\n\n### 开源是否等于免费\n开源等于免费是对开源的最大误解。\n\n商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于**License**（许可协议）。\n\n商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。\n\n开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的**约束和保护**。\n\n目前使用最广泛的一种开源协议便是**MIT License**，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。\n\n### 为什么要选择开源软件\n开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！\n\n对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步**相互切磋与学习**。\n\n开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。\n\n### 最后\n\n最后还要说一点：不要把开源软件与盗版混为一谈。\n\n如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。\n\n开源的观念并不只限于软件的开发与使用，而是希望能够抱着**开放的心态**，**分享与合作的精神**，**相互切磋与学习**，**当你的代码被分享时它会变得更好**。\n\n> 参考连接：\n> - https://blog.csdn.net/happmaoo/article/details/83201544\n> - https://www.oschina.net/news/58921/what-is-open-source","source":"_posts/【杂谈】对开源的理解.md","raw":"---\ntitle: 【杂谈】对开源的理解\ndate: 2019-04-11 20:13:15\ntags: [杂谈, 开源]\ncategories: 杂谈\n---\n\n### 什么是开源\n所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。\n\n在IT领域来说的话，字面意思就是**开放源代码**，开源软件的源代码任何人都可以审查、修改和增强。\n<!-- more -->\n虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。\n\n\n### 开源是否等于免费\n开源等于免费是对开源的最大误解。\n\n商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于**License**（许可协议）。\n\n商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。\n\n开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的**约束和保护**。\n\n目前使用最广泛的一种开源协议便是**MIT License**，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。\n\n### 为什么要选择开源软件\n开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！\n\n对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步**相互切磋与学习**。\n\n开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。\n\n### 最后\n\n最后还要说一点：不要把开源软件与盗版混为一谈。\n\n如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。\n\n开源的观念并不只限于软件的开发与使用，而是希望能够抱着**开放的心态**，**分享与合作的精神**，**相互切磋与学习**，**当你的代码被分享时它会变得更好**。\n\n> 参考连接：\n> - https://blog.csdn.net/happmaoo/article/details/83201544\n> - https://www.oschina.net/news/58921/what-is-open-source","slug":"【杂谈】对开源的理解","published":1,"updated":"2021-12-12T02:50:23.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6vd000qvcueezw254zh","content":"<h3 id=\"什么是开源\"><a href=\"#什么是开源\" class=\"headerlink\" title=\"什么是开源\"></a>什么是开源</h3><p>所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。</p>\n<p>在IT领域来说的话，字面意思就是<strong>开放源代码</strong>，开源软件的源代码任何人都可以审查、修改和增强。</p>\n<span id=\"more\"></span>\n<p>虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。</p>\n<h3 id=\"开源是否等于免费\"><a href=\"#开源是否等于免费\" class=\"headerlink\" title=\"开源是否等于免费\"></a>开源是否等于免费</h3><p>开源等于免费是对开源的最大误解。</p>\n<p>商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于<strong>License</strong>（许可协议）。</p>\n<p>商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。</p>\n<p>开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的<strong>约束和保护</strong>。</p>\n<p>目前使用最广泛的一种开源协议便是<strong>MIT License</strong>，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。</p>\n<h3 id=\"为什么要选择开源软件\"><a href=\"#为什么要选择开源软件\" class=\"headerlink\" title=\"为什么要选择开源软件\"></a>为什么要选择开源软件</h3><p>开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！</p>\n<p>对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步<strong>相互切磋与学习</strong>。</p>\n<p>开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>最后还要说一点：不要把开源软件与盗版混为一谈。</p>\n<p>如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。</p>\n<p>开源的观念并不只限于软件的开发与使用，而是希望能够抱着<strong>开放的心态</strong>，<strong>分享与合作的精神</strong>，<strong>相互切磋与学习</strong>，<strong>当你的代码被分享时它会变得更好</strong>。</p>\n<blockquote>\n<p>参考连接：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/happmaoo/article/details/83201544\">https://blog.csdn.net/happmaoo/article/details/83201544</a></li>\n<li><a href=\"https://www.oschina.net/news/58921/what-is-open-source\">https://www.oschina.net/news/58921/what-is-open-source</a></li>\n</ul>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h3 id=\"什么是开源\"><a href=\"#什么是开源\" class=\"headerlink\" title=\"什么是开源\"></a>什么是开源</h3><p>所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。</p>\n<p>在IT领域来说的话，字面意思就是<strong>开放源代码</strong>，开源软件的源代码任何人都可以审查、修改和增强。</p>","more":"<p>虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。</p>\n<h3 id=\"开源是否等于免费\"><a href=\"#开源是否等于免费\" class=\"headerlink\" title=\"开源是否等于免费\"></a>开源是否等于免费</h3><p>开源等于免费是对开源的最大误解。</p>\n<p>商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于<strong>License</strong>（许可协议）。</p>\n<p>商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。</p>\n<p>开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的<strong>约束和保护</strong>。</p>\n<p>目前使用最广泛的一种开源协议便是<strong>MIT License</strong>，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。</p>\n<h3 id=\"为什么要选择开源软件\"><a href=\"#为什么要选择开源软件\" class=\"headerlink\" title=\"为什么要选择开源软件\"></a>为什么要选择开源软件</h3><p>开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！</p>\n<p>对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步<strong>相互切磋与学习</strong>。</p>\n<p>开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>最后还要说一点：不要把开源软件与盗版混为一谈。</p>\n<p>如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。</p>\n<p>开源的观念并不只限于软件的开发与使用，而是希望能够抱着<strong>开放的心态</strong>，<strong>分享与合作的精神</strong>，<strong>相互切磋与学习</strong>，<strong>当你的代码被分享时它会变得更好</strong>。</p>\n<blockquote>\n<p>参考连接：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/happmaoo/article/details/83201544\">https://blog.csdn.net/happmaoo/article/details/83201544</a></li>\n<li><a href=\"https://www.oschina.net/news/58921/what-is-open-source\">https://www.oschina.net/news/58921/what-is-open-source</a></li>\n</ul>\n</blockquote>"},{"layout":"[post]","title":"【环境配置】Win10下配置Nginx+PHP-7+MySQL-5.6","date":"2018-10-22T03:39:12.000Z","_content":"\n\n### 1. 软件下载\n  - Windows操作系统。\n  - Nginx，下载地址：[http://nginx.org/en/download.html](http://nginx.org/en/download.html)。\n  - PHP，下载地址：[http://php.net/downloads.php](http://php.net/downloads.php)（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。\n  - MySQL，下载地址：[https://www.mysql.com/downloads/](https://www.mysql.com/downloads/)。（选择社区版`Community`->`MySQL Community Server`->`MySQL Community Server 5.6`，根据Windows系统选择对应zip包）。\n<!-- more -->\n### 2. 软件安装\n在C盘新建安装目录`C:\\PHP`。\n#### 2.1 Nginx安装\n  Nginx本身就是绿色软件，下载zip安装包解压到`C:\\PHP`，打开目录`C:\\PHP\\nginx-1.15.8`双击nginx.exe就可以运行，然后在浏览器打开[http://127.0.0.1](http://127.0.0.1)，出现欢迎界面表示NGINX正常工作。\n  确认NGINX正常工作后在任务管理器中结束nginx.exe任务。\n#### 2.2 PHP安装\n  把PHP的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\php-7.3.2`。\n  cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。\n  将`C:\\PHP\\php-7.3.2`加入系统环境变量。\n#### 2.3 准备网站根目录\n  准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把`C:\\PHP\\web`作为我的网站根目录。\n  在根目录`C:\\PHP\\web`下新建一个info.php文件，输入如下内容：\n    ``` php\n    <?php\n        phpinfo();\n    ?>\n    ```\n#### 2.4 让nginx识别PHP\n  配置PHP (`C:\\PHP\\php-7.3.2`)\n  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:\n  在PHP根目录下修改配置文件`C:\\PHP\\php-7.3.2\\php.ini-development`并另存为`php.ini`,在其中修改或添加配置：\n  ```\n  cgi.fix_pathinfo=1\n  ```\n  配置nginx conf(`C:\\PHP\\nginx-1.15.8\\conf`)\n  在Nginx根目录下找到conf目录，编辑器打开`C:\\PHP\\nginx-1.15.8\\confnginx.conf`:\n    ```\n    error_log  logs/error.log; #打开error_log\n    http {\n\n        # ...\n\n        server {\n\n            # ...\n\n            location / {\n                root     C:\\PHP\\web; #配置根目录\n                index   index.html index.htm index.php;\n            }\n\n            # ...\n\n            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n            # 打开下面几行注释\n            location ~ \\.php$ {\n                root             C:\\PHP\\web; #配置根目录\n                fastcgi_pass     127.0.0.1:9000;\n                fastcgi_index    index.php;\n                #重要: 把下面 /scripts 修改成 $document_root\n                fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; \n                include          fastcgi_params;\n            }\n\n            # ...\n        }\n    }\n    ```\n#### 2.5 运行与测试\nnginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么`nginx.conf`中有这样一句`fastcgi_pass 127.0.0.1:9000;`。\n1. 在任务管理器中结束nginx.exe任务，然后到`C:\\PHP\\nginx-1.15.8`目录双击nginx.exe开启服务。\n2. 在命令行中，cd到php的home目录`C:\\PHP\\php-7.3.2`，然后执行如下命令：\n  ``` cmd\n  php-cgi.exe -b 127.0.0.1:9000 -c php.ini\n  ```\n3. 打开浏览器，输入 [http://127.0.0.1/info.php](http://127.0.0.1/info.php)，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。\n\n#### 2.6 MySQL安装\n  把MySQL的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\mysql-5.6.43-winx64`。\n  将`C:\\PHP\\mysql-5.6.43-winx64\\bin`加入系统环境变量。\n  修改配置文件`C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini`并另存为`my.ini`,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：\n    ```\n    basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录\n    datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data\n    ```\n  以管理员身份运行cmd,到安装目录的bin下，输入`mysqld -install`：\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin> mysqld -install\n    Service successfully installed.\n    ```\n  输入命令:`mysql --version`,正常会显示版本信息。\n  输入命令:`net start mysql`启动服务(停止命令：net stop mysql):\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>net start mysql\n    MySQL 服务正在启动 ..\n    MySQL 服务已经启动成功。\n    ```\n  服务启动成功之后，输入命令：`mysql -u root -p`（第一次登录没有密码，直接按回车过）:\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>mysql -u root -p\n    Enter password:\n    Welcome to the MySQL monitor.  Commands end with ; or \\g.\n    Your MySQL connection id is 1\n    Server version: 5.6.43 MySQL Community Server (GPL)\n    Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n    Oracle is a registered trademark of Oracle Corporation and/or its\n    affiliates. Other names may be trademarks of their respective\n    owners.\n    Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n    mysql>\n    ```\n  如出现`mysql>`,即登录成功。\n  输入命令`exit`,退出登录。\n    ```\n    mysql> exit\n    Bye\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>\n    ```\n### 3. 制作自动启动脚本\n控制台就一直开着，很不方便。这个时候可以使用 [RunHiddenConsole.zip](https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip) 来得管理服务的启动与关闭。\n#### 3.1 启动脚本\n在目录`C:\\PHP`下新建一个`start.bat`作为启动脚本文件：\n``` bat\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n#### 3.2 停止脚本\n在目录`C:\\PHP`下新建一个`stop.bat`作为停止脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\n:请按任意键继续. . .\npause\n```\n#### 3.3 重启脚本\n在目录`C:\\PHP`下新建一个`restart.bat`作为重启脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\necho.\n\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n### 4.最后\n我的根目录结构\n``` cmd\nC:\\PHP>dir\n 驱动器 C 中的卷是 系统\n 卷的序列号是 09C1-B27D\n\n C:\\PHP 的目录\n\n2019/02/22  15:46    <DIR>          .\n2019/02/22  15:46    <DIR>          ..\n2019/02/22  11:23    <DIR>          mysql-5.6.43-winx64\n2018/12/25  17:54    <DIR>          nginx-1.15.8\n2019/02/21  15:59    <DIR>          php-7.3.2\n2019/02/22  15:41               758 restart.bat\n2010/10/26  11:43             1,536 RunHiddenConsole.exe\n2019/02/22  15:41               549 start.bat\n2019/02/22  15:41               227 stop.bat\n2019/02/21  16:56    <DIR>          web\n               4 个文件          3,070 字节\n               6 个目录 100,959,772,672 可用字节\n```\n","source":"_posts/【环境配置】Win10下配置Nginx-php7-mysql-5-6.md","raw":"---\nlayout: '[post]'\ntitle: 【环境配置】Win10下配置Nginx+PHP-7+MySQL-5.6\ndate: 2018-10-22 11:39:12\ntags: 环境配置\ncategories: 环境配置\n---\n\n\n### 1. 软件下载\n  - Windows操作系统。\n  - Nginx，下载地址：[http://nginx.org/en/download.html](http://nginx.org/en/download.html)。\n  - PHP，下载地址：[http://php.net/downloads.php](http://php.net/downloads.php)（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。\n  - MySQL，下载地址：[https://www.mysql.com/downloads/](https://www.mysql.com/downloads/)。（选择社区版`Community`->`MySQL Community Server`->`MySQL Community Server 5.6`，根据Windows系统选择对应zip包）。\n<!-- more -->\n### 2. 软件安装\n在C盘新建安装目录`C:\\PHP`。\n#### 2.1 Nginx安装\n  Nginx本身就是绿色软件，下载zip安装包解压到`C:\\PHP`，打开目录`C:\\PHP\\nginx-1.15.8`双击nginx.exe就可以运行，然后在浏览器打开[http://127.0.0.1](http://127.0.0.1)，出现欢迎界面表示NGINX正常工作。\n  确认NGINX正常工作后在任务管理器中结束nginx.exe任务。\n#### 2.2 PHP安装\n  把PHP的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\php-7.3.2`。\n  cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。\n  将`C:\\PHP\\php-7.3.2`加入系统环境变量。\n#### 2.3 准备网站根目录\n  准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把`C:\\PHP\\web`作为我的网站根目录。\n  在根目录`C:\\PHP\\web`下新建一个info.php文件，输入如下内容：\n    ``` php\n    <?php\n        phpinfo();\n    ?>\n    ```\n#### 2.4 让nginx识别PHP\n  配置PHP (`C:\\PHP\\php-7.3.2`)\n  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:\n  在PHP根目录下修改配置文件`C:\\PHP\\php-7.3.2\\php.ini-development`并另存为`php.ini`,在其中修改或添加配置：\n  ```\n  cgi.fix_pathinfo=1\n  ```\n  配置nginx conf(`C:\\PHP\\nginx-1.15.8\\conf`)\n  在Nginx根目录下找到conf目录，编辑器打开`C:\\PHP\\nginx-1.15.8\\confnginx.conf`:\n    ```\n    error_log  logs/error.log; #打开error_log\n    http {\n\n        # ...\n\n        server {\n\n            # ...\n\n            location / {\n                root     C:\\PHP\\web; #配置根目录\n                index   index.html index.htm index.php;\n            }\n\n            # ...\n\n            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n            # 打开下面几行注释\n            location ~ \\.php$ {\n                root             C:\\PHP\\web; #配置根目录\n                fastcgi_pass     127.0.0.1:9000;\n                fastcgi_index    index.php;\n                #重要: 把下面 /scripts 修改成 $document_root\n                fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; \n                include          fastcgi_params;\n            }\n\n            # ...\n        }\n    }\n    ```\n#### 2.5 运行与测试\nnginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么`nginx.conf`中有这样一句`fastcgi_pass 127.0.0.1:9000;`。\n1. 在任务管理器中结束nginx.exe任务，然后到`C:\\PHP\\nginx-1.15.8`目录双击nginx.exe开启服务。\n2. 在命令行中，cd到php的home目录`C:\\PHP\\php-7.3.2`，然后执行如下命令：\n  ``` cmd\n  php-cgi.exe -b 127.0.0.1:9000 -c php.ini\n  ```\n3. 打开浏览器，输入 [http://127.0.0.1/info.php](http://127.0.0.1/info.php)，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。\n\n#### 2.6 MySQL安装\n  把MySQL的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\mysql-5.6.43-winx64`。\n  将`C:\\PHP\\mysql-5.6.43-winx64\\bin`加入系统环境变量。\n  修改配置文件`C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini`并另存为`my.ini`,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：\n    ```\n    basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录\n    datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data\n    ```\n  以管理员身份运行cmd,到安装目录的bin下，输入`mysqld -install`：\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin> mysqld -install\n    Service successfully installed.\n    ```\n  输入命令:`mysql --version`,正常会显示版本信息。\n  输入命令:`net start mysql`启动服务(停止命令：net stop mysql):\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>net start mysql\n    MySQL 服务正在启动 ..\n    MySQL 服务已经启动成功。\n    ```\n  服务启动成功之后，输入命令：`mysql -u root -p`（第一次登录没有密码，直接按回车过）:\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>mysql -u root -p\n    Enter password:\n    Welcome to the MySQL monitor.  Commands end with ; or \\g.\n    Your MySQL connection id is 1\n    Server version: 5.6.43 MySQL Community Server (GPL)\n    Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n    Oracle is a registered trademark of Oracle Corporation and/or its\n    affiliates. Other names may be trademarks of their respective\n    owners.\n    Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n    mysql>\n    ```\n  如出现`mysql>`,即登录成功。\n  输入命令`exit`,退出登录。\n    ```\n    mysql> exit\n    Bye\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>\n    ```\n### 3. 制作自动启动脚本\n控制台就一直开着，很不方便。这个时候可以使用 [RunHiddenConsole.zip](https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip) 来得管理服务的启动与关闭。\n#### 3.1 启动脚本\n在目录`C:\\PHP`下新建一个`start.bat`作为启动脚本文件：\n``` bat\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n#### 3.2 停止脚本\n在目录`C:\\PHP`下新建一个`stop.bat`作为停止脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\n:请按任意键继续. . .\npause\n```\n#### 3.3 重启脚本\n在目录`C:\\PHP`下新建一个`restart.bat`作为重启脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\necho.\n\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n### 4.最后\n我的根目录结构\n``` cmd\nC:\\PHP>dir\n 驱动器 C 中的卷是 系统\n 卷的序列号是 09C1-B27D\n\n C:\\PHP 的目录\n\n2019/02/22  15:46    <DIR>          .\n2019/02/22  15:46    <DIR>          ..\n2019/02/22  11:23    <DIR>          mysql-5.6.43-winx64\n2018/12/25  17:54    <DIR>          nginx-1.15.8\n2019/02/21  15:59    <DIR>          php-7.3.2\n2019/02/22  15:41               758 restart.bat\n2010/10/26  11:43             1,536 RunHiddenConsole.exe\n2019/02/22  15:41               549 start.bat\n2019/02/22  15:41               227 stop.bat\n2019/02/21  16:56    <DIR>          web\n               4 个文件          3,070 字节\n               6 个目录 100,959,772,672 可用字节\n```\n","slug":"【环境配置】Win10下配置Nginx-php7-mysql-5-6","published":1,"updated":"2021-12-12T02:50:23.401Z","comments":1,"photos":[],"link":"","_id":"ckx2vb6vg000vvcue66q96wcl","content":"<h3 id=\"1-软件下载\"><a href=\"#1-软件下载\" class=\"headerlink\" title=\"1. 软件下载\"></a>1. 软件下载</h3><ul>\n<li>Windows操作系统。</li>\n<li>Nginx，下载地址：<a href=\"http://nginx.org/en/download.html\">http://nginx.org/en/download.html</a>。</li>\n<li>PHP，下载地址：<a href=\"http://php.net/downloads.php\">http://php.net/downloads.php</a>（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。</li>\n<li>MySQL，下载地址：<a href=\"https://www.mysql.com/downloads/\">https://www.mysql.com/downloads/</a>。（选择社区版<code>Community</code>-&gt;<code>MySQL Community Server</code>-&gt;<code>MySQL Community Server 5.6</code>，根据Windows系统选择对应zip包）。<span id=\"more\"></span>\n<h3 id=\"2-软件安装\"><a href=\"#2-软件安装\" class=\"headerlink\" title=\"2. 软件安装\"></a>2. 软件安装</h3>在C盘新建安装目录<code>C:\\PHP</code>。<h4 id=\"2-1-Nginx安装\"><a href=\"#2-1-Nginx安装\" class=\"headerlink\" title=\"2.1 Nginx安装\"></a>2.1 Nginx安装</h4>Nginx本身就是绿色软件，下载zip安装包解压到<code>C:\\PHP</code>，打开目录<code>C:\\PHP\\nginx-1.15.8</code>双击nginx.exe就可以运行，然后在浏览器打开<a href=\"http://127.0.0.1/\">http://127.0.0.1</a>，出现欢迎界面表示NGINX正常工作。<br>确认NGINX正常工作后在任务管理器中结束nginx.exe任务。<h4 id=\"2-2-PHP安装\"><a href=\"#2-2-PHP安装\" class=\"headerlink\" title=\"2.2 PHP安装\"></a>2.2 PHP安装</h4>把PHP的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\php-7.3.2</code>。<br>cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。<br>将<code>C:\\PHP\\php-7.3.2</code>加入系统环境变量。<h4 id=\"2-3-准备网站根目录\"><a href=\"#2-3-准备网站根目录\" class=\"headerlink\" title=\"2.3 准备网站根目录\"></a>2.3 准备网站根目录</h4>准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把<code>C:\\PHP\\web</code>作为我的网站根目录。<br>在根目录<code>C:\\PHP\\web</code>下新建一个info.php文件，输入如下内容：<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    phpinfo();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-让nginx识别PHP\"><a href=\"#2-4-让nginx识别PHP\" class=\"headerlink\" title=\"2.4 让nginx识别PHP\"></a>2.4 让nginx识别PHP</h4>配置PHP (<code>C:\\PHP\\php-7.3.2</code>)<br>在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:<br>在PHP根目录下修改配置文件<code>C:\\PHP\\php-7.3.2\\php.ini-development</code>并另存为<code>php.ini</code>,在其中修改或添加配置：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cgi.fix_pathinfo=1</span><br></pre></td></tr></table></figure>\n配置nginx conf(<code>C:\\PHP\\nginx-1.15.8\\conf</code>)<br>在Nginx根目录下找到conf目录，编辑器打开<code>C:\\PHP\\nginx-1.15.8\\confnginx.conf</code>:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error_log  logs/error.log; #打开error_log</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    # ...</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root     C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            index   index.html index.htm index.php;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">        # 打开下面几行注释</span><br><span class=\"line\">        location ~ \\.php$ &#123;</span><br><span class=\"line\">            root             C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            fastcgi_pass     127.0.0.1:9000;</span><br><span class=\"line\">            fastcgi_index    index.php;</span><br><span class=\"line\">            #重要: 把下面 /scripts 修改成 $document_root</span><br><span class=\"line\">            fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; </span><br><span class=\"line\">            include          fastcgi_params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-运行与测试\"><a href=\"#2-5-运行与测试\" class=\"headerlink\" title=\"2.5 运行与测试\"></a>2.5 运行与测试</h4>nginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么<code>nginx.conf</code>中有这样一句<code>fastcgi_pass 127.0.0.1:9000;</code>。</li>\n</ul>\n<ol>\n<li>在任务管理器中结束nginx.exe任务，然后到<code>C:\\PHP\\nginx-1.15.8</code>目录双击nginx.exe开启服务。</li>\n<li>在命令行中，cd到php的home目录<code>C:\\PHP\\php-7.3.2</code>，然后执行如下命令：<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c php.ini</span><br></pre></td></tr></table></figure></li>\n<li>打开浏览器，输入 <a href=\"http://127.0.0.1/info.php\">http://127.0.0.1/info.php</a>，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。</li>\n</ol>\n<h4 id=\"2-6-MySQL安装\"><a href=\"#2-6-MySQL安装\" class=\"headerlink\" title=\"2.6 MySQL安装\"></a>2.6 MySQL安装</h4><p>  把MySQL的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\mysql-5.6.43-winx64</code>。<br>  将<code>C:\\PHP\\mysql-5.6.43-winx64\\bin</code>加入系统环境变量。<br>  修改配置文件<code>C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini</code>并另存为<code>my.ini</code>,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录</span><br><span class=\"line\">datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data</span><br></pre></td></tr></table></figure><br>  以管理员身份运行cmd,到安装目录的bin下，输入<code>mysqld -install</code>：<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt; mysqld -install</span><br><span class=\"line\">Service successfully installed.</span><br></pre></td></tr></table></figure><br>  输入命令:<code>mysql --version</code>,正常会显示版本信息。<br>  输入命令:<code>net start mysql</code>启动服务(停止命令：net stop mysql):<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;net start mysql</span><br><span class=\"line\">MySQL 服务正在启动 ..</span><br><span class=\"line\">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure><br>  服务启动成功之后，输入命令：<code>mysql -u root -p</code>（第一次登录没有密码，直接按回车过）:<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;mysql -u root -p</span><br><span class=\"line\">Enter password:</span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 1</span><br><span class=\"line\">Server version: 5.6.43 MySQL Community Server (GPL)</span><br><span class=\"line\">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\">Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.</span><br><span class=\"line\">mysql&gt;</span><br></pre></td></tr></table></figure><br>  如出现<code>mysql&gt;</code>,即登录成功。<br>  输入命令<code>exit</code>,退出登录。<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; exit</span><br><span class=\"line\">Bye</span><br><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-制作自动启动脚本\"><a href=\"#3-制作自动启动脚本\" class=\"headerlink\" title=\"3. 制作自动启动脚本\"></a>3. 制作自动启动脚本</h3><p>控制台就一直开着，很不方便。这个时候可以使用 <a href=\"https://link.jianshu.com/?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip\">RunHiddenConsole.zip</a> 来得管理服务的启动与关闭。</p>\n<h4 id=\"3-1-启动脚本\"><a href=\"#3-1-启动脚本\" class=\"headerlink\" title=\"3.1 启动脚本\"></a>3.1 启动脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>start.bat</code>作为启动脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-停止脚本\"><a href=\"#3-2-停止脚本\" class=\"headerlink\" title=\"3.2 停止脚本\"></a>3.2 停止脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>stop.bat</code>作为停止脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-重启脚本\"><a href=\"#3-3-重启脚本\" class=\"headerlink\" title=\"3.3 重启脚本\"></a>3.3 重启脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>restart.bat</code>作为重启脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-最后\"><a href=\"#4-最后\" class=\"headerlink\" title=\"4.最后\"></a>4.最后</h3><p>我的根目录结构</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">PHP</span>&gt;<span class=\"title\">dir</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 系统</span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 09<span class=\"title\">C1</span>-<span class=\"title\">B27D</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">PHP</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          ..</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  11:23    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">mysql</span>-5.6.43-<span class=\"title\">winx64</span></span></span><br><span class=\"line\"><span class=\"function\">2018/12/25  17:54    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">nginx</span>-1.15.8</span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  15:59    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">php</span>-7.3.2</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               758 <span class=\"title\">restart.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2010/10/26  11:43             1,536 <span class=\"title\">RunHiddenConsole.exe</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               549 <span class=\"title\">start.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               227 <span class=\"title\">stop.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  16:56    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">web</span></span></span><br><span class=\"line\"><span class=\"function\">               4 个文件          3,070 字节</span></span><br><span class=\"line\"><span class=\"function\">               6 个目录 100,959,772,672 可用字节</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h3 id=\"1-软件下载\"><a href=\"#1-软件下载\" class=\"headerlink\" title=\"1. 软件下载\"></a>1. 软件下载</h3><ul>\n<li>Windows操作系统。</li>\n<li>Nginx，下载地址：<a href=\"http://nginx.org/en/download.html\">http://nginx.org/en/download.html</a>。</li>\n<li>PHP，下载地址：<a href=\"http://php.net/downloads.php\">http://php.net/downloads.php</a>（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。</li>\n<li>MySQL，下载地址：<a href=\"https://www.mysql.com/downloads/\">https://www.mysql.com/downloads/</a>。（选择社区版<code>Community</code>-&gt;<code>MySQL Community Server</code>-&gt;<code>MySQL Community Server 5.6</code>，根据Windows系统选择对应zip包）。","more":"<h3 id=\"2-软件安装\"><a href=\"#2-软件安装\" class=\"headerlink\" title=\"2. 软件安装\"></a>2. 软件安装</h3>在C盘新建安装目录<code>C:\\PHP</code>。<h4 id=\"2-1-Nginx安装\"><a href=\"#2-1-Nginx安装\" class=\"headerlink\" title=\"2.1 Nginx安装\"></a>2.1 Nginx安装</h4>Nginx本身就是绿色软件，下载zip安装包解压到<code>C:\\PHP</code>，打开目录<code>C:\\PHP\\nginx-1.15.8</code>双击nginx.exe就可以运行，然后在浏览器打开<a href=\"http://127.0.0.1/\">http://127.0.0.1</a>，出现欢迎界面表示NGINX正常工作。<br>确认NGINX正常工作后在任务管理器中结束nginx.exe任务。<h4 id=\"2-2-PHP安装\"><a href=\"#2-2-PHP安装\" class=\"headerlink\" title=\"2.2 PHP安装\"></a>2.2 PHP安装</h4>把PHP的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\php-7.3.2</code>。<br>cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。<br>将<code>C:\\PHP\\php-7.3.2</code>加入系统环境变量。<h4 id=\"2-3-准备网站根目录\"><a href=\"#2-3-准备网站根目录\" class=\"headerlink\" title=\"2.3 准备网站根目录\"></a>2.3 准备网站根目录</h4>准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把<code>C:\\PHP\\web</code>作为我的网站根目录。<br>在根目录<code>C:\\PHP\\web</code>下新建一个info.php文件，输入如下内容：<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    phpinfo();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-让nginx识别PHP\"><a href=\"#2-4-让nginx识别PHP\" class=\"headerlink\" title=\"2.4 让nginx识别PHP\"></a>2.4 让nginx识别PHP</h4>配置PHP (<code>C:\\PHP\\php-7.3.2</code>)<br>在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:<br>在PHP根目录下修改配置文件<code>C:\\PHP\\php-7.3.2\\php.ini-development</code>并另存为<code>php.ini</code>,在其中修改或添加配置：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cgi.fix_pathinfo=1</span><br></pre></td></tr></table></figure>\n配置nginx conf(<code>C:\\PHP\\nginx-1.15.8\\conf</code>)<br>在Nginx根目录下找到conf目录，编辑器打开<code>C:\\PHP\\nginx-1.15.8\\confnginx.conf</code>:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error_log  logs/error.log; #打开error_log</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    # ...</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root     C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            index   index.html index.htm index.php;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">        # 打开下面几行注释</span><br><span class=\"line\">        location ~ \\.php$ &#123;</span><br><span class=\"line\">            root             C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            fastcgi_pass     127.0.0.1:9000;</span><br><span class=\"line\">            fastcgi_index    index.php;</span><br><span class=\"line\">            #重要: 把下面 /scripts 修改成 $document_root</span><br><span class=\"line\">            fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; </span><br><span class=\"line\">            include          fastcgi_params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-运行与测试\"><a href=\"#2-5-运行与测试\" class=\"headerlink\" title=\"2.5 运行与测试\"></a>2.5 运行与测试</h4>nginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么<code>nginx.conf</code>中有这样一句<code>fastcgi_pass 127.0.0.1:9000;</code>。</li>\n</ul>\n<ol>\n<li>在任务管理器中结束nginx.exe任务，然后到<code>C:\\PHP\\nginx-1.15.8</code>目录双击nginx.exe开启服务。</li>\n<li>在命令行中，cd到php的home目录<code>C:\\PHP\\php-7.3.2</code>，然后执行如下命令：<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c php.ini</span><br></pre></td></tr></table></figure></li>\n<li>打开浏览器，输入 <a href=\"http://127.0.0.1/info.php\">http://127.0.0.1/info.php</a>，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。</li>\n</ol>\n<h4 id=\"2-6-MySQL安装\"><a href=\"#2-6-MySQL安装\" class=\"headerlink\" title=\"2.6 MySQL安装\"></a>2.6 MySQL安装</h4><p>  把MySQL的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\mysql-5.6.43-winx64</code>。<br>  将<code>C:\\PHP\\mysql-5.6.43-winx64\\bin</code>加入系统环境变量。<br>  修改配置文件<code>C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini</code>并另存为<code>my.ini</code>,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录</span><br><span class=\"line\">datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data</span><br></pre></td></tr></table></figure><br>  以管理员身份运行cmd,到安装目录的bin下，输入<code>mysqld -install</code>：<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt; mysqld -install</span><br><span class=\"line\">Service successfully installed.</span><br></pre></td></tr></table></figure><br>  输入命令:<code>mysql --version</code>,正常会显示版本信息。<br>  输入命令:<code>net start mysql</code>启动服务(停止命令：net stop mysql):<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;net start mysql</span><br><span class=\"line\">MySQL 服务正在启动 ..</span><br><span class=\"line\">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure><br>  服务启动成功之后，输入命令：<code>mysql -u root -p</code>（第一次登录没有密码，直接按回车过）:<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;mysql -u root -p</span><br><span class=\"line\">Enter password:</span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 1</span><br><span class=\"line\">Server version: 5.6.43 MySQL Community Server (GPL)</span><br><span class=\"line\">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\">Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.</span><br><span class=\"line\">mysql&gt;</span><br></pre></td></tr></table></figure><br>  如出现<code>mysql&gt;</code>,即登录成功。<br>  输入命令<code>exit</code>,退出登录。<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; exit</span><br><span class=\"line\">Bye</span><br><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-制作自动启动脚本\"><a href=\"#3-制作自动启动脚本\" class=\"headerlink\" title=\"3. 制作自动启动脚本\"></a>3. 制作自动启动脚本</h3><p>控制台就一直开着，很不方便。这个时候可以使用 <a href=\"https://link.jianshu.com/?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip\">RunHiddenConsole.zip</a> 来得管理服务的启动与关闭。</p>\n<h4 id=\"3-1-启动脚本\"><a href=\"#3-1-启动脚本\" class=\"headerlink\" title=\"3.1 启动脚本\"></a>3.1 启动脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>start.bat</code>作为启动脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-停止脚本\"><a href=\"#3-2-停止脚本\" class=\"headerlink\" title=\"3.2 停止脚本\"></a>3.2 停止脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>stop.bat</code>作为停止脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-重启脚本\"><a href=\"#3-3-重启脚本\" class=\"headerlink\" title=\"3.3 重启脚本\"></a>3.3 重启脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>restart.bat</code>作为重启脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-最后\"><a href=\"#4-最后\" class=\"headerlink\" title=\"4.最后\"></a>4.最后</h3><p>我的根目录结构</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">PHP</span>&gt;<span class=\"title\">dir</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 系统</span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 09<span class=\"title\">C1</span>-<span class=\"title\">B27D</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">PHP</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          ..</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  11:23    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">mysql</span>-5.6.43-<span class=\"title\">winx64</span></span></span><br><span class=\"line\"><span class=\"function\">2018/12/25  17:54    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">nginx</span>-1.15.8</span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  15:59    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">php</span>-7.3.2</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               758 <span class=\"title\">restart.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2010/10/26  11:43             1,536 <span class=\"title\">RunHiddenConsole.exe</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               549 <span class=\"title\">start.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               227 <span class=\"title\">stop.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  16:56    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">web</span></span></span><br><span class=\"line\"><span class=\"function\">               4 个文件          3,070 字节</span></span><br><span class=\"line\"><span class=\"function\">               6 个目录 100,959,772,672 可用字节</span></span><br></pre></td></tr></table></figure>"},{"title":"【环境配置】Redis与MySQL多实例配置","date":"2020-02-11T15:08:46.000Z","_content":"\n最近由于工作的需要，需要在同一台服务器上搭建两个`Redis`与`MySQL`的实例。\n多实例：就是在一台机器上面开启多个不同的端口(如`Redis`用`6379`/`6380`，`MySQL`用`3306`/`3307`等)，运行多个服务进程；公用一套安装程序，使用不同的配置文件，数据文件。\n<!-- more -->\n\n### 1. Redis多实例配置\n#### 1.1 查看主机Redis信息\n1. 用`ps`命令查看`Redis`进程\n\n``` bash\n[root@localhost ~] ps -ef |grep redis\nroot      1706     1  0  2019 ?        04:12:09 /usr/local/bin/redis-server *:6379                    \nroot     18174  2560  0 15:35 pts/0    00:00:00 grep redis\n```\n\n2. 查找配置文件位置\n\n``` bash\n[root@localhost ~] locate redis.conf\n/etc/redis.conf\n```\n\n#### 1.2 拷贝配置文件并修改\n1. 拷贝`redis.conf`并命名为`redis6380.conf`，并修改参数\n\n``` bash\n[root@localhost ~] cp /etc/redis.conf /etc/redis6380.conf\n[root@localhost ~] vim /etc/redis6380.conf\n# 查找 /pidfile 找到pid位置\n# pidfile /var/run/redis.pid        #修改pid，每个实例需要运行在不同的pid\npidfile /var/run/redis6380.pid\n# \n# 查找 /port 6379 找到端口位置\n# port 6379                         #修改端口\nport 6380\n#                      \n# 查找 /dir 找到数据目录位置\n# dir /mnt/newdatadrive/data/redis  #修改数据存放目录\ndir /mnt/newdatadrive/data/redis6380\n# \n# 已开启Redis持久化\nappendonly yes\n```\n\n2. 准备上面配置的文件\n\n``` bash\n[root@localhost ~] mkdir –p /mnt/newdatadrive/data/redis6380\n[root@localhost ~] cp /var/run/redis.pid /var/run/redis6380.pid\n```\n\n\n#### 1.3 启动测试\n1. 启动`6380`端口`Redis`服务，并查看`Redis`进程\n\n``` bash\n[root@localhost ~] /usr/local/bin/redis-server /etc/redis6380.conf\n[root@localhost ~] ps -ef |grep redis\nroot      1706     1  0  2019 ?        04:12:00 /usr/local/bin/redis-server *:6379         \nroot     15967     1  0 12:16 ?        00:00:00 /usr/local/bin/redis-server *:6380             \nroot     15994  8014  0 12:16 pts/2    00:00:00 grep redis\n```\n\n2. 测试登录`Redis`客户端\n\n``` bash\n[root@localhost ~] redis-cli -p 6380\n127.0.0.1:6380> QUIT     #退出\n```\n\n3. 停止`6380`端口的`Redis`服务\n\n``` bash\nredis-cli -p 6380 shutdown\n```\n\n\n#### 1.4 Redis数据迁移\n1. 登录原`Redis`客户端(`6379`)\n\n``` bash\n[root@localhost ~] redis-cli -p 6379\n127.0.0.1:6379> SAVE             #数据备份\n127.0.0.1:6379> CONFIG GET dir   #查看Redis数据目录\n1) \"dir\"\n2) \"/mnt/newdatadrive/data/redis\"\n127.0.0.1:6379> QUIT             #退出\n```\n\n2. 拷贝数据文件`appendonly.aof`和`dump.rdb`到`6380`\n\n``` bash\n# 查看6379的数据文件\n[root@localhost ~] cd /mnt/newdatadrive/data/redis && ll\ntotal 55176\n-rw-r--r-- 1 root root 55411226 Feb 11 09:25 appendonly.aof\n-rw-r--r-- 1 root root  1017181 Feb 11 12:28 dump.rdb\n# 拷贝到6380\n[root@localhost ~] \\cp /mnt/newdatadrive/data/redis/appendonly.aof /mnt/newdatadrive/data/redis6380/appendonly.aof\n[root@localhost ~] \\cp /mnt/newdatadrive/data/redis/dump.rdb /mnt/newdatadrive/data/redis6380/dump.rdb\n```\n\n3. 启动`6380`端口`Redis`服务，导入`AOF`数据文件\n\n``` bash\n[root@localhost ~] /usr/local/bin/redis-server /etc/redis6380.conf\n[root@localhost ~] redis-cli -p 6380 --pipe < /mnt/newdatadrive/data/redis6380/appendonly.aof\n```\n\n4. 登录`Redis`查看数据\n\n``` bash\n[root@localhost ~] redis-cli -p 6380\n127.0.0.1:6380>   #输入具体命令查看数据\n```\n\n#### 1.5 配置远程可访问\n1. 修改配置文件`redis6380.conf`\n\n``` bash\n[root@localhost ~] vim /etc/redis6380.conf\n# 查找 /bind 找到：bind 127.0.0.1并注释，其它ip地址也可访问\n# bind 127.0.0.1\n# \n# 查找 /requirepass 去掉注释#，并把foobared 替换为密码，例如：password123456\n# requirepass foobared\nrequirepass password123456\n```\n\n2. 开启防火墙的端口号规则（安全组），将`6380`端口号开通\n\n``` bash\n[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 6380 -j ACCEPT\n```\n\n3. 修改完成后，要在服务里重启`Redis`服务才能使设置生效\n\n``` bash\n/usr/local/bin/redis-server /etc/redis6380.conf\n```\n\n4. 测试远程访问\n\n``` bash\nC:\\Users\\zc> redis-cli -h 192.168.111.226 -p 6380 -a password123456\n192.168.111.226:6380>\n```\n\n5. 停止`6380`的`Redis`服务也需要密码\n\n``` bash\n[root@localhost ~] redis-cli -p 6380 -a password123456 shutdown\n```\n\n\n\n### 2. MySQL多实例配置\n#### 2.1 查看主机MySQL信息\n1. 查看现有`MySQL`数据库实例占用端口\n\n``` bash\n[root@localhost ~] netstat -anp | grep mysqld\ntcp6       0      0 :::3306                 :::*                    LISTEN      1089/mysqld         \nunix  2      [ ACC ]     STREAM     LISTENING     20497    1089/mysqld          /var/lib/mysql/mysql.sock\n```\n\n> **须先关闭单实例，跟多实例会有冲突**\n> - 备份数据：`[root@localhost ~] mysqldump -P 3306 -u root -p --all-databases > /home/backup/data3306.bak`\n> - 停止单实例服务：`[root@localhost ~] service mysqld stop`\n\n2. 查找配置文件位置\n\n``` bash\n[root@localhost ~] locate my.cnf\n/etc/my.cnf\n/etc/my.cnf.d\n```\n\n#### 2.2 添加一个3307端口的实例\n1. 拷贝`my.cnf`并命名为`my3307.cnf`，并修改参数，主要修改port,sockt,datadir\n\n``` bash\n[root@localhost ~] cp /etc/my.cnf /etc/my3307.cnf\n[root@localhost ~] vi /etc/my3307.cnf\n[mysqld]\n# server端字符集\ncharacter-set-server=utf8\ncollation-server=utf8_general_ci\nuser=root\n# 修改端口\nport=3307\n# 修改数据存放目录\ndatadir=/var/lib/mysql3307\n# 客户端连接socket\nsocket=/var/lib/mysql/mysql3307.sock\n# 修改日志文件\nlog-error=/var/log/mysqld3307.log\n# 修改pid，每个实例需要运行在不同的pid\npid-file=/var/run/mysqld/mysqld3307.pid\n# 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated\nexplicit_defaults_for_timestamp=true\n# skip_grant_tables\n[mysql]\nsocket=/var/lib/mysql/mysql3307.sock\ndefault-character-set=utf8\n[mysql.server]\ndefault-character-set=utf8\n[mysql_safe]\ndefault-character-set=utf8\n[client]\nsocket=/var/lib/mysql/mysql3307.sock\ndefault-character-set=utf8\n```\n\n2. 初始化数据库\n\n``` bash\n# 写入host避免反解析报错\n[root@localhost ~] echo \"127.0.0.1   `hostname`\" >> /etc/hosts && cat /etc/hosts\n[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --initialize-insecure\n```\n\n3. 启动`3307`端口`MySQL`服务，并查看`MySQL`进程\n\n``` bash\n[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --user=root &\n```\n\n4. 登录`MySQL`\n\n``` bash\n# 多实例为root增加密码\n[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock password '123qwe'\n# 登录\n[root@localhost ~] mysql -S /var/lib/mysql/mysql3307.sock -p\n```\n\n5. 停止本实例`MySQL`服务\n\n``` bash\n[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock shutdown\n```\n\n\n#### 2.3 再添加一个3308端口的实例\n1. 拷贝`my.cnf`并命名为`my3308.cnf`，并修改参数，主要修改port,sockt,datadir\n\n``` bash\n[root@localhost ~] cp /etc/my.cnf /etc/my3308.cnf\n[root@localhost ~] vi /etc/my3308.cnf\n[mysqld]\n# server端字符集\ncharacter-set-server=utf8\ncollation-server=utf8_general_ci\nuser=root\n# 修改端口\nport=3308\n# 修改数据存放目录\ndatadir=/var/lib/mysql3308\n# 客户端连接socket\nsocket=/var/lib/mysql/mysql3308.sock\n# 修改日志文件\nlog-error=/var/log/mysqld3308.log\n# 修改pid，每个实例需要运行在不同的pid\npid-file=/var/run/mysqld/mysqld3308.pid\n# 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated\nexplicit_defaults_for_timestamp=true\n# skip_grant_tables\n[mysql]\nsocket=/var/lib/mysql/mysql3308.sock\ndefault-character-set=utf8\n[mysql.server]\ndefault-character-set=utf8\n[mysql_safe]\ndefault-character-set=utf8\n[client]\nsocket=/var/lib/mysql/mysql3308.sock\ndefault-character-set=utf8\n```\n\n2. 初始化数据库\n\n``` bash\n[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --initialize-insecure\n```\n\n3. 启动`3308`端口`MySQL`服务\n\n``` bash\n[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --user=root &\n```\n\n4. 登录`MySQL`\n\n``` bash\n# 多实例为root增加密码\n[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock password '123qwe'\n# 登录\n[root@localhost ~] mysql -S /var/lib/mysql/mysql3308.sock -p\n```\n\n5. 停止本实例`MySQL`服务\n\n``` bash\n[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock shutdown\n```\n\n\n#### 2.4 实例3307开启远程访问\n1. 开启`3307`端口防火墙\n\n``` bash\n[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 3307 -j ACCEPT\n```\n\n2. 测试远程访问\n\n``` bash\nC:\\Users\\zc>mysql -h 192.168.111.227 -P 3307 -u root -p\nEnter password: ******\n```\n\n","source":"_posts/【环境配置】Redis与MySQL多实例配置.md","raw":"---\ntitle: 【环境配置】Redis与MySQL多实例配置\ndate: 2020-02-11 23:08:46\ntags: 环境配置\ncategories: 环境配置\n---\n\n最近由于工作的需要，需要在同一台服务器上搭建两个`Redis`与`MySQL`的实例。\n多实例：就是在一台机器上面开启多个不同的端口(如`Redis`用`6379`/`6380`，`MySQL`用`3306`/`3307`等)，运行多个服务进程；公用一套安装程序，使用不同的配置文件，数据文件。\n<!-- more -->\n\n### 1. Redis多实例配置\n#### 1.1 查看主机Redis信息\n1. 用`ps`命令查看`Redis`进程\n\n``` bash\n[root@localhost ~] ps -ef |grep redis\nroot      1706     1  0  2019 ?        04:12:09 /usr/local/bin/redis-server *:6379                    \nroot     18174  2560  0 15:35 pts/0    00:00:00 grep redis\n```\n\n2. 查找配置文件位置\n\n``` bash\n[root@localhost ~] locate redis.conf\n/etc/redis.conf\n```\n\n#### 1.2 拷贝配置文件并修改\n1. 拷贝`redis.conf`并命名为`redis6380.conf`，并修改参数\n\n``` bash\n[root@localhost ~] cp /etc/redis.conf /etc/redis6380.conf\n[root@localhost ~] vim /etc/redis6380.conf\n# 查找 /pidfile 找到pid位置\n# pidfile /var/run/redis.pid        #修改pid，每个实例需要运行在不同的pid\npidfile /var/run/redis6380.pid\n# \n# 查找 /port 6379 找到端口位置\n# port 6379                         #修改端口\nport 6380\n#                      \n# 查找 /dir 找到数据目录位置\n# dir /mnt/newdatadrive/data/redis  #修改数据存放目录\ndir /mnt/newdatadrive/data/redis6380\n# \n# 已开启Redis持久化\nappendonly yes\n```\n\n2. 准备上面配置的文件\n\n``` bash\n[root@localhost ~] mkdir –p /mnt/newdatadrive/data/redis6380\n[root@localhost ~] cp /var/run/redis.pid /var/run/redis6380.pid\n```\n\n\n#### 1.3 启动测试\n1. 启动`6380`端口`Redis`服务，并查看`Redis`进程\n\n``` bash\n[root@localhost ~] /usr/local/bin/redis-server /etc/redis6380.conf\n[root@localhost ~] ps -ef |grep redis\nroot      1706     1  0  2019 ?        04:12:00 /usr/local/bin/redis-server *:6379         \nroot     15967     1  0 12:16 ?        00:00:00 /usr/local/bin/redis-server *:6380             \nroot     15994  8014  0 12:16 pts/2    00:00:00 grep redis\n```\n\n2. 测试登录`Redis`客户端\n\n``` bash\n[root@localhost ~] redis-cli -p 6380\n127.0.0.1:6380> QUIT     #退出\n```\n\n3. 停止`6380`端口的`Redis`服务\n\n``` bash\nredis-cli -p 6380 shutdown\n```\n\n\n#### 1.4 Redis数据迁移\n1. 登录原`Redis`客户端(`6379`)\n\n``` bash\n[root@localhost ~] redis-cli -p 6379\n127.0.0.1:6379> SAVE             #数据备份\n127.0.0.1:6379> CONFIG GET dir   #查看Redis数据目录\n1) \"dir\"\n2) \"/mnt/newdatadrive/data/redis\"\n127.0.0.1:6379> QUIT             #退出\n```\n\n2. 拷贝数据文件`appendonly.aof`和`dump.rdb`到`6380`\n\n``` bash\n# 查看6379的数据文件\n[root@localhost ~] cd /mnt/newdatadrive/data/redis && ll\ntotal 55176\n-rw-r--r-- 1 root root 55411226 Feb 11 09:25 appendonly.aof\n-rw-r--r-- 1 root root  1017181 Feb 11 12:28 dump.rdb\n# 拷贝到6380\n[root@localhost ~] \\cp /mnt/newdatadrive/data/redis/appendonly.aof /mnt/newdatadrive/data/redis6380/appendonly.aof\n[root@localhost ~] \\cp /mnt/newdatadrive/data/redis/dump.rdb /mnt/newdatadrive/data/redis6380/dump.rdb\n```\n\n3. 启动`6380`端口`Redis`服务，导入`AOF`数据文件\n\n``` bash\n[root@localhost ~] /usr/local/bin/redis-server /etc/redis6380.conf\n[root@localhost ~] redis-cli -p 6380 --pipe < /mnt/newdatadrive/data/redis6380/appendonly.aof\n```\n\n4. 登录`Redis`查看数据\n\n``` bash\n[root@localhost ~] redis-cli -p 6380\n127.0.0.1:6380>   #输入具体命令查看数据\n```\n\n#### 1.5 配置远程可访问\n1. 修改配置文件`redis6380.conf`\n\n``` bash\n[root@localhost ~] vim /etc/redis6380.conf\n# 查找 /bind 找到：bind 127.0.0.1并注释，其它ip地址也可访问\n# bind 127.0.0.1\n# \n# 查找 /requirepass 去掉注释#，并把foobared 替换为密码，例如：password123456\n# requirepass foobared\nrequirepass password123456\n```\n\n2. 开启防火墙的端口号规则（安全组），将`6380`端口号开通\n\n``` bash\n[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 6380 -j ACCEPT\n```\n\n3. 修改完成后，要在服务里重启`Redis`服务才能使设置生效\n\n``` bash\n/usr/local/bin/redis-server /etc/redis6380.conf\n```\n\n4. 测试远程访问\n\n``` bash\nC:\\Users\\zc> redis-cli -h 192.168.111.226 -p 6380 -a password123456\n192.168.111.226:6380>\n```\n\n5. 停止`6380`的`Redis`服务也需要密码\n\n``` bash\n[root@localhost ~] redis-cli -p 6380 -a password123456 shutdown\n```\n\n\n\n### 2. MySQL多实例配置\n#### 2.1 查看主机MySQL信息\n1. 查看现有`MySQL`数据库实例占用端口\n\n``` bash\n[root@localhost ~] netstat -anp | grep mysqld\ntcp6       0      0 :::3306                 :::*                    LISTEN      1089/mysqld         \nunix  2      [ ACC ]     STREAM     LISTENING     20497    1089/mysqld          /var/lib/mysql/mysql.sock\n```\n\n> **须先关闭单实例，跟多实例会有冲突**\n> - 备份数据：`[root@localhost ~] mysqldump -P 3306 -u root -p --all-databases > /home/backup/data3306.bak`\n> - 停止单实例服务：`[root@localhost ~] service mysqld stop`\n\n2. 查找配置文件位置\n\n``` bash\n[root@localhost ~] locate my.cnf\n/etc/my.cnf\n/etc/my.cnf.d\n```\n\n#### 2.2 添加一个3307端口的实例\n1. 拷贝`my.cnf`并命名为`my3307.cnf`，并修改参数，主要修改port,sockt,datadir\n\n``` bash\n[root@localhost ~] cp /etc/my.cnf /etc/my3307.cnf\n[root@localhost ~] vi /etc/my3307.cnf\n[mysqld]\n# server端字符集\ncharacter-set-server=utf8\ncollation-server=utf8_general_ci\nuser=root\n# 修改端口\nport=3307\n# 修改数据存放目录\ndatadir=/var/lib/mysql3307\n# 客户端连接socket\nsocket=/var/lib/mysql/mysql3307.sock\n# 修改日志文件\nlog-error=/var/log/mysqld3307.log\n# 修改pid，每个实例需要运行在不同的pid\npid-file=/var/run/mysqld/mysqld3307.pid\n# 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated\nexplicit_defaults_for_timestamp=true\n# skip_grant_tables\n[mysql]\nsocket=/var/lib/mysql/mysql3307.sock\ndefault-character-set=utf8\n[mysql.server]\ndefault-character-set=utf8\n[mysql_safe]\ndefault-character-set=utf8\n[client]\nsocket=/var/lib/mysql/mysql3307.sock\ndefault-character-set=utf8\n```\n\n2. 初始化数据库\n\n``` bash\n# 写入host避免反解析报错\n[root@localhost ~] echo \"127.0.0.1   `hostname`\" >> /etc/hosts && cat /etc/hosts\n[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --initialize-insecure\n```\n\n3. 启动`3307`端口`MySQL`服务，并查看`MySQL`进程\n\n``` bash\n[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --user=root &\n```\n\n4. 登录`MySQL`\n\n``` bash\n# 多实例为root增加密码\n[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock password '123qwe'\n# 登录\n[root@localhost ~] mysql -S /var/lib/mysql/mysql3307.sock -p\n```\n\n5. 停止本实例`MySQL`服务\n\n``` bash\n[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock shutdown\n```\n\n\n#### 2.3 再添加一个3308端口的实例\n1. 拷贝`my.cnf`并命名为`my3308.cnf`，并修改参数，主要修改port,sockt,datadir\n\n``` bash\n[root@localhost ~] cp /etc/my.cnf /etc/my3308.cnf\n[root@localhost ~] vi /etc/my3308.cnf\n[mysqld]\n# server端字符集\ncharacter-set-server=utf8\ncollation-server=utf8_general_ci\nuser=root\n# 修改端口\nport=3308\n# 修改数据存放目录\ndatadir=/var/lib/mysql3308\n# 客户端连接socket\nsocket=/var/lib/mysql/mysql3308.sock\n# 修改日志文件\nlog-error=/var/log/mysqld3308.log\n# 修改pid，每个实例需要运行在不同的pid\npid-file=/var/run/mysqld/mysqld3308.pid\n# 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated\nexplicit_defaults_for_timestamp=true\n# skip_grant_tables\n[mysql]\nsocket=/var/lib/mysql/mysql3308.sock\ndefault-character-set=utf8\n[mysql.server]\ndefault-character-set=utf8\n[mysql_safe]\ndefault-character-set=utf8\n[client]\nsocket=/var/lib/mysql/mysql3308.sock\ndefault-character-set=utf8\n```\n\n2. 初始化数据库\n\n``` bash\n[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --initialize-insecure\n```\n\n3. 启动`3308`端口`MySQL`服务\n\n``` bash\n[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --user=root &\n```\n\n4. 登录`MySQL`\n\n``` bash\n# 多实例为root增加密码\n[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock password '123qwe'\n# 登录\n[root@localhost ~] mysql -S /var/lib/mysql/mysql3308.sock -p\n```\n\n5. 停止本实例`MySQL`服务\n\n``` bash\n[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock shutdown\n```\n\n\n#### 2.4 实例3307开启远程访问\n1. 开启`3307`端口防火墙\n\n``` bash\n[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 3307 -j ACCEPT\n```\n\n2. 测试远程访问\n\n``` bash\nC:\\Users\\zc>mysql -h 192.168.111.227 -P 3307 -u root -p\nEnter password: ******\n```\n\n","slug":"【环境配置】Redis与MySQL多实例配置","published":1,"updated":"2021-12-12T02:50:23.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6vh000wvcuefbe21qri","content":"<p>最近由于工作的需要，需要在同一台服务器上搭建两个<code>Redis</code>与<code>MySQL</code>的实例。<br>多实例：就是在一台机器上面开启多个不同的端口(如<code>Redis</code>用<code>6379</code>/<code>6380</code>，<code>MySQL</code>用<code>3306</code>/<code>3307</code>等)，运行多个服务进程；公用一套安装程序，使用不同的配置文件，数据文件。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"1-Redis多实例配置\"><a href=\"#1-Redis多实例配置\" class=\"headerlink\" title=\"1. Redis多实例配置\"></a>1. Redis多实例配置</h3><h4 id=\"1-1-查看主机Redis信息\"><a href=\"#1-1-查看主机Redis信息\" class=\"headerlink\" title=\"1.1 查看主机Redis信息\"></a>1.1 查看主机Redis信息</h4><ol>\n<li>用<code>ps</code>命令查看<code>Redis</code>进程</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] ps -ef |grep redis</span><br><span class=\"line\">root      1706     1  0  2019 ?        04:12:09 /usr/<span class=\"built_in\">local</span>/bin/redis-server *:6379                    </span><br><span class=\"line\">root     18174  2560  0 15:35 pts/0    00:00:00 grep redis</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>查找配置文件位置</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] locate redis.conf</span><br><span class=\"line\">/etc/redis.conf</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-拷贝配置文件并修改\"><a href=\"#1-2-拷贝配置文件并修改\" class=\"headerlink\" title=\"1.2 拷贝配置文件并修改\"></a>1.2 拷贝配置文件并修改</h4><ol>\n<li>拷贝<code>redis.conf</code>并命名为<code>redis6380.conf</code>，并修改参数</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] cp /etc/redis.conf /etc/redis6380.conf</span><br><span class=\"line\">[root@localhost ~] vim /etc/redis6380.conf</span><br><span class=\"line\"><span class=\"comment\"># 查找 /pidfile 找到pid位置</span></span><br><span class=\"line\"><span class=\"comment\"># pidfile /var/run/redis.pid        #修改pid，每个实例需要运行在不同的pid</span></span><br><span class=\"line\">pidfile /var/run/redis6380.pid</span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># 查找 /port 6379 找到端口位置</span></span><br><span class=\"line\"><span class=\"comment\"># port 6379                         #修改端口</span></span><br><span class=\"line\">port 6380</span><br><span class=\"line\"><span class=\"comment\">#                      </span></span><br><span class=\"line\"><span class=\"comment\"># 查找 /dir 找到数据目录位置</span></span><br><span class=\"line\"><span class=\"comment\"># dir /mnt/newdatadrive/data/redis  #修改数据存放目录</span></span><br><span class=\"line\">dir /mnt/newdatadrive/data/redis6380</span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># 已开启Redis持久化</span></span><br><span class=\"line\">appendonly yes</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>准备上面配置的文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mkdir –p /mnt/newdatadrive/data/redis6380</span><br><span class=\"line\">[root@localhost ~] cp /var/run/redis.pid /var/run/redis6380.pid</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"1-3-启动测试\"><a href=\"#1-3-启动测试\" class=\"headerlink\" title=\"1.3 启动测试\"></a>1.3 启动测试</h4><ol>\n<li>启动<code>6380</code>端口<code>Redis</code>服务，并查看<code>Redis</code>进程</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] /usr/<span class=\"built_in\">local</span>/bin/redis-server /etc/redis6380.conf</span><br><span class=\"line\">[root@localhost ~] ps -ef |grep redis</span><br><span class=\"line\">root      1706     1  0  2019 ?        04:12:00 /usr/<span class=\"built_in\">local</span>/bin/redis-server *:6379         </span><br><span class=\"line\">root     15967     1  0 12:16 ?        00:00:00 /usr/<span class=\"built_in\">local</span>/bin/redis-server *:6380             </span><br><span class=\"line\">root     15994  8014  0 12:16 pts/2    00:00:00 grep redis</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>测试登录<code>Redis</code>客户端</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] redis-cli -p 6380</span><br><span class=\"line\">127.0.0.1:6380&gt; QUIT     <span class=\"comment\">#退出</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>停止<code>6380</code>端口的<code>Redis</code>服务</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -p 6380 shutdown</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"1-4-Redis数据迁移\"><a href=\"#1-4-Redis数据迁移\" class=\"headerlink\" title=\"1.4 Redis数据迁移\"></a>1.4 Redis数据迁移</h4><ol>\n<li>登录原<code>Redis</code>客户端(<code>6379</code>)</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] redis-cli -p 6379</span><br><span class=\"line\">127.0.0.1:6379&gt; SAVE             <span class=\"comment\">#数据备份</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CONFIG GET dir   <span class=\"comment\">#查看Redis数据目录</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;dir&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;/mnt/newdatadrive/data/redis&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; QUIT             <span class=\"comment\">#退出</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>拷贝数据文件<code>appendonly.aof</code>和<code>dump.rdb</code>到<code>6380</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看6379的数据文件</span></span><br><span class=\"line\">[root@localhost ~] <span class=\"built_in\">cd</span> /mnt/newdatadrive/data/redis &amp;&amp; ll</span><br><span class=\"line\">total 55176</span><br><span class=\"line\">-rw-r--r-- 1 root root 55411226 Feb 11 09:25 appendonly.aof</span><br><span class=\"line\">-rw-r--r-- 1 root root  1017181 Feb 11 12:28 dump.rdb</span><br><span class=\"line\"><span class=\"comment\"># 拷贝到6380</span></span><br><span class=\"line\">[root@localhost ~] \\cp /mnt/newdatadrive/data/redis/appendonly.aof /mnt/newdatadrive/data/redis6380/appendonly.aof</span><br><span class=\"line\">[root@localhost ~] \\cp /mnt/newdatadrive/data/redis/dump.rdb /mnt/newdatadrive/data/redis6380/dump.rdb</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动<code>6380</code>端口<code>Redis</code>服务，导入<code>AOF</code>数据文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] /usr/<span class=\"built_in\">local</span>/bin/redis-server /etc/redis6380.conf</span><br><span class=\"line\">[root@localhost ~] redis-cli -p 6380 --pipe &lt; /mnt/newdatadrive/data/redis6380/appendonly.aof</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>登录<code>Redis</code>查看数据</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] redis-cli -p 6380</span><br><span class=\"line\">127.0.0.1:6380&gt;   <span class=\"comment\">#输入具体命令查看数据</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-5-配置远程可访问\"><a href=\"#1-5-配置远程可访问\" class=\"headerlink\" title=\"1.5 配置远程可访问\"></a>1.5 配置远程可访问</h4><ol>\n<li>修改配置文件<code>redis6380.conf</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] vim /etc/redis6380.conf</span><br><span class=\"line\"><span class=\"comment\"># 查找 /bind 找到：bind 127.0.0.1并注释，其它ip地址也可访问</span></span><br><span class=\"line\"><span class=\"comment\"># bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># 查找 /requirepass 去掉注释#，并把foobared 替换为密码，例如：password123456</span></span><br><span class=\"line\"><span class=\"comment\"># requirepass foobared</span></span><br><span class=\"line\">requirepass password123456</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>开启防火墙的端口号规则（安全组），将<code>6380</code>端口号开通</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 6380 -j ACCEPT</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改完成后，要在服务里重启<code>Redis</code>服务才能使设置生效</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/<span class=\"built_in\">local</span>/bin/redis-server /etc/redis6380.conf</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>测试远程访问</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\zc&gt; redis-cli -h 192.168.111.226 -p 6380 -a password123456</span><br><span class=\"line\">192.168.111.226:6380&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>停止<code>6380</code>的<code>Redis</code>服务也需要密码</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] redis-cli -p 6380 -a password123456 shutdown</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-MySQL多实例配置\"><a href=\"#2-MySQL多实例配置\" class=\"headerlink\" title=\"2. MySQL多实例配置\"></a>2. MySQL多实例配置</h3><h4 id=\"2-1-查看主机MySQL信息\"><a href=\"#2-1-查看主机MySQL信息\" class=\"headerlink\" title=\"2.1 查看主机MySQL信息\"></a>2.1 查看主机MySQL信息</h4><ol>\n<li>查看现有<code>MySQL</code>数据库实例占用端口</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] netstat -anp | grep mysqld</span><br><span class=\"line\">tcp6       0      0 :::3306                 :::*                    LISTEN      1089/mysqld         </span><br><span class=\"line\">unix  2      [ ACC ]     STREAM     LISTENING     20497    1089/mysqld          /var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>须先关闭单实例，跟多实例会有冲突</strong></p>\n<ul>\n<li>备份数据：<code>[root@localhost ~] mysqldump -P 3306 -u root -p --all-databases &gt; /home/backup/data3306.bak</code></li>\n<li>停止单实例服务：<code>[root@localhost ~] service mysqld stop</code></li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li>查找配置文件位置</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] locate my.cnf</span><br><span class=\"line\">/etc/my.cnf</span><br><span class=\"line\">/etc/my.cnf.d</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-添加一个3307端口的实例\"><a href=\"#2-2-添加一个3307端口的实例\" class=\"headerlink\" title=\"2.2 添加一个3307端口的实例\"></a>2.2 添加一个3307端口的实例</h4><ol>\n<li>拷贝<code>my.cnf</code>并命名为<code>my3307.cnf</code>，并修改参数，主要修改port,sockt,datadir</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] cp /etc/my.cnf /etc/my3307.cnf</span><br><span class=\"line\">[root@localhost ~] vi /etc/my3307.cnf</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"comment\"># server端字符集</span></span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">collation-server=utf8_general_ci</span><br><span class=\"line\">user=root</span><br><span class=\"line\"><span class=\"comment\"># 修改端口</span></span><br><span class=\"line\">port=3307</span><br><span class=\"line\"><span class=\"comment\"># 修改数据存放目录</span></span><br><span class=\"line\">datadir=/var/lib/mysql3307</span><br><span class=\"line\"><span class=\"comment\"># 客户端连接socket</span></span><br><span class=\"line\">socket=/var/lib/mysql/mysql3307.sock</span><br><span class=\"line\"><span class=\"comment\"># 修改日志文件</span></span><br><span class=\"line\">log-error=/var/<span class=\"built_in\">log</span>/mysqld3307.log</span><br><span class=\"line\"><span class=\"comment\"># 修改pid，每个实例需要运行在不同的pid</span></span><br><span class=\"line\">pid-file=/var/run/mysqld/mysqld3307.pid</span><br><span class=\"line\"><span class=\"comment\"># 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated</span></span><br><span class=\"line\">explicit_defaults_for_timestamp=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># skip_grant_tables</span></span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">socket=/var/lib/mysql/mysql3307.sock</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql.server]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql_safe]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[client]</span><br><span class=\"line\">socket=/var/lib/mysql/mysql3307.sock</span><br><span class=\"line\">default-character-set=utf8</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>初始化数据库</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入host避免反解析报错</span></span><br><span class=\"line\">[root@localhost ~] <span class=\"built_in\">echo</span> <span class=\"string\">&quot;127.0.0.1   `hostname`&quot;</span> &gt;&gt; /etc/hosts &amp;&amp; cat /etc/hosts</span><br><span class=\"line\">[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --initialize-insecure</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动<code>3307</code>端口<code>MySQL</code>服务，并查看<code>MySQL</code>进程</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --user=root &amp;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>登录<code>MySQL</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多实例为root增加密码</span></span><br><span class=\"line\">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock password <span class=\"string\">&#x27;123qwe&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 登录</span></span><br><span class=\"line\">[root@localhost ~] mysql -S /var/lib/mysql/mysql3307.sock -p</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>停止本实例<code>MySQL</code>服务</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock shutdown</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-3-再添加一个3308端口的实例\"><a href=\"#2-3-再添加一个3308端口的实例\" class=\"headerlink\" title=\"2.3 再添加一个3308端口的实例\"></a>2.3 再添加一个3308端口的实例</h4><ol>\n<li>拷贝<code>my.cnf</code>并命名为<code>my3308.cnf</code>，并修改参数，主要修改port,sockt,datadir</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] cp /etc/my.cnf /etc/my3308.cnf</span><br><span class=\"line\">[root@localhost ~] vi /etc/my3308.cnf</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"comment\"># server端字符集</span></span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">collation-server=utf8_general_ci</span><br><span class=\"line\">user=root</span><br><span class=\"line\"><span class=\"comment\"># 修改端口</span></span><br><span class=\"line\">port=3308</span><br><span class=\"line\"><span class=\"comment\"># 修改数据存放目录</span></span><br><span class=\"line\">datadir=/var/lib/mysql3308</span><br><span class=\"line\"><span class=\"comment\"># 客户端连接socket</span></span><br><span class=\"line\">socket=/var/lib/mysql/mysql3308.sock</span><br><span class=\"line\"><span class=\"comment\"># 修改日志文件</span></span><br><span class=\"line\">log-error=/var/<span class=\"built_in\">log</span>/mysqld3308.log</span><br><span class=\"line\"><span class=\"comment\"># 修改pid，每个实例需要运行在不同的pid</span></span><br><span class=\"line\">pid-file=/var/run/mysqld/mysqld3308.pid</span><br><span class=\"line\"><span class=\"comment\"># 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated</span></span><br><span class=\"line\">explicit_defaults_for_timestamp=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># skip_grant_tables</span></span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">socket=/var/lib/mysql/mysql3308.sock</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql.server]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql_safe]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[client]</span><br><span class=\"line\">socket=/var/lib/mysql/mysql3308.sock</span><br><span class=\"line\">default-character-set=utf8</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>初始化数据库</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --initialize-insecure</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动<code>3308</code>端口<code>MySQL</code>服务</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --user=root &amp;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>登录<code>MySQL</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多实例为root增加密码</span></span><br><span class=\"line\">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock password <span class=\"string\">&#x27;123qwe&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 登录</span></span><br><span class=\"line\">[root@localhost ~] mysql -S /var/lib/mysql/mysql3308.sock -p</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>停止本实例<code>MySQL</code>服务</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock shutdown</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-4-实例3307开启远程访问\"><a href=\"#2-4-实例3307开启远程访问\" class=\"headerlink\" title=\"2.4 实例3307开启远程访问\"></a>2.4 实例3307开启远程访问</h4><ol>\n<li>开启<code>3307</code>端口防火墙</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 3307 -j ACCEPT</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>测试远程访问</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\zc&gt;mysql -h 192.168.111.227 -P 3307 -u root -p</span><br><span class=\"line\">Enter password: ******</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<p>最近由于工作的需要，需要在同一台服务器上搭建两个<code>Redis</code>与<code>MySQL</code>的实例。<br>多实例：就是在一台机器上面开启多个不同的端口(如<code>Redis</code>用<code>6379</code>/<code>6380</code>，<code>MySQL</code>用<code>3306</code>/<code>3307</code>等)，运行多个服务进程；公用一套安装程序，使用不同的配置文件，数据文件。</p>","more":"<h3 id=\"1-Redis多实例配置\"><a href=\"#1-Redis多实例配置\" class=\"headerlink\" title=\"1. Redis多实例配置\"></a>1. Redis多实例配置</h3><h4 id=\"1-1-查看主机Redis信息\"><a href=\"#1-1-查看主机Redis信息\" class=\"headerlink\" title=\"1.1 查看主机Redis信息\"></a>1.1 查看主机Redis信息</h4><ol>\n<li>用<code>ps</code>命令查看<code>Redis</code>进程</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] ps -ef |grep redis</span><br><span class=\"line\">root      1706     1  0  2019 ?        04:12:09 /usr/<span class=\"built_in\">local</span>/bin/redis-server *:6379                    </span><br><span class=\"line\">root     18174  2560  0 15:35 pts/0    00:00:00 grep redis</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>查找配置文件位置</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] locate redis.conf</span><br><span class=\"line\">/etc/redis.conf</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-拷贝配置文件并修改\"><a href=\"#1-2-拷贝配置文件并修改\" class=\"headerlink\" title=\"1.2 拷贝配置文件并修改\"></a>1.2 拷贝配置文件并修改</h4><ol>\n<li>拷贝<code>redis.conf</code>并命名为<code>redis6380.conf</code>，并修改参数</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] cp /etc/redis.conf /etc/redis6380.conf</span><br><span class=\"line\">[root@localhost ~] vim /etc/redis6380.conf</span><br><span class=\"line\"><span class=\"comment\"># 查找 /pidfile 找到pid位置</span></span><br><span class=\"line\"><span class=\"comment\"># pidfile /var/run/redis.pid        #修改pid，每个实例需要运行在不同的pid</span></span><br><span class=\"line\">pidfile /var/run/redis6380.pid</span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># 查找 /port 6379 找到端口位置</span></span><br><span class=\"line\"><span class=\"comment\"># port 6379                         #修改端口</span></span><br><span class=\"line\">port 6380</span><br><span class=\"line\"><span class=\"comment\">#                      </span></span><br><span class=\"line\"><span class=\"comment\"># 查找 /dir 找到数据目录位置</span></span><br><span class=\"line\"><span class=\"comment\"># dir /mnt/newdatadrive/data/redis  #修改数据存放目录</span></span><br><span class=\"line\">dir /mnt/newdatadrive/data/redis6380</span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># 已开启Redis持久化</span></span><br><span class=\"line\">appendonly yes</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>准备上面配置的文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mkdir –p /mnt/newdatadrive/data/redis6380</span><br><span class=\"line\">[root@localhost ~] cp /var/run/redis.pid /var/run/redis6380.pid</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"1-3-启动测试\"><a href=\"#1-3-启动测试\" class=\"headerlink\" title=\"1.3 启动测试\"></a>1.3 启动测试</h4><ol>\n<li>启动<code>6380</code>端口<code>Redis</code>服务，并查看<code>Redis</code>进程</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] /usr/<span class=\"built_in\">local</span>/bin/redis-server /etc/redis6380.conf</span><br><span class=\"line\">[root@localhost ~] ps -ef |grep redis</span><br><span class=\"line\">root      1706     1  0  2019 ?        04:12:00 /usr/<span class=\"built_in\">local</span>/bin/redis-server *:6379         </span><br><span class=\"line\">root     15967     1  0 12:16 ?        00:00:00 /usr/<span class=\"built_in\">local</span>/bin/redis-server *:6380             </span><br><span class=\"line\">root     15994  8014  0 12:16 pts/2    00:00:00 grep redis</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>测试登录<code>Redis</code>客户端</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] redis-cli -p 6380</span><br><span class=\"line\">127.0.0.1:6380&gt; QUIT     <span class=\"comment\">#退出</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>停止<code>6380</code>端口的<code>Redis</code>服务</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -p 6380 shutdown</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"1-4-Redis数据迁移\"><a href=\"#1-4-Redis数据迁移\" class=\"headerlink\" title=\"1.4 Redis数据迁移\"></a>1.4 Redis数据迁移</h4><ol>\n<li>登录原<code>Redis</code>客户端(<code>6379</code>)</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] redis-cli -p 6379</span><br><span class=\"line\">127.0.0.1:6379&gt; SAVE             <span class=\"comment\">#数据备份</span></span><br><span class=\"line\">127.0.0.1:6379&gt; CONFIG GET dir   <span class=\"comment\">#查看Redis数据目录</span></span><br><span class=\"line\">1) <span class=\"string\">&quot;dir&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;/mnt/newdatadrive/data/redis&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; QUIT             <span class=\"comment\">#退出</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>拷贝数据文件<code>appendonly.aof</code>和<code>dump.rdb</code>到<code>6380</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看6379的数据文件</span></span><br><span class=\"line\">[root@localhost ~] <span class=\"built_in\">cd</span> /mnt/newdatadrive/data/redis &amp;&amp; ll</span><br><span class=\"line\">total 55176</span><br><span class=\"line\">-rw-r--r-- 1 root root 55411226 Feb 11 09:25 appendonly.aof</span><br><span class=\"line\">-rw-r--r-- 1 root root  1017181 Feb 11 12:28 dump.rdb</span><br><span class=\"line\"><span class=\"comment\"># 拷贝到6380</span></span><br><span class=\"line\">[root@localhost ~] \\cp /mnt/newdatadrive/data/redis/appendonly.aof /mnt/newdatadrive/data/redis6380/appendonly.aof</span><br><span class=\"line\">[root@localhost ~] \\cp /mnt/newdatadrive/data/redis/dump.rdb /mnt/newdatadrive/data/redis6380/dump.rdb</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动<code>6380</code>端口<code>Redis</code>服务，导入<code>AOF</code>数据文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] /usr/<span class=\"built_in\">local</span>/bin/redis-server /etc/redis6380.conf</span><br><span class=\"line\">[root@localhost ~] redis-cli -p 6380 --pipe &lt; /mnt/newdatadrive/data/redis6380/appendonly.aof</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>登录<code>Redis</code>查看数据</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] redis-cli -p 6380</span><br><span class=\"line\">127.0.0.1:6380&gt;   <span class=\"comment\">#输入具体命令查看数据</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-5-配置远程可访问\"><a href=\"#1-5-配置远程可访问\" class=\"headerlink\" title=\"1.5 配置远程可访问\"></a>1.5 配置远程可访问</h4><ol>\n<li>修改配置文件<code>redis6380.conf</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] vim /etc/redis6380.conf</span><br><span class=\"line\"><span class=\"comment\"># 查找 /bind 找到：bind 127.0.0.1并注释，其它ip地址也可访问</span></span><br><span class=\"line\"><span class=\"comment\"># bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># 查找 /requirepass 去掉注释#，并把foobared 替换为密码，例如：password123456</span></span><br><span class=\"line\"><span class=\"comment\"># requirepass foobared</span></span><br><span class=\"line\">requirepass password123456</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>开启防火墙的端口号规则（安全组），将<code>6380</code>端口号开通</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 6380 -j ACCEPT</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改完成后，要在服务里重启<code>Redis</code>服务才能使设置生效</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/<span class=\"built_in\">local</span>/bin/redis-server /etc/redis6380.conf</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>测试远程访问</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\zc&gt; redis-cli -h 192.168.111.226 -p 6380 -a password123456</span><br><span class=\"line\">192.168.111.226:6380&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>停止<code>6380</code>的<code>Redis</code>服务也需要密码</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] redis-cli -p 6380 -a password123456 shutdown</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-MySQL多实例配置\"><a href=\"#2-MySQL多实例配置\" class=\"headerlink\" title=\"2. MySQL多实例配置\"></a>2. MySQL多实例配置</h3><h4 id=\"2-1-查看主机MySQL信息\"><a href=\"#2-1-查看主机MySQL信息\" class=\"headerlink\" title=\"2.1 查看主机MySQL信息\"></a>2.1 查看主机MySQL信息</h4><ol>\n<li>查看现有<code>MySQL</code>数据库实例占用端口</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] netstat -anp | grep mysqld</span><br><span class=\"line\">tcp6       0      0 :::3306                 :::*                    LISTEN      1089/mysqld         </span><br><span class=\"line\">unix  2      [ ACC ]     STREAM     LISTENING     20497    1089/mysqld          /var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>须先关闭单实例，跟多实例会有冲突</strong></p>\n<ul>\n<li>备份数据：<code>[root@localhost ~] mysqldump -P 3306 -u root -p --all-databases &gt; /home/backup/data3306.bak</code></li>\n<li>停止单实例服务：<code>[root@localhost ~] service mysqld stop</code></li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li>查找配置文件位置</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] locate my.cnf</span><br><span class=\"line\">/etc/my.cnf</span><br><span class=\"line\">/etc/my.cnf.d</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-添加一个3307端口的实例\"><a href=\"#2-2-添加一个3307端口的实例\" class=\"headerlink\" title=\"2.2 添加一个3307端口的实例\"></a>2.2 添加一个3307端口的实例</h4><ol>\n<li>拷贝<code>my.cnf</code>并命名为<code>my3307.cnf</code>，并修改参数，主要修改port,sockt,datadir</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] cp /etc/my.cnf /etc/my3307.cnf</span><br><span class=\"line\">[root@localhost ~] vi /etc/my3307.cnf</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"comment\"># server端字符集</span></span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">collation-server=utf8_general_ci</span><br><span class=\"line\">user=root</span><br><span class=\"line\"><span class=\"comment\"># 修改端口</span></span><br><span class=\"line\">port=3307</span><br><span class=\"line\"><span class=\"comment\"># 修改数据存放目录</span></span><br><span class=\"line\">datadir=/var/lib/mysql3307</span><br><span class=\"line\"><span class=\"comment\"># 客户端连接socket</span></span><br><span class=\"line\">socket=/var/lib/mysql/mysql3307.sock</span><br><span class=\"line\"><span class=\"comment\"># 修改日志文件</span></span><br><span class=\"line\">log-error=/var/<span class=\"built_in\">log</span>/mysqld3307.log</span><br><span class=\"line\"><span class=\"comment\"># 修改pid，每个实例需要运行在不同的pid</span></span><br><span class=\"line\">pid-file=/var/run/mysqld/mysqld3307.pid</span><br><span class=\"line\"><span class=\"comment\"># 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated</span></span><br><span class=\"line\">explicit_defaults_for_timestamp=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># skip_grant_tables</span></span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">socket=/var/lib/mysql/mysql3307.sock</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql.server]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql_safe]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[client]</span><br><span class=\"line\">socket=/var/lib/mysql/mysql3307.sock</span><br><span class=\"line\">default-character-set=utf8</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>初始化数据库</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 写入host避免反解析报错</span></span><br><span class=\"line\">[root@localhost ~] <span class=\"built_in\">echo</span> <span class=\"string\">&quot;127.0.0.1   `hostname`&quot;</span> &gt;&gt; /etc/hosts &amp;&amp; cat /etc/hosts</span><br><span class=\"line\">[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --initialize-insecure</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动<code>3307</code>端口<code>MySQL</code>服务，并查看<code>MySQL</code>进程</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --user=root &amp;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>登录<code>MySQL</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多实例为root增加密码</span></span><br><span class=\"line\">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock password <span class=\"string\">&#x27;123qwe&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 登录</span></span><br><span class=\"line\">[root@localhost ~] mysql -S /var/lib/mysql/mysql3307.sock -p</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>停止本实例<code>MySQL</code>服务</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock shutdown</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-3-再添加一个3308端口的实例\"><a href=\"#2-3-再添加一个3308端口的实例\" class=\"headerlink\" title=\"2.3 再添加一个3308端口的实例\"></a>2.3 再添加一个3308端口的实例</h4><ol>\n<li>拷贝<code>my.cnf</code>并命名为<code>my3308.cnf</code>，并修改参数，主要修改port,sockt,datadir</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] cp /etc/my.cnf /etc/my3308.cnf</span><br><span class=\"line\">[root@localhost ~] vi /etc/my3308.cnf</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"comment\"># server端字符集</span></span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">collation-server=utf8_general_ci</span><br><span class=\"line\">user=root</span><br><span class=\"line\"><span class=\"comment\"># 修改端口</span></span><br><span class=\"line\">port=3308</span><br><span class=\"line\"><span class=\"comment\"># 修改数据存放目录</span></span><br><span class=\"line\">datadir=/var/lib/mysql3308</span><br><span class=\"line\"><span class=\"comment\"># 客户端连接socket</span></span><br><span class=\"line\">socket=/var/lib/mysql/mysql3308.sock</span><br><span class=\"line\"><span class=\"comment\"># 修改日志文件</span></span><br><span class=\"line\">log-error=/var/<span class=\"built_in\">log</span>/mysqld3308.log</span><br><span class=\"line\"><span class=\"comment\"># 修改pid，每个实例需要运行在不同的pid</span></span><br><span class=\"line\">pid-file=/var/run/mysqld/mysqld3308.pid</span><br><span class=\"line\"><span class=\"comment\"># 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated</span></span><br><span class=\"line\">explicit_defaults_for_timestamp=<span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># skip_grant_tables</span></span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">socket=/var/lib/mysql/mysql3308.sock</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql.server]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql_safe]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[client]</span><br><span class=\"line\">socket=/var/lib/mysql/mysql3308.sock</span><br><span class=\"line\">default-character-set=utf8</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>初始化数据库</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --initialize-insecure</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动<code>3308</code>端口<code>MySQL</code>服务</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --user=root &amp;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>登录<code>MySQL</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多实例为root增加密码</span></span><br><span class=\"line\">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock password <span class=\"string\">&#x27;123qwe&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 登录</span></span><br><span class=\"line\">[root@localhost ~] mysql -S /var/lib/mysql/mysql3308.sock -p</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>停止本实例<code>MySQL</code>服务</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock shutdown</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-4-实例3307开启远程访问\"><a href=\"#2-4-实例3307开启远程访问\" class=\"headerlink\" title=\"2.4 实例3307开启远程访问\"></a>2.4 实例3307开启远程访问</h4><ol>\n<li>开启<code>3307</code>端口防火墙</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 3307 -j ACCEPT</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>测试远程访问</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\zc&gt;mysql -h 192.168.111.227 -P 3307 -u root -p</span><br><span class=\"line\">Enter password: ******</span><br></pre></td></tr></table></figure>"},{"title":"【数据库】嵌入式SQL语言","date":"2019-07-16T06:32:28.000Z","_content":"\n### 概述\n* 交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，\n* 然而，交互式SQL本身也有很多局限：<!-- more -->\n    + 从使用者角度：专业人员可熟练写出SQL语句，但大部分的普通用户并非可以\n    + 从SQL本身角度：特别复杂的检索结果难以用一条交互式SQL语句完成，此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理\n* 因此，高级语言+SQL语言：\n    + 既继承高级语言的过程控制性\n    + 又结合SQL语言的复杂结果集操作的非过程性\n    + 同时又为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作\n* 嵌入式SQL语言\n    + 将SQL语言嵌入到某一种高级语言中使用\n    + 这种高级语言，如C/C++, Java, PowerBuilder等，又称宿主语言(Host Language)\n    + 嵌入在宿主语言中的SQL与前面介绍的交互式SQL有一些不同的操作方式\n\n\n#### 目录：\n1. [变量声明与数据库连接](#id1)\n2. [事务Transaction](#id2)\n3. [数据集与游标](#id3)\n4. [状态捕获及错误处理机制](#id4)\n5. [动态SQL](#id5)\n6. [数据字典与SQLDA](#id6)\n7. [ODBC简介](#id7)\n8. [JDBC简介](#id8)\n9. [嵌入式SQL-ODBC-JDBC三者比较](#id9)\n\n\n<span id=\"id1\"><span>\n### 1. 变量声明与数据库连接\n1. 以宿主语言**C语言**为例，对比交互式SQL语言与嵌入式SQL语言\n    + 交互式SQL:`select Sname, Sage from Student where Sname='张三';`\n    + 嵌入式SQL:`exec sql select Sname, Sage into :vSname, :vSage from Student where Sname='张三';`\n2. 典型特点\n    + **exec sql**引导SQL语句: 提供给C编译器，以便对SQL语句预编译成C编译器可识别的语句\n    + 增加一 **into子句**: 该子句用于指出接收SQL语句检索结果的程序变量\n    + 由冒号引导的**程序变量**,如: ‘:vSname’, ‘:vSage’\n\n#### 1.1 变量的声明与使用\n* 在嵌入式SQL语句中可以出现宿主语言语句所使用的变量，这些变量需要特殊的声明：\n``` sql\nexec sql begin declare section;\n    char vSname[10], specName[10]=\"张三\";\n    int vSage;\nexec sql end declare section;\n```\n* 变量声明和赋值中，要注意：\n    + 宿主程序的字符串变量长度应比字符型字段的长度多1个。因宿主程序的字符串尾部多一个终止符为'\\0'，而程序中用双引号来描述。\n    + 宿主程序变量类型与数据库字段类型之间有些是有差异的,有些DBMS可支持自动转换，有些不能。\n* 声明的变量，可以在宿主程序中赋值，然后传递给SQL语句的where等子句中，以使SQL语句能够按照指定的要求(可变化的)进行检索。\n* 嵌入式比交互式SQL语句灵活了一些：只需改一下变量值，SQL语句便可反复使用，以检索出不同结果。\n* 示例：\n``` sql\nexec sql begin declare section;\n    char vSname[10], specName[10]=\"张三\";\n    int vSage;\nexec sql end declare section;\n//用户可在此处基于键盘输入给specName赋值\nexec sql select Sname, Sage into :vSname, :vSage from Student where Sname = :specName;\n//比较相应的交互式SQL语句：\nselect Sname, Sage from Student where Sname = '张三';\n```\n\n\n#### 1.2 程序与数据库的连接和断开\n##### 1.2.1 数据库的连接connect\n在嵌入式SQL程序执行之前，首先要与数据库进行连接, 不同DBMS，具体连接语句的语法略有差异\n1. SQL标准中建议的连接语法为：\n    + `execsql connecttotarget-server asconnect-name useruser-name;`\n    + 或 `execsql connecttodefault;`\n2. Oracle中数据库连接:\n    + `execsql connect:user_name identified by :user_pwd;`\n3. DB2 UDB中数据库连接:\n    + `execsql connecttomydb user:user_name using:user_pwd;`\n\n##### 1.2.1 数据库的断开disconnect\n在嵌入式SQL程序执行之后，需要与数据库断开连接\n1. SQL标准中建议的断开连接的语法为：\n    + `exec sql disconnect connect-name;`\n    + 或 `exec sql disconnect current;`\n2. Oracle中断开连接:\n    + `exec sql commit release;`\n    + 或 `exec sql rollback release;`\n3. DB2 UDB中断开连接:\n    + `exec sql connect reset;`\n    + `exec sql disconnect current;`\n\n#### 1.3 SQL执行的提交与撤消\nSQL语句在执行过程中，必须有提交和撤消语句才能确认其操作结果\n1. SQL执行的提交：\n    + `execsql commitwork;`\n2. SQL执行的撤消：\n    + `execsql rollbackwork;`\n3. 为此，很多DBMS都设计了捆绑提交/撤消与断开连接在一起的语句,以保证在断开连接之前使用户确认提交或撤消先前的工作，例如Oracle中：\n    + `execsql commitrelease;`\n    + 或 `execsql rollbackrelease;`\n\n\n<span id=\"id2\"><span>\n### 2. 事务Transaction\n1. 从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务\n2. 从微观角度，或者从DBMS角度：事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。\n3. 简单来说：事务是作为单个逻辑工作单元执行的一系列操作；多个操作作为一个整体向系统提交，要么都执行，要么都不执行；**事务是一个不可分割的工作逻辑单元**。\n\n#### 2.1 事务的特性: ACID\n1. **原子性**Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对DB而言，要么都执行，要么都不执行\n2. **一致性**Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作规则，它是进一步由隔离性来保证的\n3. **隔离性**Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;或者先执行了T2, 再执行T1。\n4. **持久性**Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的。\n\n> 换句话说：具有ACID特性的若干数据库基本操作的组合体被称为事务。\n\n\n<span id=\"id3\"><span>\n### 3. 数据集与游标\n读取单行结果处理与多行结果处理的差异：Into子句与游标(Cursor)\n1. 检索单行结果，可将结果直接传送到宿主程序的变量中(Into)\n    + 示例：`exec sql select Sname,Sage into :vSname,:vSage from Student where Sname = :specName;`\n2. 检索多行结果，则需使用游标(Cursor)\n    + 游标是指向某检索记录集的指针\n    + 通过这个指针的移动，每次读一行，处理一行，再读一行… , 直至处理完毕\n    + 读一行操作是通过Fetch…into语句实现的：每一次Fetch, 都是先向下移动指针，然后再读取\n    + 记录集有结束标识EOF, 用来标记后面已没有记录了\n* 游标(Cursor)的使用需要先定义、再打开(执行)、接着一条接一条处理，最后再关闭\n* 游标可以定义一次，多次打开(多次执行)，多次关闭\n\n#### 3.1 游标的使用方法\n1. Cursor的定义：declare cursor\n``` sql\nEXEC SQL DECLARE cursor_name CURSOR FOR\n    Subquery\n    [ORDER BY result_column [ASC | DESC][, result_column …]\n    [FOR [ READ ONLY | UPDATE [OF columnname [, columnname…]]]];\n//示例:\nexec sql declare cur_student cursor for\n    select Sno, Sname, Sclass from Student where Sclass= :vClass\n    order by Sno\n    for read only ;\n```\n\n2. Cursor的打开和关闭：open cursor //close cursor\n    + EXEC SQL OPEN cursor_name;\n    + EXEC SQL CLOSE cursor_name;\n\n3. Cursor的数据读取：Fetch\n``` sql\nEXEC SQL FETCH cursor_name\n    INTO host-variable , [host-variable, …];\n//示例:\nexec sql declare cur_student cursor for\n    select Sno, Sname, Sclass from Student where Sclass= :vClass\n    order by Sno for read only ;\nexec sql open cur_student;\n…\nexec sql fetch cur_student into :vSno, :vSname, :vSage\n…\nexec sql close cur_student;\n```\n\n#### 3.2 可滚动游标\n1. ODBC支持的可滚动Cursor\n    + 标准的游标始终是自开始向结束方向移动的，每fetch一次，向结束方向移动一次；一条记录只能被访问一次；再次访问该记录只能关闭游标后重新打开\n    + ODBC(OpenDataBase Connectivity)是一种跨DBMS的DB操作平台，它在应用程序与实际的DBMS之间提供了一种通用接口\n    + 许多实际的DBMS并不支持可滚动游标，但通过ODBC可以使用该功能\n2. 可滚动游标是可使游标指针在记录集之间灵活移动、使每条记录可以反复被访问的一种游标\n    + 可滚动游标移动时需判断是否到结束位置，或到起始位置\n        - 可通过判断是否到EOF位置(最后一条记录的后面),或BOF位置(起始记录的前面)\n        - 如果不需区分，可通过whenevernotfound语句设置来检测\n\n``` sql\nEXEC SQL DECLARE cursor_name [INSENSITIVE] [SCROLL] CURSOR\n[WITH HOLD] FOR Subquery\n[ORDER BY result_column [ASC | DESC][, result_column …]\n[FOR READ ONLY | FOR UPDATE OF columnname [,\ncolumnname ]…];\nEXEC SQL FETCH\n[ NEXT | PRIOR | FIRST | LAST\n| [ABSOLUTE | RELATIVE] value_spec ]\nFROM cursor_name INTO host-variable [, host-variable …];\n```\n* `NEXT`向结束方向移动一条；\n* `PRIOR`向开始方向移动一条；\n* `FIRST`回到第一条；\n* `LAST`移动到最后一条；\n* `ABSOLUTvalue_spec`定向检索指定位置的行,value_spec由1至当前记录集最大值；\n* `RELATIVEvalue_spec`相对当前记录向前或向后移动，value_spec为正数向结束方向移动，为负数向开始方向移动\n\n#### 3.3 数据库记录的增删改\n1. 数据库记录的删除\n    + 一种是查找删除(与交互式DELETE语句相同)，一种是定位删除\n\n``` sql\nEXEC SQL DELETE FROM tablename [corr_name]\n    WHERE search_condition | WHERE CURRENT OF cursor_name;\n//示例：查找删除\nexec sql delete from customers c where c.city = ‘Harbin’ and\n    not exists ( select * from orders o where o.cid = c.cid);\n//示例：定位删除\nexec sql declare delcust cursor for\n    select cid from customers c where c.city =‘harbin’ and\n    not exists ( select * from orders o where o.cid = c.cid)\n    for update of cid;\nexec sql open delcust\nWhile (TRUE) {\n    exec sql fetch delcust into :cust_id;\n    exec sql delete from customers where current of delcust ; }\n```\n\n2. 数据库记录的更新\n    + 一种是查找更新(与交互式Update语句相同)，一种是定位更新\n\n``` sql\nEXEC SQL UPDATE tablename [corr_name]\n    SET columnname = expr [, columnname = expr …]\n    [ WHERE search_condition ] | WHERE CURRENT OF cursor_name;\n//示例：查找更新\nexec sql update student s set sclass = ‘035102’\n    where s.sclass = ‘034101’\n// 示例：定位更新\nexec sql declare stud cursor for\n    select * from student s where s.sclass =‘034101’\n    for update of sclass;\nexec sql open stud\nWhile (TRUE) {\n    exec sql fetch stud into :vSno, :vSname, :vSclass;\n    exec sql update student set sclass = ‘035102’ where current of stud ; }\n```\n\n3. 数据库记录的插入\n    + 只有一种类型的插入语句\n\n``` sql\nEXEC SQL INSERT INTO tablename [ (columnname [,columnname, …] )]\n    [ VALUES (expr [ , expr , …] ) | subqurey ] ;\n//示例：插入语句\nexec sql insert into student ( sno, sname, sclass)\n    values (‘03510128’, ‘张三’, ‘035101’) ;\n//示例：插入语句\nexec sql insert into masterstudent ( sno, sname, sclass)\n    select sno, sname, sclass from student;\n```\n\n\n\n<span id=\"id4\"><span>\n### 4. 状态捕获及错误处理机制\n#### 4.1 基本机制\n* 状态，是嵌入式SQL语句的执行状态，尤其指一些出错状态；有时程序需要知道这些状态并对这些状态进行处理\n* 嵌入式 SQL程序中，状态捕获及处理有三部分构成\n    1. 设置SQL通信区:一般在嵌入式SQL程序的开始处便设置\n        + `exec sql include sqlca;`\n    2. 设置状态捕获语句:在嵌入式SQL程序的任何位置都可设置；可多次设置；但有作用域\n        + `exec sql whenever sqlerror goto report_error;`\n    3. 状态处理语句:某一段程序以应对SQL操作的某种状态\n        + `report_error: exec sql rollback;`\n* SQL通信区: SQLCA\n    1. SQLCA是一个已被声明过的具C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句执行的状态，便于宿主程序读取与处理\n    2. SQLCA是DBMS(执行SQL语句)与宿主程序之间交流的桥梁之一\n* 状态捕获语句: `exec sql whenever condition action;`\n    + Whenever语句的作用是设置一个“条件陷阱”, 该条语句会对其后面的所有由Exec SQL语句所引起的对数据库系统的调用自动检查它是否满足条件(由condition指出).\n        - SQLERROR: 检测是否有SQL语句出错。其具体意义依赖于特定的DBMS\n        - NOT FOUND: 执行某一SQL语句后，没有相应的结果记录出现\n        - SQLWARNING: 不是错误，但应引起注意的条件\n    + 如果满足condition, 则要采取一些动作(由action指出)\n        - CONTINUE: 忽略条件或错误，继续执行\n        - GOTO 标号: 转移到标号所指示的语句，去进行相应的处理\n        - STOP: 终止程序运行、撤消当前的工作、断开数据库的连接\n        - DO函数或 CALL函数: 调用宿主程序的函数进行处理，函数返回后从引发该condition的Exec SQL语句之后的语句继续进行\n* 状态捕获语句Whenever的作用范围是其后的所有Exec SQL语句，一直到程序中出现另一条相同条件的Whenever语句为止，后面的将覆盖前面的。\n``` SQL\nint main() {\n    exec sql whenever sqlerror stop;\n    … …\n    goto s1\n    … …\n    exec sql whenever sqlerror continue;\n    s1: exec sql update agents set percent = percent + 1;\n    … …\n}\n//S1标号指示的语句受第二个Whenever语句约束。\n//注意：作用域是语句在程序中的位置，而不是控制流程(因是预编译程序处理条件陷阱)\n```\n\n* 状态捕获语句Whenever的使用容易引发无限循环\n``` SQL\nint main() {\n    exec sql whenever sqlerror goto handle_error;\n    exec sql create table customers(cid char(4) not null,\n    cname varchar(13), … … );\n    … …\n    handle_error:\n        exec sql whenever sqlerror continue;// 控制是否无限循环：无，则可能；有，则不会\n        exec sql drop customers;\n        exec sql disconnect;\n        fprintf(stderr,”could not create customers table\\n”);\n        return -1;\n}\n```\n\n#### 4.2 状态信息\n典型DBMS系统记录状态信息的三种方法\n* 状态记录:\n    1. `sqlcode`: 典型DBMS都提供一个sqlcode变量来记录其执行sql语句的状态，但不同DBMS定义的sqlcode值所代表的状态意义可能是不同的。\n        + sqlcode== 0, successful call;\n        + sqlcode < 0, error, e.g., from connect, database does not exist , –16;\n        + sqlcode > 0, warning, e.g., no rows retrieved from fetch\n    2. `sqlca.sqlcode`: 支持SQLCA的产品一般要在SQLCA中填写sqlcode来记录上述信息; 除此而外，sqlca还有其他状态信息的记录\n    3. `sqlstate`: 有些DBMS提供的记录状态信息的变量是sqlstate或sqlca.sqlstate\n* 当我们不需明确知道错误类型，而只需知道发生错误与否，则我们只要使用前述的状态捕获语句即可，而无需关心状态记录变量(隐式状态处理)\n* 但我们程序中如要自行处理不同状态信息时，则需要知道以上信息，但也需知道正确的操作方法(显式状态处理)\n\n\n#### 4.3 程序自身进行错误信息的处理\n正确的显式状态处理示例:\n``` SQL\nexec sql begin declar section;\n    char SQLSTATE[6];\nexec sql end declare section;\nexec sql whenever sqlerror goto handle_error;\n… …\nexec sql whenever sqlerror continue;\nexec sql create table custs\n    (cid char(4) not null, cname varchar(13), … … );\nif (strcmp(SQLSTATE, “82100”)==0)\n    <处理82100错误的程序>\n    … …\n```\n上述的if语句是能被执行的，因为createtable发生错误时是继续向下执行的。\n\n\n<span id=\"id5\"><span>\n### 5. 动态SQL\n#### 5.1 动态SQL的概念\n动态SQL是相对于静态SQL而言的\n* 静态SQL特点：SQL语句在程序中已经按要求写好，只需要把一些参数通过变量(高级语言程序语句中不带冒号) 传送给嵌入式SQL语句即可(嵌入式SQL语句中带冒号)\n* 动态SQL特点：SQL语句可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍旧可以传递变量\n\n#### 5.2 动态SQL的两种执行方式\n如SQL语句已经被构造在host-variable字符串变量中,则：\n1. **立即执行语句**: 运行时编译并执行\n    + `EXEC SQL EXECUTE IMMEDIATE :host-variable;`\n2. **Prepare-Execute-Using语句**:PREPARE语句先编译，编译后的SQL语句允许动态参数，EXECUTE语句执行，用USING语句将动态参数值传送给编译好的SQL语句\n    + `EXEC SQL PREPARE sql_temp FROM :host-variable;`\n    + `EXEC SQL EXECUTE sql_temp USING :cond-variable`\n\n\n<span id=\"id6\"><span>\n### 6. 数据字典与SQLDA\n#### 6.1 数据字典的概念\n数据字典(Data dictionary)，又称为系统目录(System Catalogs)\n* 是系统维护的一些表或视图的集合，这些表或视图存储了数据库中各类对象的定义信息，这些对象包括用Create语句定义的表、列、索引、视图、权限、约束等,这些信息又称数据库的元数据--关于数据的数据。\n* 不同DBMS术语不一样：数据字典(DataDictionary(Oracle))、目录表(DB2UDB)、系统目录(INFORMIX)、系统视图(X/Open)\n* 不同DBMS中系统目录存储方式可能是不同的,但会有一些信息对DBA公开。这些公开的信息,DBA可以使用一些特殊的SQL命令来检索。\n\n#### 6.2 数据字典的内容构成\n数据字典通常存储的是数据库和表的元数据，即模式本身的信息：\n1. 与关系相关的信息\n    + 关系名字\n    + 每一个关系的属性名及其类型\n    + 视图的名字及其定义\n    + 完整性约束\n2. 用户与账户信息，包括密码\n3. 统计与描述性数据：如每个关系中元组的数目\n4. 物理文件组织信息：\n    + 关系是如何存储的(顺序/无序/散列等)\n    + 关系的物理位置\n5. 索引相关的信息\n\n#### 6.3 数据字典的结构\n1. 也是存储在磁盘上的关系\n2. 专为内存高效访问设计的特定的数据结构\n\n* 可能的字典数据结构\n    + `Relation_metadata` = `(relation_name, number_of_attributes, storage_organization, location)`\n    + `Attribute_metadata` = `(attribute_name, relation_name, domain_type, position, length)`\n    + `User_metadata` = `(user_name, encrypted_password, group)`\n    + `Index_metadata` = `(index_name, relation_name, index_type, index_attributes)`\n    + `View_metadata` = `(view_name, definition)`\n\n#### 6.4 X/Open标准的系统目录\n1. X/Open标准中有一个目录表Info_Schem.Tables, 该表中的一行是一个已经定义的表的有关信息\n    + `Table_Schem`：表的模式名(通常是表所有者的用户名)\n    + `Table_Name`：表名\n    + `Table_Type`：`'Base_Table'`或`'View'`\n2. 可以使用SQL语句来访问这个表中的信息，比如了解已经定义了哪些表，可如下进行：\n    + `Select Table_Name From Tables;`\n3. 模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而不混淆。\n4. 一般而言，一个用户有一个模式。可以使用CreateSchema语句来创建模式(用法参见相关文献)，在CreateTable等语句可以使用所定义的模式名称。\n\n#### 6.5 Oracle的数据字典\n1. Oracle数据字典由视图组成，分为三种不同形式，由不同的前缀标识\n    + `USER_` :用户视图，用户所拥有的对象，在用户模式中\n    + `ALL_`  :扩展的用户视图，用户可访问的对象\n    + `DBA_`  :DBA视图(所有用户都可访问的DBA对象的子集)\n2. Oracle数据字典中定义了三个视图`USER_Tables`,`ALL_Tables`,和`DBA_Tables`供DBA和用户使用数据字典中关于**表的信息**\n3. 同样,Oracle数据字典中也定义了三个视图`USER_TAB_Columns`,`ALL_TAB_Columns`(`Accessible_Columns`),和`DBA_TAB_Columns`供DBA和用户使用数据字典中关于表的**列的信息**\n4. 可以使用SQL语句来访问这些表中的信息：\n    + `Select Column_Name From ALL_TAB_Columns Where Table_Name = ‘STUDENT’;`\n5. Oracle数据字典中还定义了其他视图\n    + `TABLE_PRIVILEDGE`(或`ALL_TAB_GRANTS`)\n    + `COLUMN_PRIVILEDGE`(或`ALL_COL_GRANTS`)可访问表的权限，列的权限\n    + `CONSTRAINT_DEFS`(或`ALL_CONSTRAINTS`)可访问表的各种约束\n6. 可以使用下述命令获取Oracle定义的所有视图信息\n    + `Select view_name from all_views where owner = ‘SYS’ and view_name like ‘ALL_%’ or view_name like ‘USER_%’;`\n7. 如果用户使用Oracle,可使用其提供的`SQL*PLUS`进行交互式访问\n8. 动态SQL: 表和列都已知，动态构造检索条件。\n9. 动态SQL:检索条件可动态构造，表和列也可动态构造。\n\n#### 6.6 SQLDA\n构造复杂的动态SQL需要了解数据字典及SQLDA，已获知关系模式信息\n1. SQLDA: SQLDescriptorArea,SQL描述符区域。\n    + SQLDA是一个内存数据结构，内可装载关系模式的定义信息，如列的数目，每一列的名字和类型等等\n    + 通过读取SQLDA信息可以进行更为复杂的动态SQL的处理\n    + 不同DBMS提供的SQLDA格式并不是一致的。\n\n\n\n<span id=\"id7\"><span>\n### 7. ODBC简介\n#### 7.1 ODBC定义\nODBC：Open DataBase Connection，ODBC是一种标准---不同语言的应用程序与不同数据库服务器之间通讯的标准。\n* 一组API(应用程序接口)，支持应用程序与数据库服务器的交互\n* 应用程序通过调用ODBC API, 实现\n    1. 与数据服务器的连接\n    2. 向数据库服务器发送SQL命令\n    3. 一条一条的提取数据库检索结果中的元组传递给应用程序的变量\n* 具体的DBMS提供一套驱动程序，即Driver库函数，供ODBC调用，以便实现数据库与应用程序的连接。\n* ODBC可以配合很多高级语言来使用，如C,C++, C#, Visual Basic, PowerBuilder等等；\n\n#### 7.2 通过ODBC连接数据库\n1. ODBC应用前，需要确认具体DBMS Driver被安装到ODBC环境中\n2. 当应用程序调用ODBC API时，ODBC API会调用具体DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯，执行相应的请求动作并返回检索结果\n3. ODBC应用程序首先要分配一个SQL环境，再产生一个数据库连接句柄\n4. 应用程序使用SQLConnect()，打开一个数据库连接，SQLConnect()的具体参数:\n    + `connection handle`, 连接句柄\n    + `the server`，要连接的数据库服务器\n    + `the user identifier`，用户\n    + `password` ，密码\n    + `SQL_NTS` 类型说明前面的参数是空终止的字符串\n5. 示例\n``` sql\nint ODBCexample(){\n    RETCODE error; /* 返回状态吗 */\n    HENV env; /* 环境变量 */\n    HDBC conn; /* 连接句柄 */\n    SQLAllocEnv(&env);\n    SQLAllocConnect(env, &conn);\n    //分配数据库连接环境\n    SQLConnect(conn, \"aura.bell-labs.com\", SQL_NTS, \"avi\", SQL_NTS, avipasswd\", SQL_NTS);\n    //打开一个数据库连接\n    { …. Do actual work … }\n    //与数据库通讯\n    SQLDisconnect(conn);\n    SQLFreeConnect(conn);\n    SQLFreeEnv(env);\n    //断开连接与释放环境\n}\n```\n\n#### 7.3 通过ODBC与数据库服务器进行通讯\n1. 应用程序使用SQLExecDirect()向数据库发送SQL命令；\n2. 使用SQLFetch()获取产生的结果元组；\n3. 使用SQLBindCol()绑定C语言变量与结果中的属性\n    + 当获取一个元组时，属性值会自动地传送到相应的C语言变量中\n4. SQLBindCol()的参数：\n    + ODBC定义的stmt变量,查询结果中的属性位置\n    + SQL到C的类型变换,变量的地址.\n    + 对于类似字符数组一样的可变长度类型，应给出\n        - •变量的最大长度\n        - •当获取到一个元组后，实际长度的存储位置.\n        - •注:当返回实际长度为负数，说明是一个空值。\n5. 示例\n``` sql\nchar branchname[80]; float balance;\nint lenOut1, lenOut2;\nHSTMT stmt;\nSQLAllocStmt(conn, &stmt);\n//分配一个与指定数据库连接的新的语句句柄\nchar * sqlquery = \"select branch_name, sum (balance)\n    from account\n    group by branch_name\";\nerror = SQLExecDirect(stmt, sqlquery, SQL_NTS);\n//执行查询，stmt句柄指向结果集合\nif (error == SQL_SUCCESS) {\nSQLBindCol(stmt, 1, SQL_C_CHAR, branchname , 80, &lenOut1);\nSQLBindCol(stmt, 2, SQL_C_FLOAT, &balance, 0 , &lenOut2);\n//绑定高级语言变量与stmt句柄中的属性\nwhile (SQLFetch(stmt) >= SQL_SUCCESS) {\n//提取一条记录，结果数据被存入高级语言变量中\n    printf (\" %s %g\\n\", branchname, balance);\n    }\n}\nSQLFreeStmt(stmt, SQL_DROP);\n//释放语句句柄\n```\n\n\n#### 7.4 ODBC的其他功能\n1. 动态SQL语句的预编译-动态参数传递功能\n2. 获取元数据特性\n    + 发现数据库中的所有关系的特性 以及\n    + 发现每一个查询结果的列的名字和类型等；\n3. 默认, 每一条SQL语句都被作为一个独立的能够自动提交的事务来处理。\n    + 应用程序可以关闭一个连接的自动提交特性\n        - `SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0)}`\n    + 此时事务要显式地给出提交和撤销的命令\n        - `SQLTransact(conn, SQL_COMMIT)` or `SQLTransact(conn, SQL_ROLLBACK)`\n\n\n<span id=\"id8\"><span>\n### 8. JDBC简介\n#### 8.1 JDBC定义\nJDBC：Java DataBase Connection，JDBC是一组Java版的应用程序接口API，提供了Java应用程序与数据库服务器的连接和通讯能力。\n* JDBCAPI分成两个程序包：\n    + Java.sql 核心API --J2SE(Java2标准版)的一部分。使用`java.sql.DriverManager`类、`java.sql.Driver`和`java.sql.Connection`接口连接到数据库\n    + Javax.sql 可选扩展API--J2EE(Java2企业版)的一部分。包含了基于`JNDI(JavaNamingandDirectoryInterface,Java命名和目录接口)`的资源，以及管理连接池、分布式事务等，使用DataSource接口连接到数据库。\n\n#### 8.2 JDBC的功能\n1. `java.sql.DriverManager`——处理驱动的调入并且对产生新数据库连接提供支持\n2. `Java.sql.Driver`——通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动。\n3. `java.sql.Connection`——代表对特定数据库的连接。\n4. `Try {…} Catch {…}` ——异常捕获及其处理\n5. `java.sql.Statement`——对特定的数据库执行SQL语句\n6. `java.sql.PreparedStatement` —— 用于执行预编译的SQL语句\n7. `java.sql.CallableStatement` ——用于执行对数据库内嵌过程的调用。\n8. `java.sql.ResultSet`——从当前执行的SQL语句中返回结果数据。\n\n#### 8.3 使用JDBC API访问数据库的过程\n1. 概念性的基本过程\n    + 打开一个连接；创建“Statement”对象，并设置查询语句；使用Statement对象执行查询，发送查询给数据库服务器和返回结果给应用程序；处理错误的例外机制\n2. 具体实施过程\n    1. •传递一个Driver给DriverManager，加载数据库驱动。\n        + `Class.forName()`\n    2. •通过URL得到一个Connection对象, 建立数据库连接\n        + `DriverManager.getConnection(sDBUrl)`\n        + `DriverManager.getConnection(sDBUrl,sDBUserID,sDBPassword)`\n    3. •接着创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库。\n        + `Statement stmt=con.createStatement()`\n    4. •查询返回一个ResultSet。\n        + `ResultSet rs=stmt.executeQuery(sSQL)`\n3. 示例：\n``` java\npublic static void JDBCexample(String dbid, String userid, String passwd)\n{ try { //错误捕获\n    Class.forName (\"oracle.jdbc.driver.OracleDriver\");\n    Connection conn = DriverManager.getConnection(\n        \"jdbc:oracle:thin:@db.yale.edu:1521:univdb\", userid, passwd);\n    //加载数据库驱动，建立数据库连接\n    Statement stmt = conn.createStatement();\n    //创建一个语句对象\n    … Do Actual Work ….\n    //进行SQL语句的执行与处理工作\n    stmt.close();\n    conn.close();\n    //关闭语句对象，关闭连接\n} catch (SQLException sqle) {\n    System.out.println(\"SQLException : \" + sqle); }\n}\n```\n\n4. 完整的示例程序\n``` java\npublic static void JDBCexample(String dbid, String userid, String passwd)\n{ try {\n    Class.forName (\"oracle.jdbc.driver.OracleDriver\");\n    Connection conn = DriverManager.getConnection(\n        \"jdbc:oracle:thin:@db.yale.edu:1521:univdb\", userid, passwd);\n    Statement stmt = conn.createStatement();\n    try {\n        stmt.executeUpdate( \"insert into instructor values\n        (‘77987', ‘Kim', ‘Physics’,98000)\");\n    } catch (SQLException sqle) {\n        System.out.println(\"插入错误:\" + sqle);\n    }\n    ResultSet rset = stmt.executeQuery(\n        \"select dept_name, avg(salary) from instructor group by dept_name\");\n    while ( rset.next() ) {\n        System.out.println(rset.getString(“dept_name\") + \" \" + rset.getFloat(2));\n    }\n    stmt.close();\n    conn.close();\n} catch (SQLException sqle) {\n    System.out.println(\"SQLException:\" + sqle);\n}\n}\n```\n\n\n<span id=\"id9\"><span>\n### 9. 嵌入式SQL-ODBC-JDBC三者比较\n执行一条SQL语句，读取执行的结果集合\n1. 嵌入式SQL的思维模式\n    1. 建立数据库连接\n    2. 声明一个游标\n    3. 打开游标\n    4. 读取一条记录(循环)\n    5. 关闭游标\n    6. 断开数据库连接\n2. ODBC的思维模式\n    1. 建立数据库连接\n    2. 分配语句句柄\n    3. 用句柄执行SQL\n    4. 建立高级语言变量与句柄属性的对应\n    5. 读取一条记录(循环)\n    6. 释放语句句柄\n    7. 断开数据库连接\n3. JDBC的思维模式\n    1. 建立数据库连接\n    2. 创建语句对象\n    3. 用语句对象执行SQL，并返回结果对象\n    4. 从结果对象获取一条记录\n    5. 提取对象的属性值传给高级语言变量(返回上一步)\n    6. 释放语句对象\n    7. 断开数据库连接\n\n* 相同点: 都是建立数据库连接, 执行sql, 处理结果, 释放连接, 流程基本一致\n* 不同点, 操作方式的不同:\n    + 嵌入式SQL按照语句进行操作\n    + ODBC按照函数来进行操作\n    + JDBC按照对象来进行操作\n\n\n","source":"_posts/【数据库】嵌入式SQL语言.md","raw":"---\ntitle: 【数据库】嵌入式SQL语言\ndate: 2019-07-16 14:32:28\ntags: [数据库, 后端开发]\ncategories: 数据库\n---\n\n### 概述\n* 交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，\n* 然而，交互式SQL本身也有很多局限：<!-- more -->\n    + 从使用者角度：专业人员可熟练写出SQL语句，但大部分的普通用户并非可以\n    + 从SQL本身角度：特别复杂的检索结果难以用一条交互式SQL语句完成，此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理\n* 因此，高级语言+SQL语言：\n    + 既继承高级语言的过程控制性\n    + 又结合SQL语言的复杂结果集操作的非过程性\n    + 同时又为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作\n* 嵌入式SQL语言\n    + 将SQL语言嵌入到某一种高级语言中使用\n    + 这种高级语言，如C/C++, Java, PowerBuilder等，又称宿主语言(Host Language)\n    + 嵌入在宿主语言中的SQL与前面介绍的交互式SQL有一些不同的操作方式\n\n\n#### 目录：\n1. [变量声明与数据库连接](#id1)\n2. [事务Transaction](#id2)\n3. [数据集与游标](#id3)\n4. [状态捕获及错误处理机制](#id4)\n5. [动态SQL](#id5)\n6. [数据字典与SQLDA](#id6)\n7. [ODBC简介](#id7)\n8. [JDBC简介](#id8)\n9. [嵌入式SQL-ODBC-JDBC三者比较](#id9)\n\n\n<span id=\"id1\"><span>\n### 1. 变量声明与数据库连接\n1. 以宿主语言**C语言**为例，对比交互式SQL语言与嵌入式SQL语言\n    + 交互式SQL:`select Sname, Sage from Student where Sname='张三';`\n    + 嵌入式SQL:`exec sql select Sname, Sage into :vSname, :vSage from Student where Sname='张三';`\n2. 典型特点\n    + **exec sql**引导SQL语句: 提供给C编译器，以便对SQL语句预编译成C编译器可识别的语句\n    + 增加一 **into子句**: 该子句用于指出接收SQL语句检索结果的程序变量\n    + 由冒号引导的**程序变量**,如: ‘:vSname’, ‘:vSage’\n\n#### 1.1 变量的声明与使用\n* 在嵌入式SQL语句中可以出现宿主语言语句所使用的变量，这些变量需要特殊的声明：\n``` sql\nexec sql begin declare section;\n    char vSname[10], specName[10]=\"张三\";\n    int vSage;\nexec sql end declare section;\n```\n* 变量声明和赋值中，要注意：\n    + 宿主程序的字符串变量长度应比字符型字段的长度多1个。因宿主程序的字符串尾部多一个终止符为'\\0'，而程序中用双引号来描述。\n    + 宿主程序变量类型与数据库字段类型之间有些是有差异的,有些DBMS可支持自动转换，有些不能。\n* 声明的变量，可以在宿主程序中赋值，然后传递给SQL语句的where等子句中，以使SQL语句能够按照指定的要求(可变化的)进行检索。\n* 嵌入式比交互式SQL语句灵活了一些：只需改一下变量值，SQL语句便可反复使用，以检索出不同结果。\n* 示例：\n``` sql\nexec sql begin declare section;\n    char vSname[10], specName[10]=\"张三\";\n    int vSage;\nexec sql end declare section;\n//用户可在此处基于键盘输入给specName赋值\nexec sql select Sname, Sage into :vSname, :vSage from Student where Sname = :specName;\n//比较相应的交互式SQL语句：\nselect Sname, Sage from Student where Sname = '张三';\n```\n\n\n#### 1.2 程序与数据库的连接和断开\n##### 1.2.1 数据库的连接connect\n在嵌入式SQL程序执行之前，首先要与数据库进行连接, 不同DBMS，具体连接语句的语法略有差异\n1. SQL标准中建议的连接语法为：\n    + `execsql connecttotarget-server asconnect-name useruser-name;`\n    + 或 `execsql connecttodefault;`\n2. Oracle中数据库连接:\n    + `execsql connect:user_name identified by :user_pwd;`\n3. DB2 UDB中数据库连接:\n    + `execsql connecttomydb user:user_name using:user_pwd;`\n\n##### 1.2.1 数据库的断开disconnect\n在嵌入式SQL程序执行之后，需要与数据库断开连接\n1. SQL标准中建议的断开连接的语法为：\n    + `exec sql disconnect connect-name;`\n    + 或 `exec sql disconnect current;`\n2. Oracle中断开连接:\n    + `exec sql commit release;`\n    + 或 `exec sql rollback release;`\n3. DB2 UDB中断开连接:\n    + `exec sql connect reset;`\n    + `exec sql disconnect current;`\n\n#### 1.3 SQL执行的提交与撤消\nSQL语句在执行过程中，必须有提交和撤消语句才能确认其操作结果\n1. SQL执行的提交：\n    + `execsql commitwork;`\n2. SQL执行的撤消：\n    + `execsql rollbackwork;`\n3. 为此，很多DBMS都设计了捆绑提交/撤消与断开连接在一起的语句,以保证在断开连接之前使用户确认提交或撤消先前的工作，例如Oracle中：\n    + `execsql commitrelease;`\n    + 或 `execsql rollbackrelease;`\n\n\n<span id=\"id2\"><span>\n### 2. 事务Transaction\n1. 从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务\n2. 从微观角度，或者从DBMS角度：事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。\n3. 简单来说：事务是作为单个逻辑工作单元执行的一系列操作；多个操作作为一个整体向系统提交，要么都执行，要么都不执行；**事务是一个不可分割的工作逻辑单元**。\n\n#### 2.1 事务的特性: ACID\n1. **原子性**Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对DB而言，要么都执行，要么都不执行\n2. **一致性**Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作规则，它是进一步由隔离性来保证的\n3. **隔离性**Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;或者先执行了T2, 再执行T1。\n4. **持久性**Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的。\n\n> 换句话说：具有ACID特性的若干数据库基本操作的组合体被称为事务。\n\n\n<span id=\"id3\"><span>\n### 3. 数据集与游标\n读取单行结果处理与多行结果处理的差异：Into子句与游标(Cursor)\n1. 检索单行结果，可将结果直接传送到宿主程序的变量中(Into)\n    + 示例：`exec sql select Sname,Sage into :vSname,:vSage from Student where Sname = :specName;`\n2. 检索多行结果，则需使用游标(Cursor)\n    + 游标是指向某检索记录集的指针\n    + 通过这个指针的移动，每次读一行，处理一行，再读一行… , 直至处理完毕\n    + 读一行操作是通过Fetch…into语句实现的：每一次Fetch, 都是先向下移动指针，然后再读取\n    + 记录集有结束标识EOF, 用来标记后面已没有记录了\n* 游标(Cursor)的使用需要先定义、再打开(执行)、接着一条接一条处理，最后再关闭\n* 游标可以定义一次，多次打开(多次执行)，多次关闭\n\n#### 3.1 游标的使用方法\n1. Cursor的定义：declare cursor\n``` sql\nEXEC SQL DECLARE cursor_name CURSOR FOR\n    Subquery\n    [ORDER BY result_column [ASC | DESC][, result_column …]\n    [FOR [ READ ONLY | UPDATE [OF columnname [, columnname…]]]];\n//示例:\nexec sql declare cur_student cursor for\n    select Sno, Sname, Sclass from Student where Sclass= :vClass\n    order by Sno\n    for read only ;\n```\n\n2. Cursor的打开和关闭：open cursor //close cursor\n    + EXEC SQL OPEN cursor_name;\n    + EXEC SQL CLOSE cursor_name;\n\n3. Cursor的数据读取：Fetch\n``` sql\nEXEC SQL FETCH cursor_name\n    INTO host-variable , [host-variable, …];\n//示例:\nexec sql declare cur_student cursor for\n    select Sno, Sname, Sclass from Student where Sclass= :vClass\n    order by Sno for read only ;\nexec sql open cur_student;\n…\nexec sql fetch cur_student into :vSno, :vSname, :vSage\n…\nexec sql close cur_student;\n```\n\n#### 3.2 可滚动游标\n1. ODBC支持的可滚动Cursor\n    + 标准的游标始终是自开始向结束方向移动的，每fetch一次，向结束方向移动一次；一条记录只能被访问一次；再次访问该记录只能关闭游标后重新打开\n    + ODBC(OpenDataBase Connectivity)是一种跨DBMS的DB操作平台，它在应用程序与实际的DBMS之间提供了一种通用接口\n    + 许多实际的DBMS并不支持可滚动游标，但通过ODBC可以使用该功能\n2. 可滚动游标是可使游标指针在记录集之间灵活移动、使每条记录可以反复被访问的一种游标\n    + 可滚动游标移动时需判断是否到结束位置，或到起始位置\n        - 可通过判断是否到EOF位置(最后一条记录的后面),或BOF位置(起始记录的前面)\n        - 如果不需区分，可通过whenevernotfound语句设置来检测\n\n``` sql\nEXEC SQL DECLARE cursor_name [INSENSITIVE] [SCROLL] CURSOR\n[WITH HOLD] FOR Subquery\n[ORDER BY result_column [ASC | DESC][, result_column …]\n[FOR READ ONLY | FOR UPDATE OF columnname [,\ncolumnname ]…];\nEXEC SQL FETCH\n[ NEXT | PRIOR | FIRST | LAST\n| [ABSOLUTE | RELATIVE] value_spec ]\nFROM cursor_name INTO host-variable [, host-variable …];\n```\n* `NEXT`向结束方向移动一条；\n* `PRIOR`向开始方向移动一条；\n* `FIRST`回到第一条；\n* `LAST`移动到最后一条；\n* `ABSOLUTvalue_spec`定向检索指定位置的行,value_spec由1至当前记录集最大值；\n* `RELATIVEvalue_spec`相对当前记录向前或向后移动，value_spec为正数向结束方向移动，为负数向开始方向移动\n\n#### 3.3 数据库记录的增删改\n1. 数据库记录的删除\n    + 一种是查找删除(与交互式DELETE语句相同)，一种是定位删除\n\n``` sql\nEXEC SQL DELETE FROM tablename [corr_name]\n    WHERE search_condition | WHERE CURRENT OF cursor_name;\n//示例：查找删除\nexec sql delete from customers c where c.city = ‘Harbin’ and\n    not exists ( select * from orders o where o.cid = c.cid);\n//示例：定位删除\nexec sql declare delcust cursor for\n    select cid from customers c where c.city =‘harbin’ and\n    not exists ( select * from orders o where o.cid = c.cid)\n    for update of cid;\nexec sql open delcust\nWhile (TRUE) {\n    exec sql fetch delcust into :cust_id;\n    exec sql delete from customers where current of delcust ; }\n```\n\n2. 数据库记录的更新\n    + 一种是查找更新(与交互式Update语句相同)，一种是定位更新\n\n``` sql\nEXEC SQL UPDATE tablename [corr_name]\n    SET columnname = expr [, columnname = expr …]\n    [ WHERE search_condition ] | WHERE CURRENT OF cursor_name;\n//示例：查找更新\nexec sql update student s set sclass = ‘035102’\n    where s.sclass = ‘034101’\n// 示例：定位更新\nexec sql declare stud cursor for\n    select * from student s where s.sclass =‘034101’\n    for update of sclass;\nexec sql open stud\nWhile (TRUE) {\n    exec sql fetch stud into :vSno, :vSname, :vSclass;\n    exec sql update student set sclass = ‘035102’ where current of stud ; }\n```\n\n3. 数据库记录的插入\n    + 只有一种类型的插入语句\n\n``` sql\nEXEC SQL INSERT INTO tablename [ (columnname [,columnname, …] )]\n    [ VALUES (expr [ , expr , …] ) | subqurey ] ;\n//示例：插入语句\nexec sql insert into student ( sno, sname, sclass)\n    values (‘03510128’, ‘张三’, ‘035101’) ;\n//示例：插入语句\nexec sql insert into masterstudent ( sno, sname, sclass)\n    select sno, sname, sclass from student;\n```\n\n\n\n<span id=\"id4\"><span>\n### 4. 状态捕获及错误处理机制\n#### 4.1 基本机制\n* 状态，是嵌入式SQL语句的执行状态，尤其指一些出错状态；有时程序需要知道这些状态并对这些状态进行处理\n* 嵌入式 SQL程序中，状态捕获及处理有三部分构成\n    1. 设置SQL通信区:一般在嵌入式SQL程序的开始处便设置\n        + `exec sql include sqlca;`\n    2. 设置状态捕获语句:在嵌入式SQL程序的任何位置都可设置；可多次设置；但有作用域\n        + `exec sql whenever sqlerror goto report_error;`\n    3. 状态处理语句:某一段程序以应对SQL操作的某种状态\n        + `report_error: exec sql rollback;`\n* SQL通信区: SQLCA\n    1. SQLCA是一个已被声明过的具C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句执行的状态，便于宿主程序读取与处理\n    2. SQLCA是DBMS(执行SQL语句)与宿主程序之间交流的桥梁之一\n* 状态捕获语句: `exec sql whenever condition action;`\n    + Whenever语句的作用是设置一个“条件陷阱”, 该条语句会对其后面的所有由Exec SQL语句所引起的对数据库系统的调用自动检查它是否满足条件(由condition指出).\n        - SQLERROR: 检测是否有SQL语句出错。其具体意义依赖于特定的DBMS\n        - NOT FOUND: 执行某一SQL语句后，没有相应的结果记录出现\n        - SQLWARNING: 不是错误，但应引起注意的条件\n    + 如果满足condition, 则要采取一些动作(由action指出)\n        - CONTINUE: 忽略条件或错误，继续执行\n        - GOTO 标号: 转移到标号所指示的语句，去进行相应的处理\n        - STOP: 终止程序运行、撤消当前的工作、断开数据库的连接\n        - DO函数或 CALL函数: 调用宿主程序的函数进行处理，函数返回后从引发该condition的Exec SQL语句之后的语句继续进行\n* 状态捕获语句Whenever的作用范围是其后的所有Exec SQL语句，一直到程序中出现另一条相同条件的Whenever语句为止，后面的将覆盖前面的。\n``` SQL\nint main() {\n    exec sql whenever sqlerror stop;\n    … …\n    goto s1\n    … …\n    exec sql whenever sqlerror continue;\n    s1: exec sql update agents set percent = percent + 1;\n    … …\n}\n//S1标号指示的语句受第二个Whenever语句约束。\n//注意：作用域是语句在程序中的位置，而不是控制流程(因是预编译程序处理条件陷阱)\n```\n\n* 状态捕获语句Whenever的使用容易引发无限循环\n``` SQL\nint main() {\n    exec sql whenever sqlerror goto handle_error;\n    exec sql create table customers(cid char(4) not null,\n    cname varchar(13), … … );\n    … …\n    handle_error:\n        exec sql whenever sqlerror continue;// 控制是否无限循环：无，则可能；有，则不会\n        exec sql drop customers;\n        exec sql disconnect;\n        fprintf(stderr,”could not create customers table\\n”);\n        return -1;\n}\n```\n\n#### 4.2 状态信息\n典型DBMS系统记录状态信息的三种方法\n* 状态记录:\n    1. `sqlcode`: 典型DBMS都提供一个sqlcode变量来记录其执行sql语句的状态，但不同DBMS定义的sqlcode值所代表的状态意义可能是不同的。\n        + sqlcode== 0, successful call;\n        + sqlcode < 0, error, e.g., from connect, database does not exist , –16;\n        + sqlcode > 0, warning, e.g., no rows retrieved from fetch\n    2. `sqlca.sqlcode`: 支持SQLCA的产品一般要在SQLCA中填写sqlcode来记录上述信息; 除此而外，sqlca还有其他状态信息的记录\n    3. `sqlstate`: 有些DBMS提供的记录状态信息的变量是sqlstate或sqlca.sqlstate\n* 当我们不需明确知道错误类型，而只需知道发生错误与否，则我们只要使用前述的状态捕获语句即可，而无需关心状态记录变量(隐式状态处理)\n* 但我们程序中如要自行处理不同状态信息时，则需要知道以上信息，但也需知道正确的操作方法(显式状态处理)\n\n\n#### 4.3 程序自身进行错误信息的处理\n正确的显式状态处理示例:\n``` SQL\nexec sql begin declar section;\n    char SQLSTATE[6];\nexec sql end declare section;\nexec sql whenever sqlerror goto handle_error;\n… …\nexec sql whenever sqlerror continue;\nexec sql create table custs\n    (cid char(4) not null, cname varchar(13), … … );\nif (strcmp(SQLSTATE, “82100”)==0)\n    <处理82100错误的程序>\n    … …\n```\n上述的if语句是能被执行的，因为createtable发生错误时是继续向下执行的。\n\n\n<span id=\"id5\"><span>\n### 5. 动态SQL\n#### 5.1 动态SQL的概念\n动态SQL是相对于静态SQL而言的\n* 静态SQL特点：SQL语句在程序中已经按要求写好，只需要把一些参数通过变量(高级语言程序语句中不带冒号) 传送给嵌入式SQL语句即可(嵌入式SQL语句中带冒号)\n* 动态SQL特点：SQL语句可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍旧可以传递变量\n\n#### 5.2 动态SQL的两种执行方式\n如SQL语句已经被构造在host-variable字符串变量中,则：\n1. **立即执行语句**: 运行时编译并执行\n    + `EXEC SQL EXECUTE IMMEDIATE :host-variable;`\n2. **Prepare-Execute-Using语句**:PREPARE语句先编译，编译后的SQL语句允许动态参数，EXECUTE语句执行，用USING语句将动态参数值传送给编译好的SQL语句\n    + `EXEC SQL PREPARE sql_temp FROM :host-variable;`\n    + `EXEC SQL EXECUTE sql_temp USING :cond-variable`\n\n\n<span id=\"id6\"><span>\n### 6. 数据字典与SQLDA\n#### 6.1 数据字典的概念\n数据字典(Data dictionary)，又称为系统目录(System Catalogs)\n* 是系统维护的一些表或视图的集合，这些表或视图存储了数据库中各类对象的定义信息，这些对象包括用Create语句定义的表、列、索引、视图、权限、约束等,这些信息又称数据库的元数据--关于数据的数据。\n* 不同DBMS术语不一样：数据字典(DataDictionary(Oracle))、目录表(DB2UDB)、系统目录(INFORMIX)、系统视图(X/Open)\n* 不同DBMS中系统目录存储方式可能是不同的,但会有一些信息对DBA公开。这些公开的信息,DBA可以使用一些特殊的SQL命令来检索。\n\n#### 6.2 数据字典的内容构成\n数据字典通常存储的是数据库和表的元数据，即模式本身的信息：\n1. 与关系相关的信息\n    + 关系名字\n    + 每一个关系的属性名及其类型\n    + 视图的名字及其定义\n    + 完整性约束\n2. 用户与账户信息，包括密码\n3. 统计与描述性数据：如每个关系中元组的数目\n4. 物理文件组织信息：\n    + 关系是如何存储的(顺序/无序/散列等)\n    + 关系的物理位置\n5. 索引相关的信息\n\n#### 6.3 数据字典的结构\n1. 也是存储在磁盘上的关系\n2. 专为内存高效访问设计的特定的数据结构\n\n* 可能的字典数据结构\n    + `Relation_metadata` = `(relation_name, number_of_attributes, storage_organization, location)`\n    + `Attribute_metadata` = `(attribute_name, relation_name, domain_type, position, length)`\n    + `User_metadata` = `(user_name, encrypted_password, group)`\n    + `Index_metadata` = `(index_name, relation_name, index_type, index_attributes)`\n    + `View_metadata` = `(view_name, definition)`\n\n#### 6.4 X/Open标准的系统目录\n1. X/Open标准中有一个目录表Info_Schem.Tables, 该表中的一行是一个已经定义的表的有关信息\n    + `Table_Schem`：表的模式名(通常是表所有者的用户名)\n    + `Table_Name`：表名\n    + `Table_Type`：`'Base_Table'`或`'View'`\n2. 可以使用SQL语句来访问这个表中的信息，比如了解已经定义了哪些表，可如下进行：\n    + `Select Table_Name From Tables;`\n3. 模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而不混淆。\n4. 一般而言，一个用户有一个模式。可以使用CreateSchema语句来创建模式(用法参见相关文献)，在CreateTable等语句可以使用所定义的模式名称。\n\n#### 6.5 Oracle的数据字典\n1. Oracle数据字典由视图组成，分为三种不同形式，由不同的前缀标识\n    + `USER_` :用户视图，用户所拥有的对象，在用户模式中\n    + `ALL_`  :扩展的用户视图，用户可访问的对象\n    + `DBA_`  :DBA视图(所有用户都可访问的DBA对象的子集)\n2. Oracle数据字典中定义了三个视图`USER_Tables`,`ALL_Tables`,和`DBA_Tables`供DBA和用户使用数据字典中关于**表的信息**\n3. 同样,Oracle数据字典中也定义了三个视图`USER_TAB_Columns`,`ALL_TAB_Columns`(`Accessible_Columns`),和`DBA_TAB_Columns`供DBA和用户使用数据字典中关于表的**列的信息**\n4. 可以使用SQL语句来访问这些表中的信息：\n    + `Select Column_Name From ALL_TAB_Columns Where Table_Name = ‘STUDENT’;`\n5. Oracle数据字典中还定义了其他视图\n    + `TABLE_PRIVILEDGE`(或`ALL_TAB_GRANTS`)\n    + `COLUMN_PRIVILEDGE`(或`ALL_COL_GRANTS`)可访问表的权限，列的权限\n    + `CONSTRAINT_DEFS`(或`ALL_CONSTRAINTS`)可访问表的各种约束\n6. 可以使用下述命令获取Oracle定义的所有视图信息\n    + `Select view_name from all_views where owner = ‘SYS’ and view_name like ‘ALL_%’ or view_name like ‘USER_%’;`\n7. 如果用户使用Oracle,可使用其提供的`SQL*PLUS`进行交互式访问\n8. 动态SQL: 表和列都已知，动态构造检索条件。\n9. 动态SQL:检索条件可动态构造，表和列也可动态构造。\n\n#### 6.6 SQLDA\n构造复杂的动态SQL需要了解数据字典及SQLDA，已获知关系模式信息\n1. SQLDA: SQLDescriptorArea,SQL描述符区域。\n    + SQLDA是一个内存数据结构，内可装载关系模式的定义信息，如列的数目，每一列的名字和类型等等\n    + 通过读取SQLDA信息可以进行更为复杂的动态SQL的处理\n    + 不同DBMS提供的SQLDA格式并不是一致的。\n\n\n\n<span id=\"id7\"><span>\n### 7. ODBC简介\n#### 7.1 ODBC定义\nODBC：Open DataBase Connection，ODBC是一种标准---不同语言的应用程序与不同数据库服务器之间通讯的标准。\n* 一组API(应用程序接口)，支持应用程序与数据库服务器的交互\n* 应用程序通过调用ODBC API, 实现\n    1. 与数据服务器的连接\n    2. 向数据库服务器发送SQL命令\n    3. 一条一条的提取数据库检索结果中的元组传递给应用程序的变量\n* 具体的DBMS提供一套驱动程序，即Driver库函数，供ODBC调用，以便实现数据库与应用程序的连接。\n* ODBC可以配合很多高级语言来使用，如C,C++, C#, Visual Basic, PowerBuilder等等；\n\n#### 7.2 通过ODBC连接数据库\n1. ODBC应用前，需要确认具体DBMS Driver被安装到ODBC环境中\n2. 当应用程序调用ODBC API时，ODBC API会调用具体DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯，执行相应的请求动作并返回检索结果\n3. ODBC应用程序首先要分配一个SQL环境，再产生一个数据库连接句柄\n4. 应用程序使用SQLConnect()，打开一个数据库连接，SQLConnect()的具体参数:\n    + `connection handle`, 连接句柄\n    + `the server`，要连接的数据库服务器\n    + `the user identifier`，用户\n    + `password` ，密码\n    + `SQL_NTS` 类型说明前面的参数是空终止的字符串\n5. 示例\n``` sql\nint ODBCexample(){\n    RETCODE error; /* 返回状态吗 */\n    HENV env; /* 环境变量 */\n    HDBC conn; /* 连接句柄 */\n    SQLAllocEnv(&env);\n    SQLAllocConnect(env, &conn);\n    //分配数据库连接环境\n    SQLConnect(conn, \"aura.bell-labs.com\", SQL_NTS, \"avi\", SQL_NTS, avipasswd\", SQL_NTS);\n    //打开一个数据库连接\n    { …. Do actual work … }\n    //与数据库通讯\n    SQLDisconnect(conn);\n    SQLFreeConnect(conn);\n    SQLFreeEnv(env);\n    //断开连接与释放环境\n}\n```\n\n#### 7.3 通过ODBC与数据库服务器进行通讯\n1. 应用程序使用SQLExecDirect()向数据库发送SQL命令；\n2. 使用SQLFetch()获取产生的结果元组；\n3. 使用SQLBindCol()绑定C语言变量与结果中的属性\n    + 当获取一个元组时，属性值会自动地传送到相应的C语言变量中\n4. SQLBindCol()的参数：\n    + ODBC定义的stmt变量,查询结果中的属性位置\n    + SQL到C的类型变换,变量的地址.\n    + 对于类似字符数组一样的可变长度类型，应给出\n        - •变量的最大长度\n        - •当获取到一个元组后，实际长度的存储位置.\n        - •注:当返回实际长度为负数，说明是一个空值。\n5. 示例\n``` sql\nchar branchname[80]; float balance;\nint lenOut1, lenOut2;\nHSTMT stmt;\nSQLAllocStmt(conn, &stmt);\n//分配一个与指定数据库连接的新的语句句柄\nchar * sqlquery = \"select branch_name, sum (balance)\n    from account\n    group by branch_name\";\nerror = SQLExecDirect(stmt, sqlquery, SQL_NTS);\n//执行查询，stmt句柄指向结果集合\nif (error == SQL_SUCCESS) {\nSQLBindCol(stmt, 1, SQL_C_CHAR, branchname , 80, &lenOut1);\nSQLBindCol(stmt, 2, SQL_C_FLOAT, &balance, 0 , &lenOut2);\n//绑定高级语言变量与stmt句柄中的属性\nwhile (SQLFetch(stmt) >= SQL_SUCCESS) {\n//提取一条记录，结果数据被存入高级语言变量中\n    printf (\" %s %g\\n\", branchname, balance);\n    }\n}\nSQLFreeStmt(stmt, SQL_DROP);\n//释放语句句柄\n```\n\n\n#### 7.4 ODBC的其他功能\n1. 动态SQL语句的预编译-动态参数传递功能\n2. 获取元数据特性\n    + 发现数据库中的所有关系的特性 以及\n    + 发现每一个查询结果的列的名字和类型等；\n3. 默认, 每一条SQL语句都被作为一个独立的能够自动提交的事务来处理。\n    + 应用程序可以关闭一个连接的自动提交特性\n        - `SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0)}`\n    + 此时事务要显式地给出提交和撤销的命令\n        - `SQLTransact(conn, SQL_COMMIT)` or `SQLTransact(conn, SQL_ROLLBACK)`\n\n\n<span id=\"id8\"><span>\n### 8. JDBC简介\n#### 8.1 JDBC定义\nJDBC：Java DataBase Connection，JDBC是一组Java版的应用程序接口API，提供了Java应用程序与数据库服务器的连接和通讯能力。\n* JDBCAPI分成两个程序包：\n    + Java.sql 核心API --J2SE(Java2标准版)的一部分。使用`java.sql.DriverManager`类、`java.sql.Driver`和`java.sql.Connection`接口连接到数据库\n    + Javax.sql 可选扩展API--J2EE(Java2企业版)的一部分。包含了基于`JNDI(JavaNamingandDirectoryInterface,Java命名和目录接口)`的资源，以及管理连接池、分布式事务等，使用DataSource接口连接到数据库。\n\n#### 8.2 JDBC的功能\n1. `java.sql.DriverManager`——处理驱动的调入并且对产生新数据库连接提供支持\n2. `Java.sql.Driver`——通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动。\n3. `java.sql.Connection`——代表对特定数据库的连接。\n4. `Try {…} Catch {…}` ——异常捕获及其处理\n5. `java.sql.Statement`——对特定的数据库执行SQL语句\n6. `java.sql.PreparedStatement` —— 用于执行预编译的SQL语句\n7. `java.sql.CallableStatement` ——用于执行对数据库内嵌过程的调用。\n8. `java.sql.ResultSet`——从当前执行的SQL语句中返回结果数据。\n\n#### 8.3 使用JDBC API访问数据库的过程\n1. 概念性的基本过程\n    + 打开一个连接；创建“Statement”对象，并设置查询语句；使用Statement对象执行查询，发送查询给数据库服务器和返回结果给应用程序；处理错误的例外机制\n2. 具体实施过程\n    1. •传递一个Driver给DriverManager，加载数据库驱动。\n        + `Class.forName()`\n    2. •通过URL得到一个Connection对象, 建立数据库连接\n        + `DriverManager.getConnection(sDBUrl)`\n        + `DriverManager.getConnection(sDBUrl,sDBUserID,sDBPassword)`\n    3. •接着创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库。\n        + `Statement stmt=con.createStatement()`\n    4. •查询返回一个ResultSet。\n        + `ResultSet rs=stmt.executeQuery(sSQL)`\n3. 示例：\n``` java\npublic static void JDBCexample(String dbid, String userid, String passwd)\n{ try { //错误捕获\n    Class.forName (\"oracle.jdbc.driver.OracleDriver\");\n    Connection conn = DriverManager.getConnection(\n        \"jdbc:oracle:thin:@db.yale.edu:1521:univdb\", userid, passwd);\n    //加载数据库驱动，建立数据库连接\n    Statement stmt = conn.createStatement();\n    //创建一个语句对象\n    … Do Actual Work ….\n    //进行SQL语句的执行与处理工作\n    stmt.close();\n    conn.close();\n    //关闭语句对象，关闭连接\n} catch (SQLException sqle) {\n    System.out.println(\"SQLException : \" + sqle); }\n}\n```\n\n4. 完整的示例程序\n``` java\npublic static void JDBCexample(String dbid, String userid, String passwd)\n{ try {\n    Class.forName (\"oracle.jdbc.driver.OracleDriver\");\n    Connection conn = DriverManager.getConnection(\n        \"jdbc:oracle:thin:@db.yale.edu:1521:univdb\", userid, passwd);\n    Statement stmt = conn.createStatement();\n    try {\n        stmt.executeUpdate( \"insert into instructor values\n        (‘77987', ‘Kim', ‘Physics’,98000)\");\n    } catch (SQLException sqle) {\n        System.out.println(\"插入错误:\" + sqle);\n    }\n    ResultSet rset = stmt.executeQuery(\n        \"select dept_name, avg(salary) from instructor group by dept_name\");\n    while ( rset.next() ) {\n        System.out.println(rset.getString(“dept_name\") + \" \" + rset.getFloat(2));\n    }\n    stmt.close();\n    conn.close();\n} catch (SQLException sqle) {\n    System.out.println(\"SQLException:\" + sqle);\n}\n}\n```\n\n\n<span id=\"id9\"><span>\n### 9. 嵌入式SQL-ODBC-JDBC三者比较\n执行一条SQL语句，读取执行的结果集合\n1. 嵌入式SQL的思维模式\n    1. 建立数据库连接\n    2. 声明一个游标\n    3. 打开游标\n    4. 读取一条记录(循环)\n    5. 关闭游标\n    6. 断开数据库连接\n2. ODBC的思维模式\n    1. 建立数据库连接\n    2. 分配语句句柄\n    3. 用句柄执行SQL\n    4. 建立高级语言变量与句柄属性的对应\n    5. 读取一条记录(循环)\n    6. 释放语句句柄\n    7. 断开数据库连接\n3. JDBC的思维模式\n    1. 建立数据库连接\n    2. 创建语句对象\n    3. 用语句对象执行SQL，并返回结果对象\n    4. 从结果对象获取一条记录\n    5. 提取对象的属性值传给高级语言变量(返回上一步)\n    6. 释放语句对象\n    7. 断开数据库连接\n\n* 相同点: 都是建立数据库连接, 执行sql, 处理结果, 释放连接, 流程基本一致\n* 不同点, 操作方式的不同:\n    + 嵌入式SQL按照语句进行操作\n    + ODBC按照函数来进行操作\n    + JDBC按照对象来进行操作\n\n\n","slug":"【数据库】嵌入式SQL语言","published":1,"updated":"2021-12-12T02:50:23.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6wi001zvcue9qvy45i1","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ul>\n<li>交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，</li>\n<li>然而，交互式SQL本身也有很多局限：<span id=\"more\"></span><ul>\n<li>从使用者角度：专业人员可熟练写出SQL语句，但大部分的普通用户并非可以</li>\n<li>从SQL本身角度：特别复杂的检索结果难以用一条交互式SQL语句完成，此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理</li>\n</ul>\n</li>\n<li>因此，高级语言+SQL语言：<ul>\n<li>既继承高级语言的过程控制性</li>\n<li>又结合SQL语言的复杂结果集操作的非过程性</li>\n<li>同时又为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作</li>\n</ul>\n</li>\n<li>嵌入式SQL语言<ul>\n<li>将SQL语言嵌入到某一种高级语言中使用</li>\n<li>这种高级语言，如C/C++, Java, PowerBuilder等，又称宿主语言(Host Language)</li>\n<li>嵌入在宿主语言中的SQL与前面介绍的交互式SQL有一些不同的操作方式</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h4><ol>\n<li><a href=\"#id1\">变量声明与数据库连接</a></li>\n<li><a href=\"#id2\">事务Transaction</a></li>\n<li><a href=\"#id3\">数据集与游标</a></li>\n<li><a href=\"#id4\">状态捕获及错误处理机制</a></li>\n<li><a href=\"#id5\">动态SQL</a></li>\n<li><a href=\"#id6\">数据字典与SQLDA</a></li>\n<li><a href=\"#id7\">ODBC简介</a></li>\n<li><a href=\"#id8\">JDBC简介</a></li>\n<li><a href=\"#id9\">嵌入式SQL-ODBC-JDBC三者比较</a></li>\n</ol>\n<p><span id=\"id1\"><span></p>\n<h3 id=\"1-变量声明与数据库连接\"><a href=\"#1-变量声明与数据库连接\" class=\"headerlink\" title=\"1. 变量声明与数据库连接\"></a>1. 变量声明与数据库连接</h3><ol>\n<li>以宿主语言<strong>C语言</strong>为例，对比交互式SQL语言与嵌入式SQL语言<ul>\n<li>交互式SQL:<code>select Sname, Sage from Student where Sname=&#39;张三&#39;;</code></li>\n<li>嵌入式SQL:<code>exec sql select Sname, Sage into :vSname, :vSage from Student where Sname=&#39;张三&#39;;</code></li>\n</ul>\n</li>\n<li>典型特点<ul>\n<li><strong>exec sql</strong>引导SQL语句: 提供给C编译器，以便对SQL语句预编译成C编译器可识别的语句</li>\n<li>增加一 <strong>into子句</strong>: 该子句用于指出接收SQL语句检索结果的程序变量</li>\n<li>由冒号引导的<strong>程序变量</strong>,如: ‘:vSname’, ‘:vSage’</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-1-变量的声明与使用\"><a href=\"#1-1-变量的声明与使用\" class=\"headerlink\" title=\"1.1 变量的声明与使用\"></a>1.1 变量的声明与使用</h4><ul>\n<li>在嵌入式SQL语句中可以出现宿主语言语句所使用的变量，这些变量需要特殊的声明：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">begin</span> <span class=\"keyword\">declare</span> section;</span><br><span class=\"line\">    <span class=\"type\">char</span> vSname[<span class=\"number\">10</span>], specName[<span class=\"number\">10</span>]<span class=\"operator\">=</span>&quot;张三&quot;;</span><br><span class=\"line\">    <span class=\"type\">int</span> vSage;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">end</span> <span class=\"keyword\">declare</span> section;</span><br></pre></td></tr></table></figure></li>\n<li>变量声明和赋值中，要注意：<ul>\n<li>宿主程序的字符串变量长度应比字符型字段的长度多1个。因宿主程序的字符串尾部多一个终止符为’\\0’，而程序中用双引号来描述。</li>\n<li>宿主程序变量类型与数据库字段类型之间有些是有差异的,有些DBMS可支持自动转换，有些不能。</li>\n</ul>\n</li>\n<li>声明的变量，可以在宿主程序中赋值，然后传递给SQL语句的where等子句中，以使SQL语句能够按照指定的要求(可变化的)进行检索。</li>\n<li>嵌入式比交互式SQL语句灵活了一些：只需改一下变量值，SQL语句便可反复使用，以检索出不同结果。</li>\n<li>示例：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">begin</span> <span class=\"keyword\">declare</span> section;</span><br><span class=\"line\">    <span class=\"type\">char</span> vSname[<span class=\"number\">10</span>], specName[<span class=\"number\">10</span>]<span class=\"operator\">=</span>&quot;张三&quot;;</span><br><span class=\"line\">    <span class=\"type\">int</span> vSage;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">end</span> <span class=\"keyword\">declare</span> section;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>用户可在此处基于键盘输入给specName赋值</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">select</span> Sname, Sage <span class=\"keyword\">into</span> :vSname, :vSage <span class=\"keyword\">from</span> Student <span class=\"keyword\">where</span> Sname <span class=\"operator\">=</span> :specName;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>比较相应的交互式<span class=\"keyword\">SQL</span>语句：</span><br><span class=\"line\"><span class=\"keyword\">select</span> Sname, Sage <span class=\"keyword\">from</span> Student <span class=\"keyword\">where</span> Sname <span class=\"operator\">=</span> <span class=\"string\">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"1-2-程序与数据库的连接和断开\"><a href=\"#1-2-程序与数据库的连接和断开\" class=\"headerlink\" title=\"1.2 程序与数据库的连接和断开\"></a>1.2 程序与数据库的连接和断开</h4><h5 id=\"1-2-1-数据库的连接connect\"><a href=\"#1-2-1-数据库的连接connect\" class=\"headerlink\" title=\"1.2.1 数据库的连接connect\"></a>1.2.1 数据库的连接connect</h5><p>在嵌入式SQL程序执行之前，首先要与数据库进行连接, 不同DBMS，具体连接语句的语法略有差异</p>\n<ol>\n<li>SQL标准中建议的连接语法为：<ul>\n<li><code>execsql connecttotarget-server asconnect-name useruser-name;</code></li>\n<li>或 <code>execsql connecttodefault;</code></li>\n</ul>\n</li>\n<li>Oracle中数据库连接:<ul>\n<li><code>execsql connect:user_name identified by :user_pwd;</code></li>\n</ul>\n</li>\n<li>DB2 UDB中数据库连接:<ul>\n<li><code>execsql connecttomydb user:user_name using:user_pwd;</code></li>\n</ul>\n</li>\n</ol>\n<h5 id=\"1-2-1-数据库的断开disconnect\"><a href=\"#1-2-1-数据库的断开disconnect\" class=\"headerlink\" title=\"1.2.1 数据库的断开disconnect\"></a>1.2.1 数据库的断开disconnect</h5><p>在嵌入式SQL程序执行之后，需要与数据库断开连接</p>\n<ol>\n<li>SQL标准中建议的断开连接的语法为：<ul>\n<li><code>exec sql disconnect connect-name;</code></li>\n<li>或 <code>exec sql disconnect current;</code></li>\n</ul>\n</li>\n<li>Oracle中断开连接:<ul>\n<li><code>exec sql commit release;</code></li>\n<li>或 <code>exec sql rollback release;</code></li>\n</ul>\n</li>\n<li>DB2 UDB中断开连接:<ul>\n<li><code>exec sql connect reset;</code></li>\n<li><code>exec sql disconnect current;</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-3-SQL执行的提交与撤消\"><a href=\"#1-3-SQL执行的提交与撤消\" class=\"headerlink\" title=\"1.3 SQL执行的提交与撤消\"></a>1.3 SQL执行的提交与撤消</h4><p>SQL语句在执行过程中，必须有提交和撤消语句才能确认其操作结果</p>\n<ol>\n<li>SQL执行的提交：<ul>\n<li><code>execsql commitwork;</code></li>\n</ul>\n</li>\n<li>SQL执行的撤消：<ul>\n<li><code>execsql rollbackwork;</code></li>\n</ul>\n</li>\n<li>为此，很多DBMS都设计了捆绑提交/撤消与断开连接在一起的语句,以保证在断开连接之前使用户确认提交或撤消先前的工作，例如Oracle中：<ul>\n<li><code>execsql commitrelease;</code></li>\n<li>或 <code>execsql rollbackrelease;</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id2\"><span></p>\n<h3 id=\"2-事务Transaction\"><a href=\"#2-事务Transaction\" class=\"headerlink\" title=\"2. 事务Transaction\"></a>2. 事务Transaction</h3><ol>\n<li>从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务</li>\n<li>从微观角度，或者从DBMS角度：事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</li>\n<li>简单来说：事务是作为单个逻辑工作单元执行的一系列操作；多个操作作为一个整体向系统提交，要么都执行，要么都不执行；<strong>事务是一个不可分割的工作逻辑单元</strong>。</li>\n</ol>\n<h4 id=\"2-1-事务的特性-ACID\"><a href=\"#2-1-事务的特性-ACID\" class=\"headerlink\" title=\"2.1 事务的特性: ACID\"></a>2.1 事务的特性: ACID</h4><ol>\n<li><strong>原子性</strong>Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对DB而言，要么都执行，要么都不执行</li>\n<li><strong>一致性</strong>Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作规则，它是进一步由隔离性来保证的</li>\n<li><strong>隔离性</strong>Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;或者先执行了T2, 再执行T1。</li>\n<li><strong>持久性</strong>Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的。</li>\n</ol>\n<blockquote>\n<p>换句话说：具有ACID特性的若干数据库基本操作的组合体被称为事务。</p>\n</blockquote>\n<p><span id=\"id3\"><span></p>\n<h3 id=\"3-数据集与游标\"><a href=\"#3-数据集与游标\" class=\"headerlink\" title=\"3. 数据集与游标\"></a>3. 数据集与游标</h3><p>读取单行结果处理与多行结果处理的差异：Into子句与游标(Cursor)</p>\n<ol>\n<li>检索单行结果，可将结果直接传送到宿主程序的变量中(Into)<ul>\n<li>示例：<code>exec sql select Sname,Sage into :vSname,:vSage from Student where Sname = :specName;</code></li>\n</ul>\n</li>\n<li>检索多行结果，则需使用游标(Cursor)<ul>\n<li>游标是指向某检索记录集的指针</li>\n<li>通过这个指针的移动，每次读一行，处理一行，再读一行… , 直至处理完毕</li>\n<li>读一行操作是通过Fetch…into语句实现的：每一次Fetch, 都是先向下移动指针，然后再读取</li>\n<li>记录集有结束标识EOF, 用来标记后面已没有记录了</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>游标(Cursor)的使用需要先定义、再打开(执行)、接着一条接一条处理，最后再关闭</li>\n<li>游标可以定义一次，多次打开(多次执行)，多次关闭</li>\n</ul>\n<h4 id=\"3-1-游标的使用方法\"><a href=\"#3-1-游标的使用方法\" class=\"headerlink\" title=\"3.1 游标的使用方法\"></a>3.1 游标的使用方法</h4><ol>\n<li><p>Cursor的定义：declare cursor</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">DECLARE</span> cursor_name <span class=\"keyword\">CURSOR</span> <span class=\"keyword\">FOR</span></span><br><span class=\"line\">    Subquery</span><br><span class=\"line\">    [<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> result_column [<span class=\"keyword\">ASC</span> <span class=\"operator\">|</span> <span class=\"keyword\">DESC</span>][, result_column …]</span><br><span class=\"line\">    [<span class=\"keyword\">FOR</span> [ READ <span class=\"keyword\">ONLY</span> <span class=\"operator\">|</span> UPDATE [<span class=\"keyword\">OF</span> columnname [, columnname…]]]];</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例:</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">declare</span> cur_student <span class=\"keyword\">cursor</span> <span class=\"keyword\">for</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> Sno, Sname, Sclass <span class=\"keyword\">from</span> Student <span class=\"keyword\">where</span> Sclass<span class=\"operator\">=</span> :vClass</span><br><span class=\"line\">    <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> Sno</span><br><span class=\"line\">    <span class=\"keyword\">for</span> read <span class=\"keyword\">only</span> ;</span><br></pre></td></tr></table></figure></li>\n<li><p>Cursor的打开和关闭：open cursor //close cursor</p>\n<ul>\n<li>EXEC SQL OPEN cursor_name;</li>\n<li>EXEC SQL CLOSE cursor_name;</li>\n</ul>\n</li>\n<li><p>Cursor的数据读取：Fetch</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">FETCH</span> cursor_name</span><br><span class=\"line\">    <span class=\"keyword\">INTO</span> host<span class=\"operator\">-</span>variable , [host<span class=\"operator\">-</span>variable, …];</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例:</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">declare</span> cur_student <span class=\"keyword\">cursor</span> <span class=\"keyword\">for</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> Sno, Sname, Sclass <span class=\"keyword\">from</span> Student <span class=\"keyword\">where</span> Sclass<span class=\"operator\">=</span> :vClass</span><br><span class=\"line\">    <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> Sno <span class=\"keyword\">for</span> read <span class=\"keyword\">only</span> ;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">open</span> cur_student;</span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">fetch</span> cur_student <span class=\"keyword\">into</span> :vSno, :vSname, :vSage</span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">close</span> cur_student;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"3-2-可滚动游标\"><a href=\"#3-2-可滚动游标\" class=\"headerlink\" title=\"3.2 可滚动游标\"></a>3.2 可滚动游标</h4><ol>\n<li>ODBC支持的可滚动Cursor<ul>\n<li>标准的游标始终是自开始向结束方向移动的，每fetch一次，向结束方向移动一次；一条记录只能被访问一次；再次访问该记录只能关闭游标后重新打开</li>\n<li>ODBC(OpenDataBase Connectivity)是一种跨DBMS的DB操作平台，它在应用程序与实际的DBMS之间提供了一种通用接口</li>\n<li>许多实际的DBMS并不支持可滚动游标，但通过ODBC可以使用该功能</li>\n</ul>\n</li>\n<li>可滚动游标是可使游标指针在记录集之间灵活移动、使每条记录可以反复被访问的一种游标<ul>\n<li>可滚动游标移动时需判断是否到结束位置，或到起始位置<ul>\n<li>可通过判断是否到EOF位置(最后一条记录的后面),或BOF位置(起始记录的前面)</li>\n<li>如果不需区分，可通过whenevernotfound语句设置来检测</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">DECLARE</span> cursor_name [<span class=\"keyword\">INSENSITIVE</span>] [<span class=\"keyword\">SCROLL</span>] <span class=\"keyword\">CURSOR</span></span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> <span class=\"keyword\">HOLD</span>] <span class=\"keyword\">FOR</span> Subquery</span><br><span class=\"line\">[<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> result_column [<span class=\"keyword\">ASC</span> <span class=\"operator\">|</span> <span class=\"keyword\">DESC</span>][, result_column …]</span><br><span class=\"line\">[<span class=\"keyword\">FOR</span> READ <span class=\"keyword\">ONLY</span> <span class=\"operator\">|</span> <span class=\"keyword\">FOR</span> UPDATE <span class=\"keyword\">OF</span> columnname [,</span><br><span class=\"line\">columnname ]…];</span><br><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">FETCH</span></span><br><span class=\"line\">[ NEXT <span class=\"operator\">|</span> PRIOR <span class=\"operator\">|</span> <span class=\"keyword\">FIRST</span> <span class=\"operator\">|</span> <span class=\"keyword\">LAST</span></span><br><span class=\"line\"><span class=\"operator\">|</span> [ABSOLUTE <span class=\"operator\">|</span> RELATIVE] value_spec ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> cursor_name <span class=\"keyword\">INTO</span> host<span class=\"operator\">-</span>variable [, host<span class=\"operator\">-</span>variable …];</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>NEXT</code>向结束方向移动一条；</li>\n<li><code>PRIOR</code>向开始方向移动一条；</li>\n<li><code>FIRST</code>回到第一条；</li>\n<li><code>LAST</code>移动到最后一条；</li>\n<li><code>ABSOLUTvalue_spec</code>定向检索指定位置的行,value_spec由1至当前记录集最大值；</li>\n<li><code>RELATIVEvalue_spec</code>相对当前记录向前或向后移动，value_spec为正数向结束方向移动，为负数向开始方向移动</li>\n</ul>\n<h4 id=\"3-3-数据库记录的增删改\"><a href=\"#3-3-数据库记录的增删改\" class=\"headerlink\" title=\"3.3 数据库记录的增删改\"></a>3.3 数据库记录的增删改</h4><ol>\n<li>数据库记录的删除<ul>\n<li>一种是查找删除(与交互式DELETE语句相同)，一种是定位删除</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> tablename [corr_name]</span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> search_condition <span class=\"operator\">|</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">CURRENT</span> <span class=\"keyword\">OF</span> cursor_name;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例：查找删除</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> customers c <span class=\"keyword\">where</span> c.city <span class=\"operator\">=</span> ‘Harbin’ <span class=\"keyword\">and</span></span><br><span class=\"line\">    <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> ( <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> orders o <span class=\"keyword\">where</span> o.cid <span class=\"operator\">=</span> c.cid);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例：定位删除</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">declare</span> delcust <span class=\"keyword\">cursor</span> <span class=\"keyword\">for</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> cid <span class=\"keyword\">from</span> customers c <span class=\"keyword\">where</span> c.city <span class=\"operator\">=</span>‘harbin’ <span class=\"keyword\">and</span></span><br><span class=\"line\">    <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> ( <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> orders o <span class=\"keyword\">where</span> o.cid <span class=\"operator\">=</span> c.cid)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> update <span class=\"keyword\">of</span> cid;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">open</span> delcust</span><br><span class=\"line\">While (<span class=\"literal\">TRUE</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">fetch</span> delcust <span class=\"keyword\">into</span> :cust_id;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> customers <span class=\"keyword\">where</span> <span class=\"keyword\">current</span> <span class=\"keyword\">of</span> delcust ; &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>数据库记录的更新<ul>\n<li>一种是查找更新(与交互式Update语句相同)，一种是定位更新</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> UPDATE tablename [corr_name]</span><br><span class=\"line\">    <span class=\"keyword\">SET</span> columnname <span class=\"operator\">=</span> expr [, columnname <span class=\"operator\">=</span> expr …]</span><br><span class=\"line\">    [ <span class=\"keyword\">WHERE</span> search_condition ] <span class=\"operator\">|</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">CURRENT</span> <span class=\"keyword\">OF</span> cursor_name;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例：查找更新</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> update student s <span class=\"keyword\">set</span> sclass <span class=\"operator\">=</span> ‘<span class=\"number\">035102</span>’</span><br><span class=\"line\">    <span class=\"keyword\">where</span> s.sclass <span class=\"operator\">=</span> ‘<span class=\"number\">034101</span>’</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> 示例：定位更新</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">declare</span> stud <span class=\"keyword\">cursor</span> <span class=\"keyword\">for</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student s <span class=\"keyword\">where</span> s.sclass <span class=\"operator\">=</span>‘<span class=\"number\">034101</span>’</span><br><span class=\"line\">    <span class=\"keyword\">for</span> update <span class=\"keyword\">of</span> sclass;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">open</span> stud</span><br><span class=\"line\">While (<span class=\"literal\">TRUE</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">fetch</span> stud <span class=\"keyword\">into</span> :vSno, :vSname, :vSclass;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> update student <span class=\"keyword\">set</span> sclass <span class=\"operator\">=</span> ‘<span class=\"number\">035102</span>’ <span class=\"keyword\">where</span> <span class=\"keyword\">current</span> <span class=\"keyword\">of</span> stud ; &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>数据库记录的插入<ul>\n<li>只有一种类型的插入语句</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> tablename [ (columnname [,columnname, …] )]</span><br><span class=\"line\">    [ <span class=\"keyword\">VALUES</span> (expr [ , expr , …] ) <span class=\"operator\">|</span> subqurey ] ;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例：插入语句</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> student ( sno, sname, sclass)</span><br><span class=\"line\">    <span class=\"keyword\">values</span> (‘<span class=\"number\">03510128</span>’, ‘张三’, ‘<span class=\"number\">035101</span>’) ;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例：插入语句</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> masterstudent ( sno, sname, sclass)</span><br><span class=\"line\">    <span class=\"keyword\">select</span> sno, sname, sclass <span class=\"keyword\">from</span> student;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><span id=\"id4\"><span></p>\n<h3 id=\"4-状态捕获及错误处理机制\"><a href=\"#4-状态捕获及错误处理机制\" class=\"headerlink\" title=\"4. 状态捕获及错误处理机制\"></a>4. 状态捕获及错误处理机制</h3><h4 id=\"4-1-基本机制\"><a href=\"#4-1-基本机制\" class=\"headerlink\" title=\"4.1 基本机制\"></a>4.1 基本机制</h4><ul>\n<li><p>状态，是嵌入式SQL语句的执行状态，尤其指一些出错状态；有时程序需要知道这些状态并对这些状态进行处理</p>\n</li>\n<li><p>嵌入式 SQL程序中，状态捕获及处理有三部分构成</p>\n<ol>\n<li>设置SQL通信区:一般在嵌入式SQL程序的开始处便设置<ul>\n<li><code>exec sql include sqlca;</code></li>\n</ul>\n</li>\n<li>设置状态捕获语句:在嵌入式SQL程序的任何位置都可设置；可多次设置；但有作用域<ul>\n<li><code>exec sql whenever sqlerror goto report_error;</code></li>\n</ul>\n</li>\n<li>状态处理语句:某一段程序以应对SQL操作的某种状态<ul>\n<li><code>report_error: exec sql rollback;</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>SQL通信区: SQLCA</p>\n<ol>\n<li>SQLCA是一个已被声明过的具C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句执行的状态，便于宿主程序读取与处理</li>\n<li>SQLCA是DBMS(执行SQL语句)与宿主程序之间交流的桥梁之一</li>\n</ol>\n</li>\n<li><p>状态捕获语句: <code>exec sql whenever condition action;</code></p>\n<ul>\n<li>Whenever语句的作用是设置一个“条件陷阱”, 该条语句会对其后面的所有由Exec SQL语句所引起的对数据库系统的调用自动检查它是否满足条件(由condition指出).<ul>\n<li>SQLERROR: 检测是否有SQL语句出错。其具体意义依赖于特定的DBMS</li>\n<li>NOT FOUND: 执行某一SQL语句后，没有相应的结果记录出现</li>\n<li>SQLWARNING: 不是错误，但应引起注意的条件</li>\n</ul>\n</li>\n<li>如果满足condition, 则要采取一些动作(由action指出)<ul>\n<li>CONTINUE: 忽略条件或错误，继续执行</li>\n<li>GOTO 标号: 转移到标号所指示的语句，去进行相应的处理</li>\n<li>STOP: 终止程序运行、撤消当前的工作、断开数据库的连接</li>\n<li>DO函数或 CALL函数: 调用宿主程序的函数进行处理，函数返回后从引发该condition的Exec SQL语句之后的语句继续进行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>状态捕获语句Whenever的作用范围是其后的所有Exec SQL语句，一直到程序中出现另一条相同条件的Whenever语句为止，后面的将覆盖前面的。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror stop;</span><br><span class=\"line\">    … …</span><br><span class=\"line\">    goto s1</span><br><span class=\"line\">    … …</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror continue;</span><br><span class=\"line\">    s1: <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> update agents <span class=\"keyword\">set</span> <span class=\"keyword\">percent</span> <span class=\"operator\">=</span> <span class=\"keyword\">percent</span> <span class=\"operator\">+</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    … …</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>S1标号指示的语句受第二个<span class=\"keyword\">Whenever</span>语句约束。</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>注意：作用域是语句在程序中的位置，而不是控制流程(因是预编译程序处理条件陷阱)</span><br></pre></td></tr></table></figure></li>\n<li><p>状态捕获语句Whenever的使用容易引发无限循环</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror goto handle_error;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> customers(cid <span class=\"type\">char</span>(<span class=\"number\">4</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    cname <span class=\"type\">varchar</span>(<span class=\"number\">13</span>), … … );</span><br><span class=\"line\">    … …</span><br><span class=\"line\">    handle_error:</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror continue;<span class=\"operator\">/</span><span class=\"operator\">/</span> 控制是否无限循环：无，则可能；有，则不会</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">drop</span> customers;</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">disconnect</span>;</span><br><span class=\"line\">        fprintf(stderr,”could <span class=\"keyword\">not</span> <span class=\"keyword\">create</span> customers <span class=\"keyword\">table</span>\\n”);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"4-2-状态信息\"><a href=\"#4-2-状态信息\" class=\"headerlink\" title=\"4.2 状态信息\"></a>4.2 状态信息</h4><p>典型DBMS系统记录状态信息的三种方法</p>\n<ul>\n<li>状态记录:<ol>\n<li><code>sqlcode</code>: 典型DBMS都提供一个sqlcode变量来记录其执行sql语句的状态，但不同DBMS定义的sqlcode值所代表的状态意义可能是不同的。<ul>\n<li>sqlcode== 0, successful call;</li>\n<li>sqlcode &lt; 0, error, e.g., from connect, database does not exist , –16;</li>\n<li>sqlcode &gt; 0, warning, e.g., no rows retrieved from fetch</li>\n</ul>\n</li>\n<li><code>sqlca.sqlcode</code>: 支持SQLCA的产品一般要在SQLCA中填写sqlcode来记录上述信息; 除此而外，sqlca还有其他状态信息的记录</li>\n<li><code>sqlstate</code>: 有些DBMS提供的记录状态信息的变量是sqlstate或sqlca.sqlstate</li>\n</ol>\n</li>\n<li>当我们不需明确知道错误类型，而只需知道发生错误与否，则我们只要使用前述的状态捕获语句即可，而无需关心状态记录变量(隐式状态处理)</li>\n<li>但我们程序中如要自行处理不同状态信息时，则需要知道以上信息，但也需知道正确的操作方法(显式状态处理)</li>\n</ul>\n<h4 id=\"4-3-程序自身进行错误信息的处理\"><a href=\"#4-3-程序自身进行错误信息的处理\" class=\"headerlink\" title=\"4.3 程序自身进行错误信息的处理\"></a>4.3 程序自身进行错误信息的处理</h4><p>正确的显式状态处理示例:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">begin</span> declar section;</span><br><span class=\"line\">    <span class=\"type\">char</span> <span class=\"keyword\">SQLSTATE</span>[<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">end</span> <span class=\"keyword\">declare</span> section;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror goto handle_error;</span><br><span class=\"line\">… …</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror continue;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> custs</span><br><span class=\"line\">    (cid <span class=\"type\">char</span>(<span class=\"number\">4</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>, cname <span class=\"type\">varchar</span>(<span class=\"number\">13</span>), … … );</span><br><span class=\"line\">if (strcmp(<span class=\"keyword\">SQLSTATE</span>, “<span class=\"number\">82100</span>”)<span class=\"operator\">=</span><span class=\"operator\">=</span><span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"operator\">&lt;</span>处理<span class=\"number\">82100</span>错误的程序<span class=\"operator\">&gt;</span></span><br><span class=\"line\">    … …</span><br></pre></td></tr></table></figure>\n<p>上述的if语句是能被执行的，因为createtable发生错误时是继续向下执行的。</p>\n<p><span id=\"id5\"><span></p>\n<h3 id=\"5-动态SQL\"><a href=\"#5-动态SQL\" class=\"headerlink\" title=\"5. 动态SQL\"></a>5. 动态SQL</h3><h4 id=\"5-1-动态SQL的概念\"><a href=\"#5-1-动态SQL的概念\" class=\"headerlink\" title=\"5.1 动态SQL的概念\"></a>5.1 动态SQL的概念</h4><p>动态SQL是相对于静态SQL而言的</p>\n<ul>\n<li>静态SQL特点：SQL语句在程序中已经按要求写好，只需要把一些参数通过变量(高级语言程序语句中不带冒号) 传送给嵌入式SQL语句即可(嵌入式SQL语句中带冒号)</li>\n<li>动态SQL特点：SQL语句可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍旧可以传递变量</li>\n</ul>\n<h4 id=\"5-2-动态SQL的两种执行方式\"><a href=\"#5-2-动态SQL的两种执行方式\" class=\"headerlink\" title=\"5.2 动态SQL的两种执行方式\"></a>5.2 动态SQL的两种执行方式</h4><p>如SQL语句已经被构造在host-variable字符串变量中,则：</p>\n<ol>\n<li><strong>立即执行语句</strong>: 运行时编译并执行<ul>\n<li><code>EXEC SQL EXECUTE IMMEDIATE :host-variable;</code></li>\n</ul>\n</li>\n<li><strong>Prepare-Execute-Using语句</strong>:PREPARE语句先编译，编译后的SQL语句允许动态参数，EXECUTE语句执行，用USING语句将动态参数值传送给编译好的SQL语句<ul>\n<li><code>EXEC SQL PREPARE sql_temp FROM :host-variable;</code></li>\n<li><code>EXEC SQL EXECUTE sql_temp USING :cond-variable</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id6\"><span></p>\n<h3 id=\"6-数据字典与SQLDA\"><a href=\"#6-数据字典与SQLDA\" class=\"headerlink\" title=\"6. 数据字典与SQLDA\"></a>6. 数据字典与SQLDA</h3><h4 id=\"6-1-数据字典的概念\"><a href=\"#6-1-数据字典的概念\" class=\"headerlink\" title=\"6.1 数据字典的概念\"></a>6.1 数据字典的概念</h4><p>数据字典(Data dictionary)，又称为系统目录(System Catalogs)</p>\n<ul>\n<li>是系统维护的一些表或视图的集合，这些表或视图存储了数据库中各类对象的定义信息，这些对象包括用Create语句定义的表、列、索引、视图、权限、约束等,这些信息又称数据库的元数据–关于数据的数据。</li>\n<li>不同DBMS术语不一样：数据字典(DataDictionary(Oracle))、目录表(DB2UDB)、系统目录(INFORMIX)、系统视图(X/Open)</li>\n<li>不同DBMS中系统目录存储方式可能是不同的,但会有一些信息对DBA公开。这些公开的信息,DBA可以使用一些特殊的SQL命令来检索。</li>\n</ul>\n<h4 id=\"6-2-数据字典的内容构成\"><a href=\"#6-2-数据字典的内容构成\" class=\"headerlink\" title=\"6.2 数据字典的内容构成\"></a>6.2 数据字典的内容构成</h4><p>数据字典通常存储的是数据库和表的元数据，即模式本身的信息：</p>\n<ol>\n<li>与关系相关的信息<ul>\n<li>关系名字</li>\n<li>每一个关系的属性名及其类型</li>\n<li>视图的名字及其定义</li>\n<li>完整性约束</li>\n</ul>\n</li>\n<li>用户与账户信息，包括密码</li>\n<li>统计与描述性数据：如每个关系中元组的数目</li>\n<li>物理文件组织信息：<ul>\n<li>关系是如何存储的(顺序/无序/散列等)</li>\n<li>关系的物理位置</li>\n</ul>\n</li>\n<li>索引相关的信息</li>\n</ol>\n<h4 id=\"6-3-数据字典的结构\"><a href=\"#6-3-数据字典的结构\" class=\"headerlink\" title=\"6.3 数据字典的结构\"></a>6.3 数据字典的结构</h4><ol>\n<li>也是存储在磁盘上的关系</li>\n<li>专为内存高效访问设计的特定的数据结构</li>\n</ol>\n<ul>\n<li>可能的字典数据结构<ul>\n<li><code>Relation_metadata</code> = <code>(relation_name, number_of_attributes, storage_organization, location)</code></li>\n<li><code>Attribute_metadata</code> = <code>(attribute_name, relation_name, domain_type, position, length)</code></li>\n<li><code>User_metadata</code> = <code>(user_name, encrypted_password, group)</code></li>\n<li><code>Index_metadata</code> = <code>(index_name, relation_name, index_type, index_attributes)</code></li>\n<li><code>View_metadata</code> = <code>(view_name, definition)</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-4-X-Open标准的系统目录\"><a href=\"#6-4-X-Open标准的系统目录\" class=\"headerlink\" title=\"6.4 X/Open标准的系统目录\"></a>6.4 X/Open标准的系统目录</h4><ol>\n<li>X/Open标准中有一个目录表Info_Schem.Tables, 该表中的一行是一个已经定义的表的有关信息<ul>\n<li><code>Table_Schem</code>：表的模式名(通常是表所有者的用户名)</li>\n<li><code>Table_Name</code>：表名</li>\n<li><code>Table_Type</code>：<code>&#39;Base_Table&#39;</code>或<code>&#39;View&#39;</code></li>\n</ul>\n</li>\n<li>可以使用SQL语句来访问这个表中的信息，比如了解已经定义了哪些表，可如下进行：<ul>\n<li><code>Select Table_Name From Tables;</code></li>\n</ul>\n</li>\n<li>模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而不混淆。</li>\n<li>一般而言，一个用户有一个模式。可以使用CreateSchema语句来创建模式(用法参见相关文献)，在CreateTable等语句可以使用所定义的模式名称。</li>\n</ol>\n<h4 id=\"6-5-Oracle的数据字典\"><a href=\"#6-5-Oracle的数据字典\" class=\"headerlink\" title=\"6.5 Oracle的数据字典\"></a>6.5 Oracle的数据字典</h4><ol>\n<li>Oracle数据字典由视图组成，分为三种不同形式，由不同的前缀标识<ul>\n<li><code>USER_</code> :用户视图，用户所拥有的对象，在用户模式中</li>\n<li><code>ALL_</code>  :扩展的用户视图，用户可访问的对象</li>\n<li><code>DBA_</code>  :DBA视图(所有用户都可访问的DBA对象的子集)</li>\n</ul>\n</li>\n<li>Oracle数据字典中定义了三个视图<code>USER_Tables</code>,<code>ALL_Tables</code>,和<code>DBA_Tables</code>供DBA和用户使用数据字典中关于<strong>表的信息</strong></li>\n<li>同样,Oracle数据字典中也定义了三个视图<code>USER_TAB_Columns</code>,<code>ALL_TAB_Columns</code>(<code>Accessible_Columns</code>),和<code>DBA_TAB_Columns</code>供DBA和用户使用数据字典中关于表的<strong>列的信息</strong></li>\n<li>可以使用SQL语句来访问这些表中的信息：<ul>\n<li><code>Select Column_Name From ALL_TAB_Columns Where Table_Name = ‘STUDENT’;</code></li>\n</ul>\n</li>\n<li>Oracle数据字典中还定义了其他视图<ul>\n<li><code>TABLE_PRIVILEDGE</code>(或<code>ALL_TAB_GRANTS</code>)</li>\n<li><code>COLUMN_PRIVILEDGE</code>(或<code>ALL_COL_GRANTS</code>)可访问表的权限，列的权限</li>\n<li><code>CONSTRAINT_DEFS</code>(或<code>ALL_CONSTRAINTS</code>)可访问表的各种约束</li>\n</ul>\n</li>\n<li>可以使用下述命令获取Oracle定义的所有视图信息<ul>\n<li><code>Select view_name from all_views where owner = ‘SYS’ and view_name like ‘ALL_%’ or view_name like ‘USER_%’;</code></li>\n</ul>\n</li>\n<li>如果用户使用Oracle,可使用其提供的<code>SQL*PLUS</code>进行交互式访问</li>\n<li>动态SQL: 表和列都已知，动态构造检索条件。</li>\n<li>动态SQL:检索条件可动态构造，表和列也可动态构造。</li>\n</ol>\n<h4 id=\"6-6-SQLDA\"><a href=\"#6-6-SQLDA\" class=\"headerlink\" title=\"6.6 SQLDA\"></a>6.6 SQLDA</h4><p>构造复杂的动态SQL需要了解数据字典及SQLDA，已获知关系模式信息</p>\n<ol>\n<li>SQLDA: SQLDescriptorArea,SQL描述符区域。<ul>\n<li>SQLDA是一个内存数据结构，内可装载关系模式的定义信息，如列的数目，每一列的名字和类型等等</li>\n<li>通过读取SQLDA信息可以进行更为复杂的动态SQL的处理</li>\n<li>不同DBMS提供的SQLDA格式并不是一致的。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id7\"><span></p>\n<h3 id=\"7-ODBC简介\"><a href=\"#7-ODBC简介\" class=\"headerlink\" title=\"7. ODBC简介\"></a>7. ODBC简介</h3><h4 id=\"7-1-ODBC定义\"><a href=\"#7-1-ODBC定义\" class=\"headerlink\" title=\"7.1 ODBC定义\"></a>7.1 ODBC定义</h4><p>ODBC：Open DataBase Connection，ODBC是一种标准—不同语言的应用程序与不同数据库服务器之间通讯的标准。</p>\n<ul>\n<li>一组API(应用程序接口)，支持应用程序与数据库服务器的交互</li>\n<li>应用程序通过调用ODBC API, 实现<ol>\n<li>与数据服务器的连接</li>\n<li>向数据库服务器发送SQL命令</li>\n<li>一条一条的提取数据库检索结果中的元组传递给应用程序的变量</li>\n</ol>\n</li>\n<li>具体的DBMS提供一套驱动程序，即Driver库函数，供ODBC调用，以便实现数据库与应用程序的连接。</li>\n<li>ODBC可以配合很多高级语言来使用，如C,C++, C#, Visual Basic, PowerBuilder等等；</li>\n</ul>\n<h4 id=\"7-2-通过ODBC连接数据库\"><a href=\"#7-2-通过ODBC连接数据库\" class=\"headerlink\" title=\"7.2 通过ODBC连接数据库\"></a>7.2 通过ODBC连接数据库</h4><ol>\n<li>ODBC应用前，需要确认具体DBMS Driver被安装到ODBC环境中</li>\n<li>当应用程序调用ODBC API时，ODBC API会调用具体DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯，执行相应的请求动作并返回检索结果</li>\n<li>ODBC应用程序首先要分配一个SQL环境，再产生一个数据库连接句柄</li>\n<li>应用程序使用SQLConnect()，打开一个数据库连接，SQLConnect()的具体参数:<ul>\n<li><code>connection handle</code>, 连接句柄</li>\n<li><code>the server</code>，要连接的数据库服务器</li>\n<li><code>the user identifier</code>，用户</li>\n<li><code>password</code> ，密码</li>\n<li><code>SQL_NTS</code> 类型说明前面的参数是空终止的字符串</li>\n</ul>\n</li>\n<li>示例<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ODBCexample()&#123;</span><br><span class=\"line\">    RETCODE error; <span class=\"comment\">/* 返回状态吗 */</span></span><br><span class=\"line\">    HENV env; <span class=\"comment\">/* 环境变量 */</span></span><br><span class=\"line\">    HDBC conn; <span class=\"comment\">/* 连接句柄 */</span></span><br><span class=\"line\">    SQLAllocEnv(<span class=\"operator\">&amp;</span>env);</span><br><span class=\"line\">    SQLAllocConnect(env, <span class=\"operator\">&amp;</span>conn);</span><br><span class=\"line\">    <span class=\"operator\">/</span><span class=\"operator\">/</span>分配数据库连接环境</span><br><span class=\"line\">    SQLConnect(conn, &quot;aura.bell-labs.com&quot;, SQL_NTS, &quot;avi&quot;, SQL_NTS, avipasswd&quot;, SQL_NTS);</span><br><span class=\"line\">    //打开一个数据库连接</span><br><span class=\"line\">    &#123; …. Do actual work … &#125;</span><br><span class=\"line\">    //与数据库通讯</span><br><span class=\"line\">    SQLDisconnect(conn);</span><br><span class=\"line\">    SQLFreeConnect(conn);</span><br><span class=\"line\">    SQLFreeEnv(env);</span><br><span class=\"line\">    //断开连接与释放环境</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"7-3-通过ODBC与数据库服务器进行通讯\"><a href=\"#7-3-通过ODBC与数据库服务器进行通讯\" class=\"headerlink\" title=\"7.3 通过ODBC与数据库服务器进行通讯\"></a>7.3 通过ODBC与数据库服务器进行通讯</h4><ol>\n<li>应用程序使用SQLExecDirect()向数据库发送SQL命令；</li>\n<li>使用SQLFetch()获取产生的结果元组；</li>\n<li>使用SQLBindCol()绑定C语言变量与结果中的属性<ul>\n<li>当获取一个元组时，属性值会自动地传送到相应的C语言变量中</li>\n</ul>\n</li>\n<li>SQLBindCol()的参数：<ul>\n<li>ODBC定义的stmt变量,查询结果中的属性位置</li>\n<li>SQL到C的类型变换,变量的地址.</li>\n<li>对于类似字符数组一样的可变长度类型，应给出<ul>\n<li>•变量的最大长度</li>\n<li>•当获取到一个元组后，实际长度的存储位置.</li>\n<li>•注:当返回实际长度为负数，说明是一个空值。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>示例<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> branchname[<span class=\"number\">80</span>]; <span class=\"type\">float</span> balance;</span><br><span class=\"line\"><span class=\"type\">int</span> lenOut1, lenOut2;</span><br><span class=\"line\">HSTMT stmt;</span><br><span class=\"line\">SQLAllocStmt(conn, <span class=\"operator\">&amp;</span>stmt);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>分配一个与指定数据库连接的新的语句句柄</span><br><span class=\"line\"><span class=\"type\">char</span> <span class=\"operator\">*</span> sqlquery <span class=\"operator\">=</span> &quot;select branch_name, sum (balance)</span><br><span class=\"line\">    from account</span><br><span class=\"line\">    group by branch_name&quot;;</span><br><span class=\"line\">error <span class=\"operator\">=</span> SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>执行查询，stmt句柄指向结果集合</span><br><span class=\"line\">if (error <span class=\"operator\">=</span><span class=\"operator\">=</span> SQL_SUCCESS) &#123;</span><br><span class=\"line\">SQLBindCol(stmt, <span class=\"number\">1</span>, SQL_C_CHAR, branchname , <span class=\"number\">80</span>, <span class=\"operator\">&amp;</span>lenOut1);</span><br><span class=\"line\">SQLBindCol(stmt, <span class=\"number\">2</span>, SQL_C_FLOAT, <span class=\"operator\">&amp;</span>balance, <span class=\"number\">0</span> , <span class=\"operator\">&amp;</span>lenOut2);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>绑定高级语言变量与stmt句柄中的属性</span><br><span class=\"line\">while (SQLFetch(stmt) <span class=\"operator\">&gt;=</span> SQL_SUCCESS) &#123;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>提取一条记录，结果数据被存入高级语言变量中</span><br><span class=\"line\">    printf (&quot; %s %g\\n&quot;, branchname, balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SQLFreeStmt(stmt, SQL_DROP);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>释放语句句柄</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"7-4-ODBC的其他功能\"><a href=\"#7-4-ODBC的其他功能\" class=\"headerlink\" title=\"7.4 ODBC的其他功能\"></a>7.4 ODBC的其他功能</h4><ol>\n<li>动态SQL语句的预编译-动态参数传递功能</li>\n<li>获取元数据特性<ul>\n<li>发现数据库中的所有关系的特性 以及</li>\n<li>发现每一个查询结果的列的名字和类型等；</li>\n</ul>\n</li>\n<li>默认, 每一条SQL语句都被作为一个独立的能够自动提交的事务来处理。<ul>\n<li>应用程序可以关闭一个连接的自动提交特性<ul>\n<li><code>SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0)&#125;</code></li>\n</ul>\n</li>\n<li>此时事务要显式地给出提交和撤销的命令<ul>\n<li><code>SQLTransact(conn, SQL_COMMIT)</code> or <code>SQLTransact(conn, SQL_ROLLBACK)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id8\"><span></p>\n<h3 id=\"8-JDBC简介\"><a href=\"#8-JDBC简介\" class=\"headerlink\" title=\"8. JDBC简介\"></a>8. JDBC简介</h3><h4 id=\"8-1-JDBC定义\"><a href=\"#8-1-JDBC定义\" class=\"headerlink\" title=\"8.1 JDBC定义\"></a>8.1 JDBC定义</h4><p>JDBC：Java DataBase Connection，JDBC是一组Java版的应用程序接口API，提供了Java应用程序与数据库服务器的连接和通讯能力。</p>\n<ul>\n<li>JDBCAPI分成两个程序包：<ul>\n<li>Java.sql 核心API –J2SE(Java2标准版)的一部分。使用<code>java.sql.DriverManager</code>类、<code>java.sql.Driver</code>和<code>java.sql.Connection</code>接口连接到数据库</li>\n<li>Javax.sql 可选扩展API–J2EE(Java2企业版)的一部分。包含了基于<code>JNDI(JavaNamingandDirectoryInterface,Java命名和目录接口)</code>的资源，以及管理连接池、分布式事务等，使用DataSource接口连接到数据库。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"8-2-JDBC的功能\"><a href=\"#8-2-JDBC的功能\" class=\"headerlink\" title=\"8.2 JDBC的功能\"></a>8.2 JDBC的功能</h4><ol>\n<li><code>java.sql.DriverManager</code>——处理驱动的调入并且对产生新数据库连接提供支持</li>\n<li><code>Java.sql.Driver</code>——通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动。</li>\n<li><code>java.sql.Connection</code>——代表对特定数据库的连接。</li>\n<li><code>Try &#123;…&#125; Catch &#123;…&#125;</code> ——异常捕获及其处理</li>\n<li><code>java.sql.Statement</code>——对特定的数据库执行SQL语句</li>\n<li><code>java.sql.PreparedStatement</code> —— 用于执行预编译的SQL语句</li>\n<li><code>java.sql.CallableStatement</code> ——用于执行对数据库内嵌过程的调用。</li>\n<li><code>java.sql.ResultSet</code>——从当前执行的SQL语句中返回结果数据。</li>\n</ol>\n<h4 id=\"8-3-使用JDBC-API访问数据库的过程\"><a href=\"#8-3-使用JDBC-API访问数据库的过程\" class=\"headerlink\" title=\"8.3 使用JDBC API访问数据库的过程\"></a>8.3 使用JDBC API访问数据库的过程</h4><ol>\n<li><p>概念性的基本过程</p>\n<ul>\n<li>打开一个连接；创建“Statement”对象，并设置查询语句；使用Statement对象执行查询，发送查询给数据库服务器和返回结果给应用程序；处理错误的例外机制</li>\n</ul>\n</li>\n<li><p>具体实施过程</p>\n<ol>\n<li>•传递一个Driver给DriverManager，加载数据库驱动。<ul>\n<li><code>Class.forName()</code></li>\n</ul>\n</li>\n<li>•通过URL得到一个Connection对象, 建立数据库连接<ul>\n<li><code>DriverManager.getConnection(sDBUrl)</code></li>\n<li><code>DriverManager.getConnection(sDBUrl,sDBUserID,sDBPassword)</code></li>\n</ul>\n</li>\n<li>•接着创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库。<ul>\n<li><code>Statement stmt=con.createStatement()</code></li>\n</ul>\n</li>\n<li>•查询返回一个ResultSet。<ul>\n<li><code>ResultSet rs=stmt.executeQuery(sSQL)</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">JDBCexample</span><span class=\"params\">(String dbid, String userid, String passwd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">try</span> &#123; <span class=\"comment\">//错误捕获</span></span><br><span class=\"line\">    Class.forName (<span class=\"string\">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class=\"line\">    Connection conn = DriverManager.getConnection(</span><br><span class=\"line\">        <span class=\"string\">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>, userid, passwd);</span><br><span class=\"line\">    <span class=\"comment\">//加载数据库驱动，建立数据库连接</span></span><br><span class=\"line\">    Statement stmt = conn.createStatement();</span><br><span class=\"line\">    <span class=\"comment\">//创建一个语句对象</span></span><br><span class=\"line\">    … Do Actual Work ….</span><br><span class=\"line\">    <span class=\"comment\">//进行SQL语句的执行与处理工作</span></span><br><span class=\"line\">    stmt.close();</span><br><span class=\"line\">    conn.close();</span><br><span class=\"line\">    <span class=\"comment\">//关闭语句对象，关闭连接</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (SQLException sqle) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;SQLException : &quot;</span> + sqle); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>完整的示例程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">JDBCexample</span><span class=\"params\">(String dbid, String userid, String passwd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Class.forName (<span class=\"string\">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class=\"line\">    Connection conn = DriverManager.getConnection(</span><br><span class=\"line\">        <span class=\"string\">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>, userid, passwd);</span><br><span class=\"line\">    Statement stmt = conn.createStatement();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        stmt.executeUpdate( <span class=\"string\">&quot;insert into instructor values</span></span><br><span class=\"line\"><span class=\"string\">        (‘77987&#x27;, ‘Kim&#x27;, ‘Physics’,98000)&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SQLException sqle) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;插入错误:&quot;</span> + sqle);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ResultSet rset = stmt.executeQuery(</span><br><span class=\"line\">        <span class=\"string\">&quot;select dept_name, avg(salary) from instructor group by dept_name&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( rset.next() ) &#123;</span><br><span class=\"line\">        System.out.println(rset.getString(“dept_name<span class=\"string\">&quot;) + &quot;</span> <span class=\"string\">&quot; + rset.getFloat(2));</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    stmt.close();</span></span><br><span class=\"line\"><span class=\"string\">    conn.close();</span></span><br><span class=\"line\"><span class=\"string\">&#125; catch (SQLException sqle) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    System.out.println(&quot;</span>SQLException:<span class=\"string\">&quot; + sqle);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><span id=\"id9\"><span></p>\n<h3 id=\"9-嵌入式SQL-ODBC-JDBC三者比较\"><a href=\"#9-嵌入式SQL-ODBC-JDBC三者比较\" class=\"headerlink\" title=\"9. 嵌入式SQL-ODBC-JDBC三者比较\"></a>9. 嵌入式SQL-ODBC-JDBC三者比较</h3><p>执行一条SQL语句，读取执行的结果集合</p>\n<ol>\n<li>嵌入式SQL的思维模式<ol>\n<li>建立数据库连接</li>\n<li>声明一个游标</li>\n<li>打开游标</li>\n<li>读取一条记录(循环)</li>\n<li>关闭游标</li>\n<li>断开数据库连接</li>\n</ol>\n</li>\n<li>ODBC的思维模式<ol>\n<li>建立数据库连接</li>\n<li>分配语句句柄</li>\n<li>用句柄执行SQL</li>\n<li>建立高级语言变量与句柄属性的对应</li>\n<li>读取一条记录(循环)</li>\n<li>释放语句句柄</li>\n<li>断开数据库连接</li>\n</ol>\n</li>\n<li>JDBC的思维模式<ol>\n<li>建立数据库连接</li>\n<li>创建语句对象</li>\n<li>用语句对象执行SQL，并返回结果对象</li>\n<li>从结果对象获取一条记录</li>\n<li>提取对象的属性值传给高级语言变量(返回上一步)</li>\n<li>释放语句对象</li>\n<li>断开数据库连接</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>相同点: 都是建立数据库连接, 执行sql, 处理结果, 释放连接, 流程基本一致</li>\n<li>不同点, 操作方式的不同:<ul>\n<li>嵌入式SQL按照语句进行操作</li>\n<li>ODBC按照函数来进行操作</li>\n<li>JDBC按照对象来进行操作</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ul>\n<li>交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，</li>\n<li>然而，交互式SQL本身也有很多局限：","more":"<ul>\n<li>从使用者角度：专业人员可熟练写出SQL语句，但大部分的普通用户并非可以</li>\n<li>从SQL本身角度：特别复杂的检索结果难以用一条交互式SQL语句完成，此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理</li>\n</ul>\n</li>\n<li>因此，高级语言+SQL语言：<ul>\n<li>既继承高级语言的过程控制性</li>\n<li>又结合SQL语言的复杂结果集操作的非过程性</li>\n<li>同时又为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作</li>\n</ul>\n</li>\n<li>嵌入式SQL语言<ul>\n<li>将SQL语言嵌入到某一种高级语言中使用</li>\n<li>这种高级语言，如C/C++, Java, PowerBuilder等，又称宿主语言(Host Language)</li>\n<li>嵌入在宿主语言中的SQL与前面介绍的交互式SQL有一些不同的操作方式</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h4><ol>\n<li><a href=\"#id1\">变量声明与数据库连接</a></li>\n<li><a href=\"#id2\">事务Transaction</a></li>\n<li><a href=\"#id3\">数据集与游标</a></li>\n<li><a href=\"#id4\">状态捕获及错误处理机制</a></li>\n<li><a href=\"#id5\">动态SQL</a></li>\n<li><a href=\"#id6\">数据字典与SQLDA</a></li>\n<li><a href=\"#id7\">ODBC简介</a></li>\n<li><a href=\"#id8\">JDBC简介</a></li>\n<li><a href=\"#id9\">嵌入式SQL-ODBC-JDBC三者比较</a></li>\n</ol>\n<p><span id=\"id1\"><span></p>\n<h3 id=\"1-变量声明与数据库连接\"><a href=\"#1-变量声明与数据库连接\" class=\"headerlink\" title=\"1. 变量声明与数据库连接\"></a>1. 变量声明与数据库连接</h3><ol>\n<li>以宿主语言<strong>C语言</strong>为例，对比交互式SQL语言与嵌入式SQL语言<ul>\n<li>交互式SQL:<code>select Sname, Sage from Student where Sname=&#39;张三&#39;;</code></li>\n<li>嵌入式SQL:<code>exec sql select Sname, Sage into :vSname, :vSage from Student where Sname=&#39;张三&#39;;</code></li>\n</ul>\n</li>\n<li>典型特点<ul>\n<li><strong>exec sql</strong>引导SQL语句: 提供给C编译器，以便对SQL语句预编译成C编译器可识别的语句</li>\n<li>增加一 <strong>into子句</strong>: 该子句用于指出接收SQL语句检索结果的程序变量</li>\n<li>由冒号引导的<strong>程序变量</strong>,如: ‘:vSname’, ‘:vSage’</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-1-变量的声明与使用\"><a href=\"#1-1-变量的声明与使用\" class=\"headerlink\" title=\"1.1 变量的声明与使用\"></a>1.1 变量的声明与使用</h4><ul>\n<li>在嵌入式SQL语句中可以出现宿主语言语句所使用的变量，这些变量需要特殊的声明：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">begin</span> <span class=\"keyword\">declare</span> section;</span><br><span class=\"line\">    <span class=\"type\">char</span> vSname[<span class=\"number\">10</span>], specName[<span class=\"number\">10</span>]<span class=\"operator\">=</span>&quot;张三&quot;;</span><br><span class=\"line\">    <span class=\"type\">int</span> vSage;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">end</span> <span class=\"keyword\">declare</span> section;</span><br></pre></td></tr></table></figure></li>\n<li>变量声明和赋值中，要注意：<ul>\n<li>宿主程序的字符串变量长度应比字符型字段的长度多1个。因宿主程序的字符串尾部多一个终止符为’\\0’，而程序中用双引号来描述。</li>\n<li>宿主程序变量类型与数据库字段类型之间有些是有差异的,有些DBMS可支持自动转换，有些不能。</li>\n</ul>\n</li>\n<li>声明的变量，可以在宿主程序中赋值，然后传递给SQL语句的where等子句中，以使SQL语句能够按照指定的要求(可变化的)进行检索。</li>\n<li>嵌入式比交互式SQL语句灵活了一些：只需改一下变量值，SQL语句便可反复使用，以检索出不同结果。</li>\n<li>示例：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">begin</span> <span class=\"keyword\">declare</span> section;</span><br><span class=\"line\">    <span class=\"type\">char</span> vSname[<span class=\"number\">10</span>], specName[<span class=\"number\">10</span>]<span class=\"operator\">=</span>&quot;张三&quot;;</span><br><span class=\"line\">    <span class=\"type\">int</span> vSage;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">end</span> <span class=\"keyword\">declare</span> section;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>用户可在此处基于键盘输入给specName赋值</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">select</span> Sname, Sage <span class=\"keyword\">into</span> :vSname, :vSage <span class=\"keyword\">from</span> Student <span class=\"keyword\">where</span> Sname <span class=\"operator\">=</span> :specName;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>比较相应的交互式<span class=\"keyword\">SQL</span>语句：</span><br><span class=\"line\"><span class=\"keyword\">select</span> Sname, Sage <span class=\"keyword\">from</span> Student <span class=\"keyword\">where</span> Sname <span class=\"operator\">=</span> <span class=\"string\">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"1-2-程序与数据库的连接和断开\"><a href=\"#1-2-程序与数据库的连接和断开\" class=\"headerlink\" title=\"1.2 程序与数据库的连接和断开\"></a>1.2 程序与数据库的连接和断开</h4><h5 id=\"1-2-1-数据库的连接connect\"><a href=\"#1-2-1-数据库的连接connect\" class=\"headerlink\" title=\"1.2.1 数据库的连接connect\"></a>1.2.1 数据库的连接connect</h5><p>在嵌入式SQL程序执行之前，首先要与数据库进行连接, 不同DBMS，具体连接语句的语法略有差异</p>\n<ol>\n<li>SQL标准中建议的连接语法为：<ul>\n<li><code>execsql connecttotarget-server asconnect-name useruser-name;</code></li>\n<li>或 <code>execsql connecttodefault;</code></li>\n</ul>\n</li>\n<li>Oracle中数据库连接:<ul>\n<li><code>execsql connect:user_name identified by :user_pwd;</code></li>\n</ul>\n</li>\n<li>DB2 UDB中数据库连接:<ul>\n<li><code>execsql connecttomydb user:user_name using:user_pwd;</code></li>\n</ul>\n</li>\n</ol>\n<h5 id=\"1-2-1-数据库的断开disconnect\"><a href=\"#1-2-1-数据库的断开disconnect\" class=\"headerlink\" title=\"1.2.1 数据库的断开disconnect\"></a>1.2.1 数据库的断开disconnect</h5><p>在嵌入式SQL程序执行之后，需要与数据库断开连接</p>\n<ol>\n<li>SQL标准中建议的断开连接的语法为：<ul>\n<li><code>exec sql disconnect connect-name;</code></li>\n<li>或 <code>exec sql disconnect current;</code></li>\n</ul>\n</li>\n<li>Oracle中断开连接:<ul>\n<li><code>exec sql commit release;</code></li>\n<li>或 <code>exec sql rollback release;</code></li>\n</ul>\n</li>\n<li>DB2 UDB中断开连接:<ul>\n<li><code>exec sql connect reset;</code></li>\n<li><code>exec sql disconnect current;</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-3-SQL执行的提交与撤消\"><a href=\"#1-3-SQL执行的提交与撤消\" class=\"headerlink\" title=\"1.3 SQL执行的提交与撤消\"></a>1.3 SQL执行的提交与撤消</h4><p>SQL语句在执行过程中，必须有提交和撤消语句才能确认其操作结果</p>\n<ol>\n<li>SQL执行的提交：<ul>\n<li><code>execsql commitwork;</code></li>\n</ul>\n</li>\n<li>SQL执行的撤消：<ul>\n<li><code>execsql rollbackwork;</code></li>\n</ul>\n</li>\n<li>为此，很多DBMS都设计了捆绑提交/撤消与断开连接在一起的语句,以保证在断开连接之前使用户确认提交或撤消先前的工作，例如Oracle中：<ul>\n<li><code>execsql commitrelease;</code></li>\n<li>或 <code>execsql rollbackrelease;</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id2\"><span></p>\n<h3 id=\"2-事务Transaction\"><a href=\"#2-事务Transaction\" class=\"headerlink\" title=\"2. 事务Transaction\"></a>2. 事务Transaction</h3><ol>\n<li>从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务</li>\n<li>从微观角度，或者从DBMS角度：事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</li>\n<li>简单来说：事务是作为单个逻辑工作单元执行的一系列操作；多个操作作为一个整体向系统提交，要么都执行，要么都不执行；<strong>事务是一个不可分割的工作逻辑单元</strong>。</li>\n</ol>\n<h4 id=\"2-1-事务的特性-ACID\"><a href=\"#2-1-事务的特性-ACID\" class=\"headerlink\" title=\"2.1 事务的特性: ACID\"></a>2.1 事务的特性: ACID</h4><ol>\n<li><strong>原子性</strong>Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对DB而言，要么都执行，要么都不执行</li>\n<li><strong>一致性</strong>Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作规则，它是进一步由隔离性来保证的</li>\n<li><strong>隔离性</strong>Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;或者先执行了T2, 再执行T1。</li>\n<li><strong>持久性</strong>Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的。</li>\n</ol>\n<blockquote>\n<p>换句话说：具有ACID特性的若干数据库基本操作的组合体被称为事务。</p>\n</blockquote>\n<p><span id=\"id3\"><span></p>\n<h3 id=\"3-数据集与游标\"><a href=\"#3-数据集与游标\" class=\"headerlink\" title=\"3. 数据集与游标\"></a>3. 数据集与游标</h3><p>读取单行结果处理与多行结果处理的差异：Into子句与游标(Cursor)</p>\n<ol>\n<li>检索单行结果，可将结果直接传送到宿主程序的变量中(Into)<ul>\n<li>示例：<code>exec sql select Sname,Sage into :vSname,:vSage from Student where Sname = :specName;</code></li>\n</ul>\n</li>\n<li>检索多行结果，则需使用游标(Cursor)<ul>\n<li>游标是指向某检索记录集的指针</li>\n<li>通过这个指针的移动，每次读一行，处理一行，再读一行… , 直至处理完毕</li>\n<li>读一行操作是通过Fetch…into语句实现的：每一次Fetch, 都是先向下移动指针，然后再读取</li>\n<li>记录集有结束标识EOF, 用来标记后面已没有记录了</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>游标(Cursor)的使用需要先定义、再打开(执行)、接着一条接一条处理，最后再关闭</li>\n<li>游标可以定义一次，多次打开(多次执行)，多次关闭</li>\n</ul>\n<h4 id=\"3-1-游标的使用方法\"><a href=\"#3-1-游标的使用方法\" class=\"headerlink\" title=\"3.1 游标的使用方法\"></a>3.1 游标的使用方法</h4><ol>\n<li><p>Cursor的定义：declare cursor</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">DECLARE</span> cursor_name <span class=\"keyword\">CURSOR</span> <span class=\"keyword\">FOR</span></span><br><span class=\"line\">    Subquery</span><br><span class=\"line\">    [<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> result_column [<span class=\"keyword\">ASC</span> <span class=\"operator\">|</span> <span class=\"keyword\">DESC</span>][, result_column …]</span><br><span class=\"line\">    [<span class=\"keyword\">FOR</span> [ READ <span class=\"keyword\">ONLY</span> <span class=\"operator\">|</span> UPDATE [<span class=\"keyword\">OF</span> columnname [, columnname…]]]];</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例:</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">declare</span> cur_student <span class=\"keyword\">cursor</span> <span class=\"keyword\">for</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> Sno, Sname, Sclass <span class=\"keyword\">from</span> Student <span class=\"keyword\">where</span> Sclass<span class=\"operator\">=</span> :vClass</span><br><span class=\"line\">    <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> Sno</span><br><span class=\"line\">    <span class=\"keyword\">for</span> read <span class=\"keyword\">only</span> ;</span><br></pre></td></tr></table></figure></li>\n<li><p>Cursor的打开和关闭：open cursor //close cursor</p>\n<ul>\n<li>EXEC SQL OPEN cursor_name;</li>\n<li>EXEC SQL CLOSE cursor_name;</li>\n</ul>\n</li>\n<li><p>Cursor的数据读取：Fetch</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">FETCH</span> cursor_name</span><br><span class=\"line\">    <span class=\"keyword\">INTO</span> host<span class=\"operator\">-</span>variable , [host<span class=\"operator\">-</span>variable, …];</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例:</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">declare</span> cur_student <span class=\"keyword\">cursor</span> <span class=\"keyword\">for</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> Sno, Sname, Sclass <span class=\"keyword\">from</span> Student <span class=\"keyword\">where</span> Sclass<span class=\"operator\">=</span> :vClass</span><br><span class=\"line\">    <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> Sno <span class=\"keyword\">for</span> read <span class=\"keyword\">only</span> ;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">open</span> cur_student;</span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">fetch</span> cur_student <span class=\"keyword\">into</span> :vSno, :vSname, :vSage</span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">close</span> cur_student;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"3-2-可滚动游标\"><a href=\"#3-2-可滚动游标\" class=\"headerlink\" title=\"3.2 可滚动游标\"></a>3.2 可滚动游标</h4><ol>\n<li>ODBC支持的可滚动Cursor<ul>\n<li>标准的游标始终是自开始向结束方向移动的，每fetch一次，向结束方向移动一次；一条记录只能被访问一次；再次访问该记录只能关闭游标后重新打开</li>\n<li>ODBC(OpenDataBase Connectivity)是一种跨DBMS的DB操作平台，它在应用程序与实际的DBMS之间提供了一种通用接口</li>\n<li>许多实际的DBMS并不支持可滚动游标，但通过ODBC可以使用该功能</li>\n</ul>\n</li>\n<li>可滚动游标是可使游标指针在记录集之间灵活移动、使每条记录可以反复被访问的一种游标<ul>\n<li>可滚动游标移动时需判断是否到结束位置，或到起始位置<ul>\n<li>可通过判断是否到EOF位置(最后一条记录的后面),或BOF位置(起始记录的前面)</li>\n<li>如果不需区分，可通过whenevernotfound语句设置来检测</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">DECLARE</span> cursor_name [<span class=\"keyword\">INSENSITIVE</span>] [<span class=\"keyword\">SCROLL</span>] <span class=\"keyword\">CURSOR</span></span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> <span class=\"keyword\">HOLD</span>] <span class=\"keyword\">FOR</span> Subquery</span><br><span class=\"line\">[<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> result_column [<span class=\"keyword\">ASC</span> <span class=\"operator\">|</span> <span class=\"keyword\">DESC</span>][, result_column …]</span><br><span class=\"line\">[<span class=\"keyword\">FOR</span> READ <span class=\"keyword\">ONLY</span> <span class=\"operator\">|</span> <span class=\"keyword\">FOR</span> UPDATE <span class=\"keyword\">OF</span> columnname [,</span><br><span class=\"line\">columnname ]…];</span><br><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">FETCH</span></span><br><span class=\"line\">[ NEXT <span class=\"operator\">|</span> PRIOR <span class=\"operator\">|</span> <span class=\"keyword\">FIRST</span> <span class=\"operator\">|</span> <span class=\"keyword\">LAST</span></span><br><span class=\"line\"><span class=\"operator\">|</span> [ABSOLUTE <span class=\"operator\">|</span> RELATIVE] value_spec ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> cursor_name <span class=\"keyword\">INTO</span> host<span class=\"operator\">-</span>variable [, host<span class=\"operator\">-</span>variable …];</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>NEXT</code>向结束方向移动一条；</li>\n<li><code>PRIOR</code>向开始方向移动一条；</li>\n<li><code>FIRST</code>回到第一条；</li>\n<li><code>LAST</code>移动到最后一条；</li>\n<li><code>ABSOLUTvalue_spec</code>定向检索指定位置的行,value_spec由1至当前记录集最大值；</li>\n<li><code>RELATIVEvalue_spec</code>相对当前记录向前或向后移动，value_spec为正数向结束方向移动，为负数向开始方向移动</li>\n</ul>\n<h4 id=\"3-3-数据库记录的增删改\"><a href=\"#3-3-数据库记录的增删改\" class=\"headerlink\" title=\"3.3 数据库记录的增删改\"></a>3.3 数据库记录的增删改</h4><ol>\n<li>数据库记录的删除<ul>\n<li>一种是查找删除(与交互式DELETE语句相同)，一种是定位删除</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> tablename [corr_name]</span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> search_condition <span class=\"operator\">|</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">CURRENT</span> <span class=\"keyword\">OF</span> cursor_name;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例：查找删除</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> customers c <span class=\"keyword\">where</span> c.city <span class=\"operator\">=</span> ‘Harbin’ <span class=\"keyword\">and</span></span><br><span class=\"line\">    <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> ( <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> orders o <span class=\"keyword\">where</span> o.cid <span class=\"operator\">=</span> c.cid);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例：定位删除</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">declare</span> delcust <span class=\"keyword\">cursor</span> <span class=\"keyword\">for</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> cid <span class=\"keyword\">from</span> customers c <span class=\"keyword\">where</span> c.city <span class=\"operator\">=</span>‘harbin’ <span class=\"keyword\">and</span></span><br><span class=\"line\">    <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> ( <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> orders o <span class=\"keyword\">where</span> o.cid <span class=\"operator\">=</span> c.cid)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> update <span class=\"keyword\">of</span> cid;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">open</span> delcust</span><br><span class=\"line\">While (<span class=\"literal\">TRUE</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">fetch</span> delcust <span class=\"keyword\">into</span> :cust_id;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> customers <span class=\"keyword\">where</span> <span class=\"keyword\">current</span> <span class=\"keyword\">of</span> delcust ; &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>数据库记录的更新<ul>\n<li>一种是查找更新(与交互式Update语句相同)，一种是定位更新</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> UPDATE tablename [corr_name]</span><br><span class=\"line\">    <span class=\"keyword\">SET</span> columnname <span class=\"operator\">=</span> expr [, columnname <span class=\"operator\">=</span> expr …]</span><br><span class=\"line\">    [ <span class=\"keyword\">WHERE</span> search_condition ] <span class=\"operator\">|</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">CURRENT</span> <span class=\"keyword\">OF</span> cursor_name;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例：查找更新</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> update student s <span class=\"keyword\">set</span> sclass <span class=\"operator\">=</span> ‘<span class=\"number\">035102</span>’</span><br><span class=\"line\">    <span class=\"keyword\">where</span> s.sclass <span class=\"operator\">=</span> ‘<span class=\"number\">034101</span>’</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> 示例：定位更新</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">declare</span> stud <span class=\"keyword\">cursor</span> <span class=\"keyword\">for</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student s <span class=\"keyword\">where</span> s.sclass <span class=\"operator\">=</span>‘<span class=\"number\">034101</span>’</span><br><span class=\"line\">    <span class=\"keyword\">for</span> update <span class=\"keyword\">of</span> sclass;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">open</span> stud</span><br><span class=\"line\">While (<span class=\"literal\">TRUE</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">fetch</span> stud <span class=\"keyword\">into</span> :vSno, :vSname, :vSclass;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> update student <span class=\"keyword\">set</span> sclass <span class=\"operator\">=</span> ‘<span class=\"number\">035102</span>’ <span class=\"keyword\">where</span> <span class=\"keyword\">current</span> <span class=\"keyword\">of</span> stud ; &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>数据库记录的插入<ul>\n<li>只有一种类型的插入语句</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXEC</span> <span class=\"keyword\">SQL</span> <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> tablename [ (columnname [,columnname, …] )]</span><br><span class=\"line\">    [ <span class=\"keyword\">VALUES</span> (expr [ , expr , …] ) <span class=\"operator\">|</span> subqurey ] ;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例：插入语句</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> student ( sno, sname, sclass)</span><br><span class=\"line\">    <span class=\"keyword\">values</span> (‘<span class=\"number\">03510128</span>’, ‘张三’, ‘<span class=\"number\">035101</span>’) ;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>示例：插入语句</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> masterstudent ( sno, sname, sclass)</span><br><span class=\"line\">    <span class=\"keyword\">select</span> sno, sname, sclass <span class=\"keyword\">from</span> student;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><span id=\"id4\"><span></p>\n<h3 id=\"4-状态捕获及错误处理机制\"><a href=\"#4-状态捕获及错误处理机制\" class=\"headerlink\" title=\"4. 状态捕获及错误处理机制\"></a>4. 状态捕获及错误处理机制</h3><h4 id=\"4-1-基本机制\"><a href=\"#4-1-基本机制\" class=\"headerlink\" title=\"4.1 基本机制\"></a>4.1 基本机制</h4><ul>\n<li><p>状态，是嵌入式SQL语句的执行状态，尤其指一些出错状态；有时程序需要知道这些状态并对这些状态进行处理</p>\n</li>\n<li><p>嵌入式 SQL程序中，状态捕获及处理有三部分构成</p>\n<ol>\n<li>设置SQL通信区:一般在嵌入式SQL程序的开始处便设置<ul>\n<li><code>exec sql include sqlca;</code></li>\n</ul>\n</li>\n<li>设置状态捕获语句:在嵌入式SQL程序的任何位置都可设置；可多次设置；但有作用域<ul>\n<li><code>exec sql whenever sqlerror goto report_error;</code></li>\n</ul>\n</li>\n<li>状态处理语句:某一段程序以应对SQL操作的某种状态<ul>\n<li><code>report_error: exec sql rollback;</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>SQL通信区: SQLCA</p>\n<ol>\n<li>SQLCA是一个已被声明过的具C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句执行的状态，便于宿主程序读取与处理</li>\n<li>SQLCA是DBMS(执行SQL语句)与宿主程序之间交流的桥梁之一</li>\n</ol>\n</li>\n<li><p>状态捕获语句: <code>exec sql whenever condition action;</code></p>\n<ul>\n<li>Whenever语句的作用是设置一个“条件陷阱”, 该条语句会对其后面的所有由Exec SQL语句所引起的对数据库系统的调用自动检查它是否满足条件(由condition指出).<ul>\n<li>SQLERROR: 检测是否有SQL语句出错。其具体意义依赖于特定的DBMS</li>\n<li>NOT FOUND: 执行某一SQL语句后，没有相应的结果记录出现</li>\n<li>SQLWARNING: 不是错误，但应引起注意的条件</li>\n</ul>\n</li>\n<li>如果满足condition, 则要采取一些动作(由action指出)<ul>\n<li>CONTINUE: 忽略条件或错误，继续执行</li>\n<li>GOTO 标号: 转移到标号所指示的语句，去进行相应的处理</li>\n<li>STOP: 终止程序运行、撤消当前的工作、断开数据库的连接</li>\n<li>DO函数或 CALL函数: 调用宿主程序的函数进行处理，函数返回后从引发该condition的Exec SQL语句之后的语句继续进行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>状态捕获语句Whenever的作用范围是其后的所有Exec SQL语句，一直到程序中出现另一条相同条件的Whenever语句为止，后面的将覆盖前面的。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror stop;</span><br><span class=\"line\">    … …</span><br><span class=\"line\">    goto s1</span><br><span class=\"line\">    … …</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror continue;</span><br><span class=\"line\">    s1: <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> update agents <span class=\"keyword\">set</span> <span class=\"keyword\">percent</span> <span class=\"operator\">=</span> <span class=\"keyword\">percent</span> <span class=\"operator\">+</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    … …</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>S1标号指示的语句受第二个<span class=\"keyword\">Whenever</span>语句约束。</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>注意：作用域是语句在程序中的位置，而不是控制流程(因是预编译程序处理条件陷阱)</span><br></pre></td></tr></table></figure></li>\n<li><p>状态捕获语句Whenever的使用容易引发无限循环</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror goto handle_error;</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> customers(cid <span class=\"type\">char</span>(<span class=\"number\">4</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    cname <span class=\"type\">varchar</span>(<span class=\"number\">13</span>), … … );</span><br><span class=\"line\">    … …</span><br><span class=\"line\">    handle_error:</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror continue;<span class=\"operator\">/</span><span class=\"operator\">/</span> 控制是否无限循环：无，则可能；有，则不会</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">drop</span> customers;</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">disconnect</span>;</span><br><span class=\"line\">        fprintf(stderr,”could <span class=\"keyword\">not</span> <span class=\"keyword\">create</span> customers <span class=\"keyword\">table</span>\\n”);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"4-2-状态信息\"><a href=\"#4-2-状态信息\" class=\"headerlink\" title=\"4.2 状态信息\"></a>4.2 状态信息</h4><p>典型DBMS系统记录状态信息的三种方法</p>\n<ul>\n<li>状态记录:<ol>\n<li><code>sqlcode</code>: 典型DBMS都提供一个sqlcode变量来记录其执行sql语句的状态，但不同DBMS定义的sqlcode值所代表的状态意义可能是不同的。<ul>\n<li>sqlcode== 0, successful call;</li>\n<li>sqlcode &lt; 0, error, e.g., from connect, database does not exist , –16;</li>\n<li>sqlcode &gt; 0, warning, e.g., no rows retrieved from fetch</li>\n</ul>\n</li>\n<li><code>sqlca.sqlcode</code>: 支持SQLCA的产品一般要在SQLCA中填写sqlcode来记录上述信息; 除此而外，sqlca还有其他状态信息的记录</li>\n<li><code>sqlstate</code>: 有些DBMS提供的记录状态信息的变量是sqlstate或sqlca.sqlstate</li>\n</ol>\n</li>\n<li>当我们不需明确知道错误类型，而只需知道发生错误与否，则我们只要使用前述的状态捕获语句即可，而无需关心状态记录变量(隐式状态处理)</li>\n<li>但我们程序中如要自行处理不同状态信息时，则需要知道以上信息，但也需知道正确的操作方法(显式状态处理)</li>\n</ul>\n<h4 id=\"4-3-程序自身进行错误信息的处理\"><a href=\"#4-3-程序自身进行错误信息的处理\" class=\"headerlink\" title=\"4.3 程序自身进行错误信息的处理\"></a>4.3 程序自身进行错误信息的处理</h4><p>正确的显式状态处理示例:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">begin</span> declar section;</span><br><span class=\"line\">    <span class=\"type\">char</span> <span class=\"keyword\">SQLSTATE</span>[<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">end</span> <span class=\"keyword\">declare</span> section;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror goto handle_error;</span><br><span class=\"line\">… …</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">whenever</span> sqlerror continue;</span><br><span class=\"line\"><span class=\"keyword\">exec</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> custs</span><br><span class=\"line\">    (cid <span class=\"type\">char</span>(<span class=\"number\">4</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>, cname <span class=\"type\">varchar</span>(<span class=\"number\">13</span>), … … );</span><br><span class=\"line\">if (strcmp(<span class=\"keyword\">SQLSTATE</span>, “<span class=\"number\">82100</span>”)<span class=\"operator\">=</span><span class=\"operator\">=</span><span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"operator\">&lt;</span>处理<span class=\"number\">82100</span>错误的程序<span class=\"operator\">&gt;</span></span><br><span class=\"line\">    … …</span><br></pre></td></tr></table></figure>\n<p>上述的if语句是能被执行的，因为createtable发生错误时是继续向下执行的。</p>\n<p><span id=\"id5\"><span></p>\n<h3 id=\"5-动态SQL\"><a href=\"#5-动态SQL\" class=\"headerlink\" title=\"5. 动态SQL\"></a>5. 动态SQL</h3><h4 id=\"5-1-动态SQL的概念\"><a href=\"#5-1-动态SQL的概念\" class=\"headerlink\" title=\"5.1 动态SQL的概念\"></a>5.1 动态SQL的概念</h4><p>动态SQL是相对于静态SQL而言的</p>\n<ul>\n<li>静态SQL特点：SQL语句在程序中已经按要求写好，只需要把一些参数通过变量(高级语言程序语句中不带冒号) 传送给嵌入式SQL语句即可(嵌入式SQL语句中带冒号)</li>\n<li>动态SQL特点：SQL语句可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍旧可以传递变量</li>\n</ul>\n<h4 id=\"5-2-动态SQL的两种执行方式\"><a href=\"#5-2-动态SQL的两种执行方式\" class=\"headerlink\" title=\"5.2 动态SQL的两种执行方式\"></a>5.2 动态SQL的两种执行方式</h4><p>如SQL语句已经被构造在host-variable字符串变量中,则：</p>\n<ol>\n<li><strong>立即执行语句</strong>: 运行时编译并执行<ul>\n<li><code>EXEC SQL EXECUTE IMMEDIATE :host-variable;</code></li>\n</ul>\n</li>\n<li><strong>Prepare-Execute-Using语句</strong>:PREPARE语句先编译，编译后的SQL语句允许动态参数，EXECUTE语句执行，用USING语句将动态参数值传送给编译好的SQL语句<ul>\n<li><code>EXEC SQL PREPARE sql_temp FROM :host-variable;</code></li>\n<li><code>EXEC SQL EXECUTE sql_temp USING :cond-variable</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id6\"><span></p>\n<h3 id=\"6-数据字典与SQLDA\"><a href=\"#6-数据字典与SQLDA\" class=\"headerlink\" title=\"6. 数据字典与SQLDA\"></a>6. 数据字典与SQLDA</h3><h4 id=\"6-1-数据字典的概念\"><a href=\"#6-1-数据字典的概念\" class=\"headerlink\" title=\"6.1 数据字典的概念\"></a>6.1 数据字典的概念</h4><p>数据字典(Data dictionary)，又称为系统目录(System Catalogs)</p>\n<ul>\n<li>是系统维护的一些表或视图的集合，这些表或视图存储了数据库中各类对象的定义信息，这些对象包括用Create语句定义的表、列、索引、视图、权限、约束等,这些信息又称数据库的元数据–关于数据的数据。</li>\n<li>不同DBMS术语不一样：数据字典(DataDictionary(Oracle))、目录表(DB2UDB)、系统目录(INFORMIX)、系统视图(X/Open)</li>\n<li>不同DBMS中系统目录存储方式可能是不同的,但会有一些信息对DBA公开。这些公开的信息,DBA可以使用一些特殊的SQL命令来检索。</li>\n</ul>\n<h4 id=\"6-2-数据字典的内容构成\"><a href=\"#6-2-数据字典的内容构成\" class=\"headerlink\" title=\"6.2 数据字典的内容构成\"></a>6.2 数据字典的内容构成</h4><p>数据字典通常存储的是数据库和表的元数据，即模式本身的信息：</p>\n<ol>\n<li>与关系相关的信息<ul>\n<li>关系名字</li>\n<li>每一个关系的属性名及其类型</li>\n<li>视图的名字及其定义</li>\n<li>完整性约束</li>\n</ul>\n</li>\n<li>用户与账户信息，包括密码</li>\n<li>统计与描述性数据：如每个关系中元组的数目</li>\n<li>物理文件组织信息：<ul>\n<li>关系是如何存储的(顺序/无序/散列等)</li>\n<li>关系的物理位置</li>\n</ul>\n</li>\n<li>索引相关的信息</li>\n</ol>\n<h4 id=\"6-3-数据字典的结构\"><a href=\"#6-3-数据字典的结构\" class=\"headerlink\" title=\"6.3 数据字典的结构\"></a>6.3 数据字典的结构</h4><ol>\n<li>也是存储在磁盘上的关系</li>\n<li>专为内存高效访问设计的特定的数据结构</li>\n</ol>\n<ul>\n<li>可能的字典数据结构<ul>\n<li><code>Relation_metadata</code> = <code>(relation_name, number_of_attributes, storage_organization, location)</code></li>\n<li><code>Attribute_metadata</code> = <code>(attribute_name, relation_name, domain_type, position, length)</code></li>\n<li><code>User_metadata</code> = <code>(user_name, encrypted_password, group)</code></li>\n<li><code>Index_metadata</code> = <code>(index_name, relation_name, index_type, index_attributes)</code></li>\n<li><code>View_metadata</code> = <code>(view_name, definition)</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-4-X-Open标准的系统目录\"><a href=\"#6-4-X-Open标准的系统目录\" class=\"headerlink\" title=\"6.4 X/Open标准的系统目录\"></a>6.4 X/Open标准的系统目录</h4><ol>\n<li>X/Open标准中有一个目录表Info_Schem.Tables, 该表中的一行是一个已经定义的表的有关信息<ul>\n<li><code>Table_Schem</code>：表的模式名(通常是表所有者的用户名)</li>\n<li><code>Table_Name</code>：表名</li>\n<li><code>Table_Type</code>：<code>&#39;Base_Table&#39;</code>或<code>&#39;View&#39;</code></li>\n</ul>\n</li>\n<li>可以使用SQL语句来访问这个表中的信息，比如了解已经定义了哪些表，可如下进行：<ul>\n<li><code>Select Table_Name From Tables;</code></li>\n</ul>\n</li>\n<li>模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而不混淆。</li>\n<li>一般而言，一个用户有一个模式。可以使用CreateSchema语句来创建模式(用法参见相关文献)，在CreateTable等语句可以使用所定义的模式名称。</li>\n</ol>\n<h4 id=\"6-5-Oracle的数据字典\"><a href=\"#6-5-Oracle的数据字典\" class=\"headerlink\" title=\"6.5 Oracle的数据字典\"></a>6.5 Oracle的数据字典</h4><ol>\n<li>Oracle数据字典由视图组成，分为三种不同形式，由不同的前缀标识<ul>\n<li><code>USER_</code> :用户视图，用户所拥有的对象，在用户模式中</li>\n<li><code>ALL_</code>  :扩展的用户视图，用户可访问的对象</li>\n<li><code>DBA_</code>  :DBA视图(所有用户都可访问的DBA对象的子集)</li>\n</ul>\n</li>\n<li>Oracle数据字典中定义了三个视图<code>USER_Tables</code>,<code>ALL_Tables</code>,和<code>DBA_Tables</code>供DBA和用户使用数据字典中关于<strong>表的信息</strong></li>\n<li>同样,Oracle数据字典中也定义了三个视图<code>USER_TAB_Columns</code>,<code>ALL_TAB_Columns</code>(<code>Accessible_Columns</code>),和<code>DBA_TAB_Columns</code>供DBA和用户使用数据字典中关于表的<strong>列的信息</strong></li>\n<li>可以使用SQL语句来访问这些表中的信息：<ul>\n<li><code>Select Column_Name From ALL_TAB_Columns Where Table_Name = ‘STUDENT’;</code></li>\n</ul>\n</li>\n<li>Oracle数据字典中还定义了其他视图<ul>\n<li><code>TABLE_PRIVILEDGE</code>(或<code>ALL_TAB_GRANTS</code>)</li>\n<li><code>COLUMN_PRIVILEDGE</code>(或<code>ALL_COL_GRANTS</code>)可访问表的权限，列的权限</li>\n<li><code>CONSTRAINT_DEFS</code>(或<code>ALL_CONSTRAINTS</code>)可访问表的各种约束</li>\n</ul>\n</li>\n<li>可以使用下述命令获取Oracle定义的所有视图信息<ul>\n<li><code>Select view_name from all_views where owner = ‘SYS’ and view_name like ‘ALL_%’ or view_name like ‘USER_%’;</code></li>\n</ul>\n</li>\n<li>如果用户使用Oracle,可使用其提供的<code>SQL*PLUS</code>进行交互式访问</li>\n<li>动态SQL: 表和列都已知，动态构造检索条件。</li>\n<li>动态SQL:检索条件可动态构造，表和列也可动态构造。</li>\n</ol>\n<h4 id=\"6-6-SQLDA\"><a href=\"#6-6-SQLDA\" class=\"headerlink\" title=\"6.6 SQLDA\"></a>6.6 SQLDA</h4><p>构造复杂的动态SQL需要了解数据字典及SQLDA，已获知关系模式信息</p>\n<ol>\n<li>SQLDA: SQLDescriptorArea,SQL描述符区域。<ul>\n<li>SQLDA是一个内存数据结构，内可装载关系模式的定义信息，如列的数目，每一列的名字和类型等等</li>\n<li>通过读取SQLDA信息可以进行更为复杂的动态SQL的处理</li>\n<li>不同DBMS提供的SQLDA格式并不是一致的。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id7\"><span></p>\n<h3 id=\"7-ODBC简介\"><a href=\"#7-ODBC简介\" class=\"headerlink\" title=\"7. ODBC简介\"></a>7. ODBC简介</h3><h4 id=\"7-1-ODBC定义\"><a href=\"#7-1-ODBC定义\" class=\"headerlink\" title=\"7.1 ODBC定义\"></a>7.1 ODBC定义</h4><p>ODBC：Open DataBase Connection，ODBC是一种标准—不同语言的应用程序与不同数据库服务器之间通讯的标准。</p>\n<ul>\n<li>一组API(应用程序接口)，支持应用程序与数据库服务器的交互</li>\n<li>应用程序通过调用ODBC API, 实现<ol>\n<li>与数据服务器的连接</li>\n<li>向数据库服务器发送SQL命令</li>\n<li>一条一条的提取数据库检索结果中的元组传递给应用程序的变量</li>\n</ol>\n</li>\n<li>具体的DBMS提供一套驱动程序，即Driver库函数，供ODBC调用，以便实现数据库与应用程序的连接。</li>\n<li>ODBC可以配合很多高级语言来使用，如C,C++, C#, Visual Basic, PowerBuilder等等；</li>\n</ul>\n<h4 id=\"7-2-通过ODBC连接数据库\"><a href=\"#7-2-通过ODBC连接数据库\" class=\"headerlink\" title=\"7.2 通过ODBC连接数据库\"></a>7.2 通过ODBC连接数据库</h4><ol>\n<li>ODBC应用前，需要确认具体DBMS Driver被安装到ODBC环境中</li>\n<li>当应用程序调用ODBC API时，ODBC API会调用具体DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯，执行相应的请求动作并返回检索结果</li>\n<li>ODBC应用程序首先要分配一个SQL环境，再产生一个数据库连接句柄</li>\n<li>应用程序使用SQLConnect()，打开一个数据库连接，SQLConnect()的具体参数:<ul>\n<li><code>connection handle</code>, 连接句柄</li>\n<li><code>the server</code>，要连接的数据库服务器</li>\n<li><code>the user identifier</code>，用户</li>\n<li><code>password</code> ，密码</li>\n<li><code>SQL_NTS</code> 类型说明前面的参数是空终止的字符串</li>\n</ul>\n</li>\n<li>示例<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ODBCexample()&#123;</span><br><span class=\"line\">    RETCODE error; <span class=\"comment\">/* 返回状态吗 */</span></span><br><span class=\"line\">    HENV env; <span class=\"comment\">/* 环境变量 */</span></span><br><span class=\"line\">    HDBC conn; <span class=\"comment\">/* 连接句柄 */</span></span><br><span class=\"line\">    SQLAllocEnv(<span class=\"operator\">&amp;</span>env);</span><br><span class=\"line\">    SQLAllocConnect(env, <span class=\"operator\">&amp;</span>conn);</span><br><span class=\"line\">    <span class=\"operator\">/</span><span class=\"operator\">/</span>分配数据库连接环境</span><br><span class=\"line\">    SQLConnect(conn, &quot;aura.bell-labs.com&quot;, SQL_NTS, &quot;avi&quot;, SQL_NTS, avipasswd&quot;, SQL_NTS);</span><br><span class=\"line\">    //打开一个数据库连接</span><br><span class=\"line\">    &#123; …. Do actual work … &#125;</span><br><span class=\"line\">    //与数据库通讯</span><br><span class=\"line\">    SQLDisconnect(conn);</span><br><span class=\"line\">    SQLFreeConnect(conn);</span><br><span class=\"line\">    SQLFreeEnv(env);</span><br><span class=\"line\">    //断开连接与释放环境</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"7-3-通过ODBC与数据库服务器进行通讯\"><a href=\"#7-3-通过ODBC与数据库服务器进行通讯\" class=\"headerlink\" title=\"7.3 通过ODBC与数据库服务器进行通讯\"></a>7.3 通过ODBC与数据库服务器进行通讯</h4><ol>\n<li>应用程序使用SQLExecDirect()向数据库发送SQL命令；</li>\n<li>使用SQLFetch()获取产生的结果元组；</li>\n<li>使用SQLBindCol()绑定C语言变量与结果中的属性<ul>\n<li>当获取一个元组时，属性值会自动地传送到相应的C语言变量中</li>\n</ul>\n</li>\n<li>SQLBindCol()的参数：<ul>\n<li>ODBC定义的stmt变量,查询结果中的属性位置</li>\n<li>SQL到C的类型变换,变量的地址.</li>\n<li>对于类似字符数组一样的可变长度类型，应给出<ul>\n<li>•变量的最大长度</li>\n<li>•当获取到一个元组后，实际长度的存储位置.</li>\n<li>•注:当返回实际长度为负数，说明是一个空值。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>示例<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> branchname[<span class=\"number\">80</span>]; <span class=\"type\">float</span> balance;</span><br><span class=\"line\"><span class=\"type\">int</span> lenOut1, lenOut2;</span><br><span class=\"line\">HSTMT stmt;</span><br><span class=\"line\">SQLAllocStmt(conn, <span class=\"operator\">&amp;</span>stmt);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>分配一个与指定数据库连接的新的语句句柄</span><br><span class=\"line\"><span class=\"type\">char</span> <span class=\"operator\">*</span> sqlquery <span class=\"operator\">=</span> &quot;select branch_name, sum (balance)</span><br><span class=\"line\">    from account</span><br><span class=\"line\">    group by branch_name&quot;;</span><br><span class=\"line\">error <span class=\"operator\">=</span> SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>执行查询，stmt句柄指向结果集合</span><br><span class=\"line\">if (error <span class=\"operator\">=</span><span class=\"operator\">=</span> SQL_SUCCESS) &#123;</span><br><span class=\"line\">SQLBindCol(stmt, <span class=\"number\">1</span>, SQL_C_CHAR, branchname , <span class=\"number\">80</span>, <span class=\"operator\">&amp;</span>lenOut1);</span><br><span class=\"line\">SQLBindCol(stmt, <span class=\"number\">2</span>, SQL_C_FLOAT, <span class=\"operator\">&amp;</span>balance, <span class=\"number\">0</span> , <span class=\"operator\">&amp;</span>lenOut2);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>绑定高级语言变量与stmt句柄中的属性</span><br><span class=\"line\">while (SQLFetch(stmt) <span class=\"operator\">&gt;=</span> SQL_SUCCESS) &#123;</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>提取一条记录，结果数据被存入高级语言变量中</span><br><span class=\"line\">    printf (&quot; %s %g\\n&quot;, branchname, balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SQLFreeStmt(stmt, SQL_DROP);</span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span>释放语句句柄</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"7-4-ODBC的其他功能\"><a href=\"#7-4-ODBC的其他功能\" class=\"headerlink\" title=\"7.4 ODBC的其他功能\"></a>7.4 ODBC的其他功能</h4><ol>\n<li>动态SQL语句的预编译-动态参数传递功能</li>\n<li>获取元数据特性<ul>\n<li>发现数据库中的所有关系的特性 以及</li>\n<li>发现每一个查询结果的列的名字和类型等；</li>\n</ul>\n</li>\n<li>默认, 每一条SQL语句都被作为一个独立的能够自动提交的事务来处理。<ul>\n<li>应用程序可以关闭一个连接的自动提交特性<ul>\n<li><code>SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0)&#125;</code></li>\n</ul>\n</li>\n<li>此时事务要显式地给出提交和撤销的命令<ul>\n<li><code>SQLTransact(conn, SQL_COMMIT)</code> or <code>SQLTransact(conn, SQL_ROLLBACK)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id8\"><span></p>\n<h3 id=\"8-JDBC简介\"><a href=\"#8-JDBC简介\" class=\"headerlink\" title=\"8. JDBC简介\"></a>8. JDBC简介</h3><h4 id=\"8-1-JDBC定义\"><a href=\"#8-1-JDBC定义\" class=\"headerlink\" title=\"8.1 JDBC定义\"></a>8.1 JDBC定义</h4><p>JDBC：Java DataBase Connection，JDBC是一组Java版的应用程序接口API，提供了Java应用程序与数据库服务器的连接和通讯能力。</p>\n<ul>\n<li>JDBCAPI分成两个程序包：<ul>\n<li>Java.sql 核心API –J2SE(Java2标准版)的一部分。使用<code>java.sql.DriverManager</code>类、<code>java.sql.Driver</code>和<code>java.sql.Connection</code>接口连接到数据库</li>\n<li>Javax.sql 可选扩展API–J2EE(Java2企业版)的一部分。包含了基于<code>JNDI(JavaNamingandDirectoryInterface,Java命名和目录接口)</code>的资源，以及管理连接池、分布式事务等，使用DataSource接口连接到数据库。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"8-2-JDBC的功能\"><a href=\"#8-2-JDBC的功能\" class=\"headerlink\" title=\"8.2 JDBC的功能\"></a>8.2 JDBC的功能</h4><ol>\n<li><code>java.sql.DriverManager</code>——处理驱动的调入并且对产生新数据库连接提供支持</li>\n<li><code>Java.sql.Driver</code>——通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动。</li>\n<li><code>java.sql.Connection</code>——代表对特定数据库的连接。</li>\n<li><code>Try &#123;…&#125; Catch &#123;…&#125;</code> ——异常捕获及其处理</li>\n<li><code>java.sql.Statement</code>——对特定的数据库执行SQL语句</li>\n<li><code>java.sql.PreparedStatement</code> —— 用于执行预编译的SQL语句</li>\n<li><code>java.sql.CallableStatement</code> ——用于执行对数据库内嵌过程的调用。</li>\n<li><code>java.sql.ResultSet</code>——从当前执行的SQL语句中返回结果数据。</li>\n</ol>\n<h4 id=\"8-3-使用JDBC-API访问数据库的过程\"><a href=\"#8-3-使用JDBC-API访问数据库的过程\" class=\"headerlink\" title=\"8.3 使用JDBC API访问数据库的过程\"></a>8.3 使用JDBC API访问数据库的过程</h4><ol>\n<li><p>概念性的基本过程</p>\n<ul>\n<li>打开一个连接；创建“Statement”对象，并设置查询语句；使用Statement对象执行查询，发送查询给数据库服务器和返回结果给应用程序；处理错误的例外机制</li>\n</ul>\n</li>\n<li><p>具体实施过程</p>\n<ol>\n<li>•传递一个Driver给DriverManager，加载数据库驱动。<ul>\n<li><code>Class.forName()</code></li>\n</ul>\n</li>\n<li>•通过URL得到一个Connection对象, 建立数据库连接<ul>\n<li><code>DriverManager.getConnection(sDBUrl)</code></li>\n<li><code>DriverManager.getConnection(sDBUrl,sDBUserID,sDBPassword)</code></li>\n</ul>\n</li>\n<li>•接着创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库。<ul>\n<li><code>Statement stmt=con.createStatement()</code></li>\n</ul>\n</li>\n<li>•查询返回一个ResultSet。<ul>\n<li><code>ResultSet rs=stmt.executeQuery(sSQL)</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">JDBCexample</span><span class=\"params\">(String dbid, String userid, String passwd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">try</span> &#123; <span class=\"comment\">//错误捕获</span></span><br><span class=\"line\">    Class.forName (<span class=\"string\">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class=\"line\">    Connection conn = DriverManager.getConnection(</span><br><span class=\"line\">        <span class=\"string\">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>, userid, passwd);</span><br><span class=\"line\">    <span class=\"comment\">//加载数据库驱动，建立数据库连接</span></span><br><span class=\"line\">    Statement stmt = conn.createStatement();</span><br><span class=\"line\">    <span class=\"comment\">//创建一个语句对象</span></span><br><span class=\"line\">    … Do Actual Work ….</span><br><span class=\"line\">    <span class=\"comment\">//进行SQL语句的执行与处理工作</span></span><br><span class=\"line\">    stmt.close();</span><br><span class=\"line\">    conn.close();</span><br><span class=\"line\">    <span class=\"comment\">//关闭语句对象，关闭连接</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (SQLException sqle) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;SQLException : &quot;</span> + sqle); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>完整的示例程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">JDBCexample</span><span class=\"params\">(String dbid, String userid, String passwd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Class.forName (<span class=\"string\">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class=\"line\">    Connection conn = DriverManager.getConnection(</span><br><span class=\"line\">        <span class=\"string\">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>, userid, passwd);</span><br><span class=\"line\">    Statement stmt = conn.createStatement();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        stmt.executeUpdate( <span class=\"string\">&quot;insert into instructor values</span></span><br><span class=\"line\"><span class=\"string\">        (‘77987&#x27;, ‘Kim&#x27;, ‘Physics’,98000)&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SQLException sqle) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;插入错误:&quot;</span> + sqle);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ResultSet rset = stmt.executeQuery(</span><br><span class=\"line\">        <span class=\"string\">&quot;select dept_name, avg(salary) from instructor group by dept_name&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( rset.next() ) &#123;</span><br><span class=\"line\">        System.out.println(rset.getString(“dept_name<span class=\"string\">&quot;) + &quot;</span> <span class=\"string\">&quot; + rset.getFloat(2));</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    stmt.close();</span></span><br><span class=\"line\"><span class=\"string\">    conn.close();</span></span><br><span class=\"line\"><span class=\"string\">&#125; catch (SQLException sqle) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    System.out.println(&quot;</span>SQLException:<span class=\"string\">&quot; + sqle);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><span id=\"id9\"><span></p>\n<h3 id=\"9-嵌入式SQL-ODBC-JDBC三者比较\"><a href=\"#9-嵌入式SQL-ODBC-JDBC三者比较\" class=\"headerlink\" title=\"9. 嵌入式SQL-ODBC-JDBC三者比较\"></a>9. 嵌入式SQL-ODBC-JDBC三者比较</h3><p>执行一条SQL语句，读取执行的结果集合</p>\n<ol>\n<li>嵌入式SQL的思维模式<ol>\n<li>建立数据库连接</li>\n<li>声明一个游标</li>\n<li>打开游标</li>\n<li>读取一条记录(循环)</li>\n<li>关闭游标</li>\n<li>断开数据库连接</li>\n</ol>\n</li>\n<li>ODBC的思维模式<ol>\n<li>建立数据库连接</li>\n<li>分配语句句柄</li>\n<li>用句柄执行SQL</li>\n<li>建立高级语言变量与句柄属性的对应</li>\n<li>读取一条记录(循环)</li>\n<li>释放语句句柄</li>\n<li>断开数据库连接</li>\n</ol>\n</li>\n<li>JDBC的思维模式<ol>\n<li>建立数据库连接</li>\n<li>创建语句对象</li>\n<li>用语句对象执行SQL，并返回结果对象</li>\n<li>从结果对象获取一条记录</li>\n<li>提取对象的属性值传给高级语言变量(返回上一步)</li>\n<li>释放语句对象</li>\n<li>断开数据库连接</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>相同点: 都是建立数据库连接, 执行sql, 处理结果, 释放连接, 流程基本一致</li>\n<li>不同点, 操作方式的不同:<ul>\n<li>嵌入式SQL按照语句进行操作</li>\n<li>ODBC按照函数来进行操作</li>\n<li>JDBC按照对象来进行操作</li>\n</ul>\n</li>\n</ul>"},{"title":"【数据库】数据库系统基础","date":"2019-06-22T12:20:19.000Z","_content":"\n### 概述\n1. 数据库 是 电子化信息的集合\n  * 将信息规范化并使之电子化，形成电子信息'库'，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。\n2. 表(Table)：以按行按列形式组织及展现的数据\n<!-- more -->\n  * 数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据-->关系\n3. 数据库系统的构成（概念层次）:\n  1. 数据库(DB):Database：相互之间有关联关系的数据的集合\n  2. 数据库管理系统(DBMS):Database Management System\n  3. 数据库应用(DBAP):Database Application\n  4. 数据库管理员(DBA):Database Asministrator\n  5. 计算机基本系统\n\n#### 目录：\n1. [数据库管理系统(DBMS)](#id1)\n2. [数据库系统的标准结构](#id2)\n3. [三级模式两层映像](#id3)\n4. [数据模型](#id4)\n5. [关系模型](#id5)\n6. [关系模型中的完整性](#id6)\n7. [关系代数](#id7)\n8. [关系演算](#id8)\n\n\n<span id=\"id1\"><span>\n### 1. 数据库管理系统(DBMS)\n#### 1.1 从用户角度看DBMS(数据库管理系统)\n1. 数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等\n  * DBMS提供了一套**数据定义语言(DDL**: Data Definition Language)给用户\n  * 用户使用DDL描述其所要建立的表的格式\n  * DBMS依照用户的定义，创建数据库及其中的表\n2. 数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等\n  * DBMS提供了一套**数据库操纵语言(DML**: Data Manipulation Language)给用户\n  * 用户使用DML描述其所要进行的增、删、改、查等操作\n  * DBMS依照用户的操作描述，实际执行这些操作\n3. 数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)\n  * DBMS提供了一套**数据控制语言(DCL**: Data Control Language)给用户\n  * 用户使用DCL描述其对数据库所要实施的控制\n  * DBMS依照用户描述，实际ijnx控制\n4. 数据库维护：转储/恢复/重组/性能监测/分析...\n  * DBMS提供了一系列程序(实用程序/例行程序)给用户\n  * 在这些程序中提供了对数据库维护的各种功能\n  * 用户使用这些程序进行各种数据库维护操作\n  * (数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)\n\n\n#### 1.2 数据库语言 \n* 使用者使用数据库语言，利用DBMS操纵数据库\n* SQL语言：结构化的数据库语言\n* 高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用\n\n\n#### 1.3 从系统实现角度看DBMS的功能\n1. 数据库管理系统的实现：形式 --> 构造 --> 自动化\n2. DBMS为完成DB管理，在后台运行着一系列程序...\n  + **语言编译器**：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等\n  + **查询优化**(执行引擎)与**查询实现**(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序\n  + **数据存取与索引**：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等\n  + **通信控制**：提供网络环境下数据库操作与数据传输的手段\n  + **事务管理**：提供提高可靠性并避免并发操作错误的手段\n  + **故障恢复**：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序\n  + **安全性控制**：提供合法性检验，避免非授权非法用户访问数据库的手段\n  + **完整性控制**：提供数据及数据操作正确性检查的手段\n  + **数据字典管理**：管理用户已经定义的信息\n  + **应用程序接口(API)**：提供应用程序使用DBMS特定功能的二首段\n  + **数据库数据装载、重组等实用程序**\n  + **数据库性能分析**：统计在运行过程中数据库的各种性能数据，便于优化运行\n\n> 典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL \n\n\n<span id=\"id2\"><span>\n### 2. 数据库系统的标准结构\nDBMS管理数据的三个层次：\n1. External Level = User Level（外部级别 = 用户级别）\n  * 某一用户能够看到与处理的数据,   全局数据中的某一部分\n2. Conceptual Level = Logic level（概念级别 = 逻辑级别）\n  * 从全局角度理解/管理的数据, 含相应的关联约束\n3. Internal Level = Physical level（内部级别 = 物理级别）\n  * 存储在介质上的数据，含存储路径、存储方式 、索引方式等\n\n<span id=\"id3\"><span>\n### 3. 三级模式两层映像\n数据库的三级模式结构是指：数据库系统是由外模式、模式(概念模式)和内模式三级构成\n* 应用--> 外模式(多个) --> 模式(一个) --> 内模式(一个) --> 数据库\n\n#### 3.1 数据(视图)与模式(数据的结构)\n+ 模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息\n+ 视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据\n\n#### 3.2 三级模式(三级视图)\n1. External Schema ----(External) View\n  * 外模式：某一用户能够看到与处理的数据的结构描述\n2. (Conceptual) Schema ---- Conceptual View\n  * 模式(概念模式)：从全局角度理解/管理的数据的结构描述, 含相应的关联约束\n  * 体现在数据之间的内在本质联系\n3. Internal Schema ---- Internal  View\n  * 内模式：存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等\n\n#### 3.3 两层映像\n1. E-C Mapping：External Schema-Conceptual Schema Mapping \n  + 将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换\n  + 便于用户观察和使用\n2. C-I Mapping：Conceptual Schema-Internal Schema Mapping \n  + 将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换\n  + 便于计算机进行存储和处理\n\n#### 3.4 标准结构的两个独立性\n1. 逻辑数据独立性\n  + 当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序\n2. 物理数据独立性\n  + 当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式\n\n\n<span id=\"id4\"><span>\n### 4. 数据模型\n1. 数据模型：模式 与 模式的结构\n  - 规定模式统一描述方式的模型，包括：数据结构、操作和约束\n  - 数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象\n  - 比如：关系模型：所有模式都可为抽象表(Table)的形式[**数据结构**]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[**操作**]和[**约束**]\n2. 三大经典数据模型\n  - 关系模型：**表**的形式组织数据\n  - 层次模型：**树**的形式组织数据\n  - 网状模型：**图**的形式组织数据\n\n<span id=\"id5\"><span>\n### 5. 关系模型\n1. 形象地说，**一个关系(relation)就是一个Table**，关系模型就是处理Table的，它由三个部分组成：\n  + 描述DB各种数据的基本结构形式(Table/Relation)\n  + 描述Table与Table之间所可能发生的各种操作(关系运算)\n  + 描述这些操作所应遵循的约束条件(完整性约束)\n2. 关系模型的三个要素：\n  + 基本结构：Relation/Table\n  + 基本操作：Relation Operator\n    - 基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。\n    - 扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算\n  + 完整性约束：实体完整性、参照完整性和用户自定义的完整性\n3. 表(Table)的基本构成要素\n  + 列/字段/属性/数据项：列名，列值\n  + 行/元组/记录\n  + 标题/模式\n\n#### 5.1 “表”的严格定义\n* 域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型\n* 笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组\n* 关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)\n\n#### 5.2 关系模式与关系\n* 同一关系模式下，可有很多的关系\n* 关系模式是关系的结构, 关系是关系模式在某一时刻的数据\n* 关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的\n\n#### 5.3 关系的特性\n* 列是同质：即每一列中的分量来自同一域，是同一类型的数据\n* 不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。\n* 列位置互换性：区分哪一列是靠列名\n* 行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)\n* 关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分\n* 理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。\n* 属性不可再分特性:又被称为关系第一范式\n\n#### 5.4 关系的一些重要概念\n1. 候选码(Candidate Key)/候选键\n  - 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉\n任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。\n2. 主码(Primary Key)/主键\n  - 当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组\n3. 主属性与非主属性\n  - 包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性\n  - 最简单的，候选码只包含一个属性；\n  - 极端的，所有属性构成这个关系的候选码，称为全码(All-Key)\n4. 外码(Foreign Key)/外键\n  - 关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。\n  - 两个关系通常是靠外码连接起来的。\n\n\n<span id=\"id6\"><span>\n### 6. 关系模型中的完整性\n#### 6.1 实体完整性\n* 关系的主码中的属性值不能为空值；\n* 意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。\n\n#### 6.2 参照完整性\n* 如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值\n* 意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在\n\n#### 6.3 用户自定义完整性\n* 用户针对具体的应用环境定义的完整性约束条件\n\n#### 6.4 DBMS对关系完整性的支持\n* 实体完整性和参照完整性由DBMS系统自动支持\n* DBMS系统通常提供了如下机制：\n  1. 它使用户可以自行定义有关的完整性约束条件\n  2. 当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性\n\n\n<span id=\"id7\"><span>\n### 7. 关系代数\n#### 7.1 关系代数的特点\n* 基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作\n* 以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。\n* 关系代数操作以一个或多个关系为输入，结果是一个新的关系。\n* 用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。\n* 是一种抽象的语言，是学习其他数据库语言，如SQL等的基础\n\n#### 7.2 关系代数的约束\n某些关系代数操作，如并、差、交等，需满足\"并相容性\"\n* 并相容性：\n  1. 参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性\n  2. 定义：关系R与关系S存在相容性，当且仅当：\n    - (1) 关系R和关系S的属性数目必须相同；\n    - (2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同\n  + 示例：关系R：STUDENT(SID **char(10)**, Sname **char(8)**, Age **char(3)**)\n  + 示例：关系S：TEACHER(TID **char(10)**, Tname **char(8)**, Age **char(3)**)\n\n\n#### 7.3 关系代数的基本操作\n1. 集合操作\n  * 并（UNIO）：R∪S\n  * 交（INTERSECTION）：R∩S\n  * 差（DIFFERENCE）：R-S\n  * 笛卡儿积（Cartesian PRODUCT）：R×S\n2. 纯关系操作\n  * 选择（SELECT）：σF(R)\n  * 投影（PROJECT）：ΠA(R)\n  * 连接（JOIN）：R⋈S\n  * 除（DIVISION）：R÷S\n\n##### 7.3.1 并(Union) 操作\n* 定义：设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：**`R∪S`**, 它由 或者出现在关系R中，或者出现在S中的元组构成。\n* 数学描述：`R∪S={t|t∈R∨t∈S}`，其中t是元组\n* 并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。\n* 汉语中的“或者…或者…”通常意义是并运算的要求。\n* `R∪S` 与 `S∪R` 运算的结果是**同**一个关系\n\n##### 7.3.2 差(Difference) 操作\n* 定义：设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：**`R-S`**, 它由出现在关系R中但不出现在关系S中的元组构成。\n* 数学描述：`R－S={t|t∈R∧t∉S}`，其中t是元组\n* 汉语中的“是…但不含…”通常意义是差运算的要求。\n* `R-S` 与 `S-R` 是**不同**的\n\n##### 7.3.3  交（Intersection Referential integrity） 操作\n* 定义：设关系R和关系S具有相同的目n，且相应的属性取自同一个域，则关系R与关系S的交由既属于R又属于S的元组组成。其结果关系仍为n目关系。\n* 数学描述：`R∩S={t|t∈R∧t∈S}`，其中t是元组\n\n##### 7.3.4 广义笛卡尔积(Extended cartesian product) 操作\n* 定义：关系`R(<a1,a2, …,an>)`与关系`S(<b1,b2, …,bm >)`的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：**`RxS`**；两个分别为n目和m目的关系R和S的广义笛卡尔积是一个(n+m)列的元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组，若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。\n* 数学描述：`RxS = {<a1,a2,…,an,b1,b2,…,bm>|<a1,a2,…,an>∈R ∧ <b1,b2,…,bm>∈S}`\n* `RxS=SxR`：RxS为R中的每一个元组都和S中的所有元组进行串接。`SxR`为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。\n* 两个关系R和S，它们的**属性个数**分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).\n* 两个关系R和S，它们的**元组个数**分别为x和y(关系R的基数x,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).\n\n##### 7.3.5 选择(Select)\n* 定义：给定一个关系R, 同时给定一个选择的条件condition(简记F), 选择运算结果也是一个关系，记作**`σF(R)`**, 它从关系R中选择出满足给定条件condition的元组构成。\n* 数学描述：`σF(R) = {t|t∈R ∧ F(t)='真'}`,其中F表示选择条件，它是一个逻辑表达式，取逻辑值‘真’或‘假’。\n* 选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ `括弧()；θ；¬；∧；∨` }\n\n##### 7.3.6 投影(Project)\n* 定义：给定一个关系R, 投影运算结果也是一个关系，记作**`A(R)`**, 它从关系R中选出属性包含在A中的列构成。\n* 数学描述：`ΠA(R) = {t[A] | t∈R}`,其中A为R中的属性列\n* 投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系\n\n\n#### 7.4 关系代数的扩展操作\n##### 7.4.1 交(Intersection)\n* **定义**：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：**`R∩S`**, 它由同时出现在关系R和关系S中的元组构成。\n* 数学描述：`R∩S = {t|t∈R ∧ t∈S}`，其中t是元组\n* R∩S 和 S∩R 运算的结果是同一个关系\n* 交运算可以通过差运算来实现：`R∩S = R-(R-S) = S-(S-R)`\n* 汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求\n\n##### 7.4.2 θ-连接(θ-Join, theta-Join)\n* 投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作\n* **定义**：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 **`R⋈S[AθB]`**：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。\n* 数学描述：`R⋈S[AθB] = σ t[A]θs[B] (R×S)`，σF(RxS)其中t是R中的元组，s是S中的元组\n* 在实际应用中，θ-连接操作经常与投影Π、选择σ操作一起使用\n* **特别注意**：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。\n\n##### 7.4.3 等值连接(Equi-Join)\n* **定义**：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作**`R⋈S[A=B]`**：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。\n* 数学描述：`R⋈S[A=B] = σ t[A]=s[B] (R×S)`\n* 当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；\n* 广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用**θ-连接/等值连接**运算可大幅度降低中间结果的保存量，提高速度。\n\n##### 7.4.4 自然连接(Natural-Join)\n* 定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。\n* 数学描述：`R⋈S = σ t[B]=s[B] (R×S)`\n* 自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列\n\n#### 7.5 关系代数的基本书写思路\n1. 选出将用到的关系/表\n2. 做\"积\"运算（可用连接运算替换）\n3. 做选择运算保留所需的行/元组\n4. 做投影运算保留所需的列/属性\n\n- 基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可\n- 如涉及多个表，则检查：\n  * 能否使用自然连接，将多个表连接起来(多数情况是这样的)\n  * 如不能，能否使用等值或不等值连接(θ-连接)\n  * 还不能，则使用广义笛卡尔积，注意相关条件的书写\n- 连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作\n\n\n#### 7.6 关系代数之复杂扩展操作\n##### 7.6.1 除(Division)\n* 除法运算经常用于求解“查询… 全部的/所有的…”问题\n* 前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m < n。\n* 定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。\n* 数学描述：\n``` math\nR÷S = {t|t∈Π[R-S](R) ∧ ∀u∈S(tu∈R) }\n    = Π[R-S](R) - Π[R-S]((Π[R-S](R)×S)-R)\n```\n> 其中[R-S]为投影Π的下标(属性)\n\n##### 7.6.2 外连接(Outer-Join)\n* 定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。\n* 外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)\n* 外连接的形式：左外连接、右外连接、全外连接\n  - 左外连接 = 自然连接(或连接) + 左侧表中失配的元组\n  - 右外连接 = 自然连接(或连接) + 右侧表中失配的元组\n  - 全外连接 = 自然连接(或连接) + 两侧表中失配的元组\n  - 左外连接(Left Outer Join)记为：⋊\n  - 右外连接(Right Outer Join)记为：⋉\n  - 全外连接(Full Outer Join)记为：⋊⋉\n\n\n<span id=\"id8\"><span>\n### 8. 关系演算\n关系演算是**描述关系运算**的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的\n* 按照谓词变量的不同，可分为关系元组演算和关系域演算\n  1. 关系元组演算是以**元组变量**作为谓词变量的基本对象\n  2. 关系域演算是以**域变量**作为谓词变量的基本对象\n\n#### 8.1 关系元组演算\n1. 关系元组演算公式：{ t | P(t) }\n  - 表示：所有使谓词 P 为真的元组 t 的集合\n  - t 是元组变量\n  - t ∈ r 表示元组 t 在关系 r 中\n  - t[A] 表示元组 t 的分量，即 t 在属性 A 上的值\n  - P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式\n2. 关系元组演算公式的基本形式：{ t | P(t) }\n3. P(t)可以是如下三种形式之一的原子公式：\n  + t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}\n  + s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符<,<=,=,<>,>,>=\n  + s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，\n4. P(t)可以由公式加运算符 ∧(与)、∨(或)、¬(非)递归地构造\n  + 如果F是一个公式，则 ¬F 也是公式\n  + 如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式\n5. P(t)运算符优先次序(括弧；θ；∃；∀；¬；∧；∨)示例\n6. 构造P(t)还有两个运算符：∃(存在)、∀(任意)\n  + 如果F是一个公式，则 ∃(t∈r)(F(t)) 也是公式\n  + 如果F是一个公式，则 ∀(t∈r)(F(t)) 也是公式\n  + 运算符∃和∀，又称为量词，前者称“**存在量词**”，后者称“**全称量词**”\n  + 而被∃或∀限定的元组变量 t , 或者说，元组变量 t 前有存在量词或全称量词，则该变量被称为“**约束变量**”，否则被称为“**自由变量**”。\n7. 元组演算的等价性变换\n    + 符号`<=>`表示表示等价于,如：`¬(A>B) <=> A<=B  <=> A<B∨A=B`\n\n\n#### 8.2 关系域演算\n1. 关系域演算公式的基本形式：`{<x1,x2, …,xn> | P(x1,x2, …,xn)}`,其中 xi 代表域变量或常量, P为以xi为变量的公式。\n2. 元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后再找到元组分量，进行谓词判断；\n3. 域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变量组成的元组是否存在或是否满足谓词判断。\n4. 公式的运算符(∧(与)、∨(或)、¬(非)、∀(全称量词)和∃(存在量词))是相同的，只是其中的变量不同。\n5. 元组演算和域演算可以等价互换。\n\n##### 8.2.1 基于关系域演算的QBE语言\nQBE: Query By Example，1975年由M. M. Zloof提出，1978年在IBM370上实现，是一种高度非过程化的查询语言，特别适合于终端用户的使用。\n1. 特点：操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只需将条件填在表格中即可\n2. QBE操作框架由四个部分构成\n    + 关系名区：用于书写欲待查询的关系名\n    + 属性名区：用于显示对应关系名区关系的所有属性名\n    + 操作命令区：用于书写查询操作的命令\n    + 查询条件区：用于书写查询条件\n3. QBE的操作命令\n    + Print 或 P.   ---- 显示输出操作\n    + Delete或D.   ---- 删除操作\n    + Insert或I.     ---- 插入操作\n    + Update或U. ---- 更新操作\n4. 构造查询的几个要素 \n    + 示例元素: 即域变量， 一定要加下划线 \n    + 示例元素是这个域中可能的一个值， 它不必是查询结果中的元素\n    + 打印操作符P.: 指定查询结果所含属性列 \n    + 查询条件: 不用加下划线\n    + 可使用比较运算符＞， ≥，＜， ≤，＝和≠  其中＝可以省略\n    + 排序要求 \n        - 升序排序(AO.)，降序排序（DO.）,多列排序，用‚AO(i).‛ 或‚DO(i).‛ 表示 ，其中i为排序的优先级， i值越小，优先级越高\n\n#### 8.3 安全性\n关系运算的安全性：不产生无限关系和无穷验证的运算被称为是安全的\n1. 关系代数是一种集合运算，是安全的\n    + 集合本身是有限的，有限元素集合的有限次运算仍旧是有限的。\n2. 关系演算不一定是安全的\n    + 如：{t|¬(R(t))}, {t R(t)∨t[2]>3}可能表示无限关系\n3. 需要对关系演算施加约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。\n\n##### 8.3.1 安全约束有限集合DOM\n1. DOM(ψ)是一个有限集合，其中的每个符号要么是ψ中明显出现的符号，要么是出现在ψ中的某个关系R的某元组的分量。\n2. DOM主要用于约束ψ中一些谓词的计算范围，它不必是最小集合。\n3. 安全元组演算表达式，满足三个条件：\n    + 只要t满足ψ，t的每个分量就是DOM(ψ)的一个成员。\n        - { t|ψ(t) }中t的取值只能是DOM中的值，有限的。\n    + 对于ψ中形如(∃u)(ω(u))的子表达式，若u满足ω,则u的每个分量都是DOM(ω)中的成员。\n        - { t|ψ(t) }中的每个(∃u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为真的元素。而对于DOM以外的元素，已经明确其都不满足ω(u)，无需验证。\n    + 对于ψ中形如(∀u)(ω(u))的子表达式，若u不满足ω,则u的每个分量都是DOM(ω)中的成员。\n        - { t|ψ(t) }中的每个(∀u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为假的元素。而对于DOM以外的元素，已经明确其都满足ω(u)，无需验证。\n\n\n#### 8.4 关于三种关系运算的一些观点\n1. 关系运算有三种：关系代数、关系元组演算和关系域演算\n2. 三种关系运算都是抽象的数学运算，体现了三种不同的思维\n    + 关系代数---以集合为对象的操作思维，由集合到集合的变换\n    + 元组演算---以元组为对象的操作思维，取出关系的每一个元组进行验证，有一个元组变量则可能需要一个循环，多个元组变量则需要多个循环\n    + 域演算---以域变量为对象的操作思维，取出域的每一个变量进行验证看其是否满足条件\n3. 三种运算之间是等价的\n    + 关系代数 与 安全的元组演算表达式 与 安全的域演算表达式 是等\n价的。即一种形式的表达式可以被等价地转换为另一种形式\n4. 三种关系运算都可说是非过程性的\n    + 相比之下：域演算的非过程性最好，元组演算次之，关系代数最差\n5. 三种关系运算虽是抽象的，但却是衡量数据库语言完备性的基础\n    + 一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的\n    + 目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他的操作，如赋值操作、聚集操作等\n6. 数据库语言可以基于这三种抽象运算来设计\n    + 用“键盘符号”来替换抽象的数学符号\n    + 用易于理解的符号组合来表达抽象的数学符号\n    + 例如：ISBL语言---基于关系代数的数据库语言\n    + 再例如：Ingres系统的QUEL语言\n\n\n","source":"_posts/【数据库】数据库系统基础.md","raw":"---\ntitle: 【数据库】数据库系统基础\ndate: 2019-06-22 20:20:19\ntags: [数据库, 后端开发]\ncategories: 数据库\n---\n\n### 概述\n1. 数据库 是 电子化信息的集合\n  * 将信息规范化并使之电子化，形成电子信息'库'，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。\n2. 表(Table)：以按行按列形式组织及展现的数据\n<!-- more -->\n  * 数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据-->关系\n3. 数据库系统的构成（概念层次）:\n  1. 数据库(DB):Database：相互之间有关联关系的数据的集合\n  2. 数据库管理系统(DBMS):Database Management System\n  3. 数据库应用(DBAP):Database Application\n  4. 数据库管理员(DBA):Database Asministrator\n  5. 计算机基本系统\n\n#### 目录：\n1. [数据库管理系统(DBMS)](#id1)\n2. [数据库系统的标准结构](#id2)\n3. [三级模式两层映像](#id3)\n4. [数据模型](#id4)\n5. [关系模型](#id5)\n6. [关系模型中的完整性](#id6)\n7. [关系代数](#id7)\n8. [关系演算](#id8)\n\n\n<span id=\"id1\"><span>\n### 1. 数据库管理系统(DBMS)\n#### 1.1 从用户角度看DBMS(数据库管理系统)\n1. 数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等\n  * DBMS提供了一套**数据定义语言(DDL**: Data Definition Language)给用户\n  * 用户使用DDL描述其所要建立的表的格式\n  * DBMS依照用户的定义，创建数据库及其中的表\n2. 数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等\n  * DBMS提供了一套**数据库操纵语言(DML**: Data Manipulation Language)给用户\n  * 用户使用DML描述其所要进行的增、删、改、查等操作\n  * DBMS依照用户的操作描述，实际执行这些操作\n3. 数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)\n  * DBMS提供了一套**数据控制语言(DCL**: Data Control Language)给用户\n  * 用户使用DCL描述其对数据库所要实施的控制\n  * DBMS依照用户描述，实际ijnx控制\n4. 数据库维护：转储/恢复/重组/性能监测/分析...\n  * DBMS提供了一系列程序(实用程序/例行程序)给用户\n  * 在这些程序中提供了对数据库维护的各种功能\n  * 用户使用这些程序进行各种数据库维护操作\n  * (数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)\n\n\n#### 1.2 数据库语言 \n* 使用者使用数据库语言，利用DBMS操纵数据库\n* SQL语言：结构化的数据库语言\n* 高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用\n\n\n#### 1.3 从系统实现角度看DBMS的功能\n1. 数据库管理系统的实现：形式 --> 构造 --> 自动化\n2. DBMS为完成DB管理，在后台运行着一系列程序...\n  + **语言编译器**：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等\n  + **查询优化**(执行引擎)与**查询实现**(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序\n  + **数据存取与索引**：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等\n  + **通信控制**：提供网络环境下数据库操作与数据传输的手段\n  + **事务管理**：提供提高可靠性并避免并发操作错误的手段\n  + **故障恢复**：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序\n  + **安全性控制**：提供合法性检验，避免非授权非法用户访问数据库的手段\n  + **完整性控制**：提供数据及数据操作正确性检查的手段\n  + **数据字典管理**：管理用户已经定义的信息\n  + **应用程序接口(API)**：提供应用程序使用DBMS特定功能的二首段\n  + **数据库数据装载、重组等实用程序**\n  + **数据库性能分析**：统计在运行过程中数据库的各种性能数据，便于优化运行\n\n> 典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL \n\n\n<span id=\"id2\"><span>\n### 2. 数据库系统的标准结构\nDBMS管理数据的三个层次：\n1. External Level = User Level（外部级别 = 用户级别）\n  * 某一用户能够看到与处理的数据,   全局数据中的某一部分\n2. Conceptual Level = Logic level（概念级别 = 逻辑级别）\n  * 从全局角度理解/管理的数据, 含相应的关联约束\n3. Internal Level = Physical level（内部级别 = 物理级别）\n  * 存储在介质上的数据，含存储路径、存储方式 、索引方式等\n\n<span id=\"id3\"><span>\n### 3. 三级模式两层映像\n数据库的三级模式结构是指：数据库系统是由外模式、模式(概念模式)和内模式三级构成\n* 应用--> 外模式(多个) --> 模式(一个) --> 内模式(一个) --> 数据库\n\n#### 3.1 数据(视图)与模式(数据的结构)\n+ 模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息\n+ 视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据\n\n#### 3.2 三级模式(三级视图)\n1. External Schema ----(External) View\n  * 外模式：某一用户能够看到与处理的数据的结构描述\n2. (Conceptual) Schema ---- Conceptual View\n  * 模式(概念模式)：从全局角度理解/管理的数据的结构描述, 含相应的关联约束\n  * 体现在数据之间的内在本质联系\n3. Internal Schema ---- Internal  View\n  * 内模式：存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等\n\n#### 3.3 两层映像\n1. E-C Mapping：External Schema-Conceptual Schema Mapping \n  + 将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换\n  + 便于用户观察和使用\n2. C-I Mapping：Conceptual Schema-Internal Schema Mapping \n  + 将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换\n  + 便于计算机进行存储和处理\n\n#### 3.4 标准结构的两个独立性\n1. 逻辑数据独立性\n  + 当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序\n2. 物理数据独立性\n  + 当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式\n\n\n<span id=\"id4\"><span>\n### 4. 数据模型\n1. 数据模型：模式 与 模式的结构\n  - 规定模式统一描述方式的模型，包括：数据结构、操作和约束\n  - 数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象\n  - 比如：关系模型：所有模式都可为抽象表(Table)的形式[**数据结构**]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[**操作**]和[**约束**]\n2. 三大经典数据模型\n  - 关系模型：**表**的形式组织数据\n  - 层次模型：**树**的形式组织数据\n  - 网状模型：**图**的形式组织数据\n\n<span id=\"id5\"><span>\n### 5. 关系模型\n1. 形象地说，**一个关系(relation)就是一个Table**，关系模型就是处理Table的，它由三个部分组成：\n  + 描述DB各种数据的基本结构形式(Table/Relation)\n  + 描述Table与Table之间所可能发生的各种操作(关系运算)\n  + 描述这些操作所应遵循的约束条件(完整性约束)\n2. 关系模型的三个要素：\n  + 基本结构：Relation/Table\n  + 基本操作：Relation Operator\n    - 基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。\n    - 扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算\n  + 完整性约束：实体完整性、参照完整性和用户自定义的完整性\n3. 表(Table)的基本构成要素\n  + 列/字段/属性/数据项：列名，列值\n  + 行/元组/记录\n  + 标题/模式\n\n#### 5.1 “表”的严格定义\n* 域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型\n* 笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组\n* 关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)\n\n#### 5.2 关系模式与关系\n* 同一关系模式下，可有很多的关系\n* 关系模式是关系的结构, 关系是关系模式在某一时刻的数据\n* 关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的\n\n#### 5.3 关系的特性\n* 列是同质：即每一列中的分量来自同一域，是同一类型的数据\n* 不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。\n* 列位置互换性：区分哪一列是靠列名\n* 行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)\n* 关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分\n* 理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。\n* 属性不可再分特性:又被称为关系第一范式\n\n#### 5.4 关系的一些重要概念\n1. 候选码(Candidate Key)/候选键\n  - 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉\n任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。\n2. 主码(Primary Key)/主键\n  - 当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组\n3. 主属性与非主属性\n  - 包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性\n  - 最简单的，候选码只包含一个属性；\n  - 极端的，所有属性构成这个关系的候选码，称为全码(All-Key)\n4. 外码(Foreign Key)/外键\n  - 关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。\n  - 两个关系通常是靠外码连接起来的。\n\n\n<span id=\"id6\"><span>\n### 6. 关系模型中的完整性\n#### 6.1 实体完整性\n* 关系的主码中的属性值不能为空值；\n* 意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。\n\n#### 6.2 参照完整性\n* 如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值\n* 意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在\n\n#### 6.3 用户自定义完整性\n* 用户针对具体的应用环境定义的完整性约束条件\n\n#### 6.4 DBMS对关系完整性的支持\n* 实体完整性和参照完整性由DBMS系统自动支持\n* DBMS系统通常提供了如下机制：\n  1. 它使用户可以自行定义有关的完整性约束条件\n  2. 当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性\n\n\n<span id=\"id7\"><span>\n### 7. 关系代数\n#### 7.1 关系代数的特点\n* 基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作\n* 以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。\n* 关系代数操作以一个或多个关系为输入，结果是一个新的关系。\n* 用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。\n* 是一种抽象的语言，是学习其他数据库语言，如SQL等的基础\n\n#### 7.2 关系代数的约束\n某些关系代数操作，如并、差、交等，需满足\"并相容性\"\n* 并相容性：\n  1. 参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性\n  2. 定义：关系R与关系S存在相容性，当且仅当：\n    - (1) 关系R和关系S的属性数目必须相同；\n    - (2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同\n  + 示例：关系R：STUDENT(SID **char(10)**, Sname **char(8)**, Age **char(3)**)\n  + 示例：关系S：TEACHER(TID **char(10)**, Tname **char(8)**, Age **char(3)**)\n\n\n#### 7.3 关系代数的基本操作\n1. 集合操作\n  * 并（UNIO）：R∪S\n  * 交（INTERSECTION）：R∩S\n  * 差（DIFFERENCE）：R-S\n  * 笛卡儿积（Cartesian PRODUCT）：R×S\n2. 纯关系操作\n  * 选择（SELECT）：σF(R)\n  * 投影（PROJECT）：ΠA(R)\n  * 连接（JOIN）：R⋈S\n  * 除（DIVISION）：R÷S\n\n##### 7.3.1 并(Union) 操作\n* 定义：设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：**`R∪S`**, 它由 或者出现在关系R中，或者出现在S中的元组构成。\n* 数学描述：`R∪S={t|t∈R∨t∈S}`，其中t是元组\n* 并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。\n* 汉语中的“或者…或者…”通常意义是并运算的要求。\n* `R∪S` 与 `S∪R` 运算的结果是**同**一个关系\n\n##### 7.3.2 差(Difference) 操作\n* 定义：设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：**`R-S`**, 它由出现在关系R中但不出现在关系S中的元组构成。\n* 数学描述：`R－S={t|t∈R∧t∉S}`，其中t是元组\n* 汉语中的“是…但不含…”通常意义是差运算的要求。\n* `R-S` 与 `S-R` 是**不同**的\n\n##### 7.3.3  交（Intersection Referential integrity） 操作\n* 定义：设关系R和关系S具有相同的目n，且相应的属性取自同一个域，则关系R与关系S的交由既属于R又属于S的元组组成。其结果关系仍为n目关系。\n* 数学描述：`R∩S={t|t∈R∧t∈S}`，其中t是元组\n\n##### 7.3.4 广义笛卡尔积(Extended cartesian product) 操作\n* 定义：关系`R(<a1,a2, …,an>)`与关系`S(<b1,b2, …,bm >)`的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：**`RxS`**；两个分别为n目和m目的关系R和S的广义笛卡尔积是一个(n+m)列的元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组，若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。\n* 数学描述：`RxS = {<a1,a2,…,an,b1,b2,…,bm>|<a1,a2,…,an>∈R ∧ <b1,b2,…,bm>∈S}`\n* `RxS=SxR`：RxS为R中的每一个元组都和S中的所有元组进行串接。`SxR`为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。\n* 两个关系R和S，它们的**属性个数**分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).\n* 两个关系R和S，它们的**元组个数**分别为x和y(关系R的基数x,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).\n\n##### 7.3.5 选择(Select)\n* 定义：给定一个关系R, 同时给定一个选择的条件condition(简记F), 选择运算结果也是一个关系，记作**`σF(R)`**, 它从关系R中选择出满足给定条件condition的元组构成。\n* 数学描述：`σF(R) = {t|t∈R ∧ F(t)='真'}`,其中F表示选择条件，它是一个逻辑表达式，取逻辑值‘真’或‘假’。\n* 选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ `括弧()；θ；¬；∧；∨` }\n\n##### 7.3.6 投影(Project)\n* 定义：给定一个关系R, 投影运算结果也是一个关系，记作**`A(R)`**, 它从关系R中选出属性包含在A中的列构成。\n* 数学描述：`ΠA(R) = {t[A] | t∈R}`,其中A为R中的属性列\n* 投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系\n\n\n#### 7.4 关系代数的扩展操作\n##### 7.4.1 交(Intersection)\n* **定义**：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：**`R∩S`**, 它由同时出现在关系R和关系S中的元组构成。\n* 数学描述：`R∩S = {t|t∈R ∧ t∈S}`，其中t是元组\n* R∩S 和 S∩R 运算的结果是同一个关系\n* 交运算可以通过差运算来实现：`R∩S = R-(R-S) = S-(S-R)`\n* 汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求\n\n##### 7.4.2 θ-连接(θ-Join, theta-Join)\n* 投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作\n* **定义**：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 **`R⋈S[AθB]`**：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。\n* 数学描述：`R⋈S[AθB] = σ t[A]θs[B] (R×S)`，σF(RxS)其中t是R中的元组，s是S中的元组\n* 在实际应用中，θ-连接操作经常与投影Π、选择σ操作一起使用\n* **特别注意**：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。\n\n##### 7.4.3 等值连接(Equi-Join)\n* **定义**：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作**`R⋈S[A=B]`**：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。\n* 数学描述：`R⋈S[A=B] = σ t[A]=s[B] (R×S)`\n* 当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；\n* 广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用**θ-连接/等值连接**运算可大幅度降低中间结果的保存量，提高速度。\n\n##### 7.4.4 自然连接(Natural-Join)\n* 定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。\n* 数学描述：`R⋈S = σ t[B]=s[B] (R×S)`\n* 自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列\n\n#### 7.5 关系代数的基本书写思路\n1. 选出将用到的关系/表\n2. 做\"积\"运算（可用连接运算替换）\n3. 做选择运算保留所需的行/元组\n4. 做投影运算保留所需的列/属性\n\n- 基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可\n- 如涉及多个表，则检查：\n  * 能否使用自然连接，将多个表连接起来(多数情况是这样的)\n  * 如不能，能否使用等值或不等值连接(θ-连接)\n  * 还不能，则使用广义笛卡尔积，注意相关条件的书写\n- 连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作\n\n\n#### 7.6 关系代数之复杂扩展操作\n##### 7.6.1 除(Division)\n* 除法运算经常用于求解“查询… 全部的/所有的…”问题\n* 前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m < n。\n* 定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。\n* 数学描述：\n``` math\nR÷S = {t|t∈Π[R-S](R) ∧ ∀u∈S(tu∈R) }\n    = Π[R-S](R) - Π[R-S]((Π[R-S](R)×S)-R)\n```\n> 其中[R-S]为投影Π的下标(属性)\n\n##### 7.6.2 外连接(Outer-Join)\n* 定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。\n* 外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)\n* 外连接的形式：左外连接、右外连接、全外连接\n  - 左外连接 = 自然连接(或连接) + 左侧表中失配的元组\n  - 右外连接 = 自然连接(或连接) + 右侧表中失配的元组\n  - 全外连接 = 自然连接(或连接) + 两侧表中失配的元组\n  - 左外连接(Left Outer Join)记为：⋊\n  - 右外连接(Right Outer Join)记为：⋉\n  - 全外连接(Full Outer Join)记为：⋊⋉\n\n\n<span id=\"id8\"><span>\n### 8. 关系演算\n关系演算是**描述关系运算**的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的\n* 按照谓词变量的不同，可分为关系元组演算和关系域演算\n  1. 关系元组演算是以**元组变量**作为谓词变量的基本对象\n  2. 关系域演算是以**域变量**作为谓词变量的基本对象\n\n#### 8.1 关系元组演算\n1. 关系元组演算公式：{ t | P(t) }\n  - 表示：所有使谓词 P 为真的元组 t 的集合\n  - t 是元组变量\n  - t ∈ r 表示元组 t 在关系 r 中\n  - t[A] 表示元组 t 的分量，即 t 在属性 A 上的值\n  - P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式\n2. 关系元组演算公式的基本形式：{ t | P(t) }\n3. P(t)可以是如下三种形式之一的原子公式：\n  + t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}\n  + s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符<,<=,=,<>,>,>=\n  + s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，\n4. P(t)可以由公式加运算符 ∧(与)、∨(或)、¬(非)递归地构造\n  + 如果F是一个公式，则 ¬F 也是公式\n  + 如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式\n5. P(t)运算符优先次序(括弧；θ；∃；∀；¬；∧；∨)示例\n6. 构造P(t)还有两个运算符：∃(存在)、∀(任意)\n  + 如果F是一个公式，则 ∃(t∈r)(F(t)) 也是公式\n  + 如果F是一个公式，则 ∀(t∈r)(F(t)) 也是公式\n  + 运算符∃和∀，又称为量词，前者称“**存在量词**”，后者称“**全称量词**”\n  + 而被∃或∀限定的元组变量 t , 或者说，元组变量 t 前有存在量词或全称量词，则该变量被称为“**约束变量**”，否则被称为“**自由变量**”。\n7. 元组演算的等价性变换\n    + 符号`<=>`表示表示等价于,如：`¬(A>B) <=> A<=B  <=> A<B∨A=B`\n\n\n#### 8.2 关系域演算\n1. 关系域演算公式的基本形式：`{<x1,x2, …,xn> | P(x1,x2, …,xn)}`,其中 xi 代表域变量或常量, P为以xi为变量的公式。\n2. 元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后再找到元组分量，进行谓词判断；\n3. 域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变量组成的元组是否存在或是否满足谓词判断。\n4. 公式的运算符(∧(与)、∨(或)、¬(非)、∀(全称量词)和∃(存在量词))是相同的，只是其中的变量不同。\n5. 元组演算和域演算可以等价互换。\n\n##### 8.2.1 基于关系域演算的QBE语言\nQBE: Query By Example，1975年由M. M. Zloof提出，1978年在IBM370上实现，是一种高度非过程化的查询语言，特别适合于终端用户的使用。\n1. 特点：操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只需将条件填在表格中即可\n2. QBE操作框架由四个部分构成\n    + 关系名区：用于书写欲待查询的关系名\n    + 属性名区：用于显示对应关系名区关系的所有属性名\n    + 操作命令区：用于书写查询操作的命令\n    + 查询条件区：用于书写查询条件\n3. QBE的操作命令\n    + Print 或 P.   ---- 显示输出操作\n    + Delete或D.   ---- 删除操作\n    + Insert或I.     ---- 插入操作\n    + Update或U. ---- 更新操作\n4. 构造查询的几个要素 \n    + 示例元素: 即域变量， 一定要加下划线 \n    + 示例元素是这个域中可能的一个值， 它不必是查询结果中的元素\n    + 打印操作符P.: 指定查询结果所含属性列 \n    + 查询条件: 不用加下划线\n    + 可使用比较运算符＞， ≥，＜， ≤，＝和≠  其中＝可以省略\n    + 排序要求 \n        - 升序排序(AO.)，降序排序（DO.）,多列排序，用‚AO(i).‛ 或‚DO(i).‛ 表示 ，其中i为排序的优先级， i值越小，优先级越高\n\n#### 8.3 安全性\n关系运算的安全性：不产生无限关系和无穷验证的运算被称为是安全的\n1. 关系代数是一种集合运算，是安全的\n    + 集合本身是有限的，有限元素集合的有限次运算仍旧是有限的。\n2. 关系演算不一定是安全的\n    + 如：{t|¬(R(t))}, {t R(t)∨t[2]>3}可能表示无限关系\n3. 需要对关系演算施加约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。\n\n##### 8.3.1 安全约束有限集合DOM\n1. DOM(ψ)是一个有限集合，其中的每个符号要么是ψ中明显出现的符号，要么是出现在ψ中的某个关系R的某元组的分量。\n2. DOM主要用于约束ψ中一些谓词的计算范围，它不必是最小集合。\n3. 安全元组演算表达式，满足三个条件：\n    + 只要t满足ψ，t的每个分量就是DOM(ψ)的一个成员。\n        - { t|ψ(t) }中t的取值只能是DOM中的值，有限的。\n    + 对于ψ中形如(∃u)(ω(u))的子表达式，若u满足ω,则u的每个分量都是DOM(ω)中的成员。\n        - { t|ψ(t) }中的每个(∃u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为真的元素。而对于DOM以外的元素，已经明确其都不满足ω(u)，无需验证。\n    + 对于ψ中形如(∀u)(ω(u))的子表达式，若u不满足ω,则u的每个分量都是DOM(ω)中的成员。\n        - { t|ψ(t) }中的每个(∀u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为假的元素。而对于DOM以外的元素，已经明确其都满足ω(u)，无需验证。\n\n\n#### 8.4 关于三种关系运算的一些观点\n1. 关系运算有三种：关系代数、关系元组演算和关系域演算\n2. 三种关系运算都是抽象的数学运算，体现了三种不同的思维\n    + 关系代数---以集合为对象的操作思维，由集合到集合的变换\n    + 元组演算---以元组为对象的操作思维，取出关系的每一个元组进行验证，有一个元组变量则可能需要一个循环，多个元组变量则需要多个循环\n    + 域演算---以域变量为对象的操作思维，取出域的每一个变量进行验证看其是否满足条件\n3. 三种运算之间是等价的\n    + 关系代数 与 安全的元组演算表达式 与 安全的域演算表达式 是等\n价的。即一种形式的表达式可以被等价地转换为另一种形式\n4. 三种关系运算都可说是非过程性的\n    + 相比之下：域演算的非过程性最好，元组演算次之，关系代数最差\n5. 三种关系运算虽是抽象的，但却是衡量数据库语言完备性的基础\n    + 一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的\n    + 目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他的操作，如赋值操作、聚集操作等\n6. 数据库语言可以基于这三种抽象运算来设计\n    + 用“键盘符号”来替换抽象的数学符号\n    + 用易于理解的符号组合来表达抽象的数学符号\n    + 例如：ISBL语言---基于关系代数的数据库语言\n    + 再例如：Ingres系统的QUEL语言\n\n\n","slug":"【数据库】数据库系统基础","published":1,"updated":"2021-12-12T02:50:23.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6wj0020vcue7f9sgck9","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>数据库 是 电子化信息的集合</li>\n</ol>\n<ul>\n<li>将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li>\n</ul>\n<ol start=\"2\">\n<li>表(Table)：以按行按列形式组织及展现的数据<span id=\"more\"></span></li>\n</ol>\n<ul>\n<li>数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据–&gt;关系</li>\n</ul>\n<ol start=\"3\">\n<li>数据库系统的构成（概念层次）:</li>\n<li>数据库(DB):Database：相互之间有关联关系的数据的集合</li>\n<li>数据库管理系统(DBMS):Database Management System</li>\n<li>数据库应用(DBAP):Database Application</li>\n<li>数据库管理员(DBA):Database Asministrator</li>\n<li>计算机基本系统</li>\n</ol>\n<h4 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h4><ol>\n<li><a href=\"#id1\">数据库管理系统(DBMS)</a></li>\n<li><a href=\"#id2\">数据库系统的标准结构</a></li>\n<li><a href=\"#id3\">三级模式两层映像</a></li>\n<li><a href=\"#id4\">数据模型</a></li>\n<li><a href=\"#id5\">关系模型</a></li>\n<li><a href=\"#id6\">关系模型中的完整性</a></li>\n<li><a href=\"#id7\">关系代数</a></li>\n<li><a href=\"#id8\">关系演算</a></li>\n</ol>\n<p><span id=\"id1\"><span></p>\n<h3 id=\"1-数据库管理系统-DBMS\"><a href=\"#1-数据库管理系统-DBMS\" class=\"headerlink\" title=\"1. 数据库管理系统(DBMS)\"></a>1. 数据库管理系统(DBMS)</h3><h4 id=\"1-1-从用户角度看DBMS-数据库管理系统\"><a href=\"#1-1-从用户角度看DBMS-数据库管理系统\" class=\"headerlink\" title=\"1.1 从用户角度看DBMS(数据库管理系统)\"></a>1.1 从用户角度看DBMS(数据库管理系统)</h4><ol>\n<li>数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等</li>\n</ol>\n<ul>\n<li>DBMS提供了一套<strong>数据定义语言(DDL</strong>: Data Definition Language)给用户</li>\n<li>用户使用DDL描述其所要建立的表的格式</li>\n<li>DBMS依照用户的定义，创建数据库及其中的表</li>\n</ul>\n<ol start=\"2\">\n<li>数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等</li>\n</ol>\n<ul>\n<li>DBMS提供了一套<strong>数据库操纵语言(DML</strong>: Data Manipulation Language)给用户</li>\n<li>用户使用DML描述其所要进行的增、删、改、查等操作</li>\n<li>DBMS依照用户的操作描述，实际执行这些操作</li>\n</ul>\n<ol start=\"3\">\n<li>数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)</li>\n</ol>\n<ul>\n<li>DBMS提供了一套<strong>数据控制语言(DCL</strong>: Data Control Language)给用户</li>\n<li>用户使用DCL描述其对数据库所要实施的控制</li>\n<li>DBMS依照用户描述，实际ijnx控制</li>\n</ul>\n<ol start=\"4\">\n<li>数据库维护：转储/恢复/重组/性能监测/分析…</li>\n</ol>\n<ul>\n<li>DBMS提供了一系列程序(实用程序/例行程序)给用户</li>\n<li>在这些程序中提供了对数据库维护的各种功能</li>\n<li>用户使用这些程序进行各种数据库维护操作</li>\n<li>(数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)</li>\n</ul>\n<h4 id=\"1-2-数据库语言\"><a href=\"#1-2-数据库语言\" class=\"headerlink\" title=\"1.2 数据库语言\"></a>1.2 数据库语言</h4><ul>\n<li>使用者使用数据库语言，利用DBMS操纵数据库</li>\n<li>SQL语言：结构化的数据库语言</li>\n<li>高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用</li>\n</ul>\n<h4 id=\"1-3-从系统实现角度看DBMS的功能\"><a href=\"#1-3-从系统实现角度看DBMS的功能\" class=\"headerlink\" title=\"1.3 从系统实现角度看DBMS的功能\"></a>1.3 从系统实现角度看DBMS的功能</h4><ol>\n<li>数据库管理系统的实现：形式 –&gt; 构造 –&gt; 自动化</li>\n<li>DBMS为完成DB管理，在后台运行着一系列程序…</li>\n</ol>\n<ul>\n<li><strong>语言编译器</strong>：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等</li>\n<li><strong>查询优化</strong>(执行引擎)与<strong>查询实现</strong>(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序</li>\n<li><strong>数据存取与索引</strong>：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等</li>\n<li><strong>通信控制</strong>：提供网络环境下数据库操作与数据传输的手段</li>\n<li><strong>事务管理</strong>：提供提高可靠性并避免并发操作错误的手段</li>\n<li><strong>故障恢复</strong>：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序</li>\n<li><strong>安全性控制</strong>：提供合法性检验，避免非授权非法用户访问数据库的手段</li>\n<li><strong>完整性控制</strong>：提供数据及数据操作正确性检查的手段</li>\n<li><strong>数据字典管理</strong>：管理用户已经定义的信息</li>\n<li>**应用程序接口(API)**：提供应用程序使用DBMS特定功能的二首段</li>\n<li><strong>数据库数据装载、重组等实用程序</strong></li>\n<li><strong>数据库性能分析</strong>：统计在运行过程中数据库的各种性能数据，便于优化运行</li>\n</ul>\n<blockquote>\n<p>典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL </p>\n</blockquote>\n<p><span id=\"id2\"><span></p>\n<h3 id=\"2-数据库系统的标准结构\"><a href=\"#2-数据库系统的标准结构\" class=\"headerlink\" title=\"2. 数据库系统的标准结构\"></a>2. 数据库系统的标准结构</h3><p>DBMS管理数据的三个层次：</p>\n<ol>\n<li>External Level = User Level（外部级别 = 用户级别）</li>\n</ol>\n<ul>\n<li>某一用户能够看到与处理的数据,   全局数据中的某一部分</li>\n</ul>\n<ol start=\"2\">\n<li>Conceptual Level = Logic level（概念级别 = 逻辑级别）</li>\n</ol>\n<ul>\n<li>从全局角度理解/管理的数据, 含相应的关联约束</li>\n</ul>\n<ol start=\"3\">\n<li>Internal Level = Physical level（内部级别 = 物理级别）</li>\n</ol>\n<ul>\n<li>存储在介质上的数据，含存储路径、存储方式 、索引方式等</li>\n</ul>\n<p><span id=\"id3\"><span></p>\n<h3 id=\"3-三级模式两层映像\"><a href=\"#3-三级模式两层映像\" class=\"headerlink\" title=\"3. 三级模式两层映像\"></a>3. 三级模式两层映像</h3><p>数据库的三级模式结构是指：数据库系统是由外模式、模式(概念模式)和内模式三级构成</p>\n<ul>\n<li>应用–&gt; 外模式(多个) –&gt; 模式(一个) –&gt; 内模式(一个) –&gt; 数据库</li>\n</ul>\n<h4 id=\"3-1-数据-视图-与模式-数据的结构\"><a href=\"#3-1-数据-视图-与模式-数据的结构\" class=\"headerlink\" title=\"3.1 数据(视图)与模式(数据的结构)\"></a>3.1 数据(视图)与模式(数据的结构)</h4><ul>\n<li>模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息</li>\n<li>视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据</li>\n</ul>\n<h4 id=\"3-2-三级模式-三级视图\"><a href=\"#3-2-三级模式-三级视图\" class=\"headerlink\" title=\"3.2 三级模式(三级视图)\"></a>3.2 三级模式(三级视图)</h4><ol>\n<li>External Schema —-(External) View</li>\n</ol>\n<ul>\n<li>外模式：某一用户能够看到与处理的数据的结构描述</li>\n</ul>\n<ol start=\"2\">\n<li>(Conceptual) Schema —- Conceptual View</li>\n</ol>\n<ul>\n<li>模式(概念模式)：从全局角度理解/管理的数据的结构描述, 含相应的关联约束</li>\n<li>体现在数据之间的内在本质联系</li>\n</ul>\n<ol start=\"3\">\n<li>Internal Schema —- Internal  View</li>\n</ol>\n<ul>\n<li>内模式：存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等</li>\n</ul>\n<h4 id=\"3-3-两层映像\"><a href=\"#3-3-两层映像\" class=\"headerlink\" title=\"3.3 两层映像\"></a>3.3 两层映像</h4><ol>\n<li>E-C Mapping：External Schema-Conceptual Schema Mapping </li>\n</ol>\n<ul>\n<li>将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换</li>\n<li>便于用户观察和使用</li>\n</ul>\n<ol start=\"2\">\n<li>C-I Mapping：Conceptual Schema-Internal Schema Mapping </li>\n</ol>\n<ul>\n<li>将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换</li>\n<li>便于计算机进行存储和处理</li>\n</ul>\n<h4 id=\"3-4-标准结构的两个独立性\"><a href=\"#3-4-标准结构的两个独立性\" class=\"headerlink\" title=\"3.4 标准结构的两个独立性\"></a>3.4 标准结构的两个独立性</h4><ol>\n<li>逻辑数据独立性</li>\n</ol>\n<ul>\n<li>当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序</li>\n</ul>\n<ol start=\"2\">\n<li>物理数据独立性</li>\n</ol>\n<ul>\n<li>当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式</li>\n</ul>\n<p><span id=\"id4\"><span></p>\n<h3 id=\"4-数据模型\"><a href=\"#4-数据模型\" class=\"headerlink\" title=\"4. 数据模型\"></a>4. 数据模型</h3><ol>\n<li>数据模型：模式 与 模式的结构</li>\n</ol>\n<ul>\n<li>规定模式统一描述方式的模型，包括：数据结构、操作和约束</li>\n<li>数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象</li>\n<li>比如：关系模型：所有模式都可为抽象表(Table)的形式[<strong>数据结构</strong>]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[<strong>操作</strong>]和[<strong>约束</strong>]</li>\n</ul>\n<ol start=\"2\">\n<li>三大经典数据模型</li>\n</ol>\n<ul>\n<li>关系模型：<strong>表</strong>的形式组织数据</li>\n<li>层次模型：<strong>树</strong>的形式组织数据</li>\n<li>网状模型：<strong>图</strong>的形式组织数据</li>\n</ul>\n<p><span id=\"id5\"><span></p>\n<h3 id=\"5-关系模型\"><a href=\"#5-关系模型\" class=\"headerlink\" title=\"5. 关系模型\"></a>5. 关系模型</h3><ol>\n<li>形象地说，<strong>一个关系(relation)就是一个Table</strong>，关系模型就是处理Table的，它由三个部分组成：</li>\n</ol>\n<ul>\n<li>描述DB各种数据的基本结构形式(Table/Relation)</li>\n<li>描述Table与Table之间所可能发生的各种操作(关系运算)</li>\n<li>描述这些操作所应遵循的约束条件(完整性约束)</li>\n</ul>\n<ol start=\"2\">\n<li>关系模型的三个要素：</li>\n</ol>\n<ul>\n<li>基本结构：Relation/Table</li>\n<li>基本操作：Relation Operator<ul>\n<li>基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。</li>\n<li>扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算</li>\n</ul>\n</li>\n<li>完整性约束：实体完整性、参照完整性和用户自定义的完整性</li>\n</ul>\n<ol start=\"3\">\n<li>表(Table)的基本构成要素</li>\n</ol>\n<ul>\n<li>列/字段/属性/数据项：列名，列值</li>\n<li>行/元组/记录</li>\n<li>标题/模式</li>\n</ul>\n<h4 id=\"5-1-“表”的严格定义\"><a href=\"#5-1-“表”的严格定义\" class=\"headerlink\" title=\"5.1 “表”的严格定义\"></a>5.1 “表”的严格定义</h4><ul>\n<li>域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型</li>\n<li>笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组</li>\n<li>关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)</li>\n</ul>\n<h4 id=\"5-2-关系模式与关系\"><a href=\"#5-2-关系模式与关系\" class=\"headerlink\" title=\"5.2 关系模式与关系\"></a>5.2 关系模式与关系</h4><ul>\n<li>同一关系模式下，可有很多的关系</li>\n<li>关系模式是关系的结构, 关系是关系模式在某一时刻的数据</li>\n<li>关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的</li>\n</ul>\n<h4 id=\"5-3-关系的特性\"><a href=\"#5-3-关系的特性\" class=\"headerlink\" title=\"5.3 关系的特性\"></a>5.3 关系的特性</h4><ul>\n<li>列是同质：即每一列中的分量来自同一域，是同一类型的数据</li>\n<li>不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</li>\n<li>列位置互换性：区分哪一列是靠列名</li>\n<li>行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)</li>\n<li>关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分</li>\n<li>理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。</li>\n<li>属性不可再分特性:又被称为关系第一范式</li>\n</ul>\n<h4 id=\"5-4-关系的一些重要概念\"><a href=\"#5-4-关系的一些重要概念\" class=\"headerlink\" title=\"5.4 关系的一些重要概念\"></a>5.4 关系的一些重要概念</h4><ol>\n<li>候选码(Candidate Key)/候选键</li>\n</ol>\n<ul>\n<li>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉<br>任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。</li>\n</ul>\n<ol start=\"2\">\n<li>主码(Primary Key)/主键</li>\n</ol>\n<ul>\n<li>当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组</li>\n</ul>\n<ol start=\"3\">\n<li>主属性与非主属性</li>\n</ol>\n<ul>\n<li>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性</li>\n<li>最简单的，候选码只包含一个属性；</li>\n<li>极端的，所有属性构成这个关系的候选码，称为全码(All-Key)</li>\n</ul>\n<ol start=\"4\">\n<li>外码(Foreign Key)/外键</li>\n</ol>\n<ul>\n<li>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</li>\n<li>两个关系通常是靠外码连接起来的。</li>\n</ul>\n<p><span id=\"id6\"><span></p>\n<h3 id=\"6-关系模型中的完整性\"><a href=\"#6-关系模型中的完整性\" class=\"headerlink\" title=\"6. 关系模型中的完整性\"></a>6. 关系模型中的完整性</h3><h4 id=\"6-1-实体完整性\"><a href=\"#6-1-实体完整性\" class=\"headerlink\" title=\"6.1 实体完整性\"></a>6.1 实体完整性</h4><ul>\n<li>关系的主码中的属性值不能为空值；</li>\n<li>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。</li>\n</ul>\n<h4 id=\"6-2-参照完整性\"><a href=\"#6-2-参照完整性\" class=\"headerlink\" title=\"6.2 参照完整性\"></a>6.2 参照完整性</h4><ul>\n<li>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值</li>\n<li>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在</li>\n</ul>\n<h4 id=\"6-3-用户自定义完整性\"><a href=\"#6-3-用户自定义完整性\" class=\"headerlink\" title=\"6.3 用户自定义完整性\"></a>6.3 用户自定义完整性</h4><ul>\n<li>用户针对具体的应用环境定义的完整性约束条件</li>\n</ul>\n<h4 id=\"6-4-DBMS对关系完整性的支持\"><a href=\"#6-4-DBMS对关系完整性的支持\" class=\"headerlink\" title=\"6.4 DBMS对关系完整性的支持\"></a>6.4 DBMS对关系完整性的支持</h4><ul>\n<li>实体完整性和参照完整性由DBMS系统自动支持</li>\n<li>DBMS系统通常提供了如下机制：<ol>\n<li>它使用户可以自行定义有关的完整性约束条件</li>\n<li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id7\"><span></p>\n<h3 id=\"7-关系代数\"><a href=\"#7-关系代数\" class=\"headerlink\" title=\"7. 关系代数\"></a>7. 关系代数</h3><h4 id=\"7-1-关系代数的特点\"><a href=\"#7-1-关系代数的特点\" class=\"headerlink\" title=\"7.1 关系代数的特点\"></a>7.1 关系代数的特点</h4><ul>\n<li>基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作</li>\n<li>以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。</li>\n<li>关系代数操作以一个或多个关系为输入，结果是一个新的关系。</li>\n<li>用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。</li>\n<li>是一种抽象的语言，是学习其他数据库语言，如SQL等的基础</li>\n</ul>\n<h4 id=\"7-2-关系代数的约束\"><a href=\"#7-2-关系代数的约束\" class=\"headerlink\" title=\"7.2 关系代数的约束\"></a>7.2 关系代数的约束</h4><p>某些关系代数操作，如并、差、交等，需满足”并相容性”</p>\n<ul>\n<li>并相容性：<ol>\n<li>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性</li>\n<li>定义：关系R与关系S存在相容性，当且仅当：</li>\n</ol>\n<ul>\n<li>(1) 关系R和关系S的属性数目必须相同；</li>\n<li>(2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同</li>\n</ul>\n<ul>\n<li>示例：关系R：STUDENT(SID <strong>char(10)</strong>, Sname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li>\n<li>示例：关系S：TEACHER(TID <strong>char(10)</strong>, Tname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-3-关系代数的基本操作\"><a href=\"#7-3-关系代数的基本操作\" class=\"headerlink\" title=\"7.3 关系代数的基本操作\"></a>7.3 关系代数的基本操作</h4><ol>\n<li>集合操作</li>\n</ol>\n<ul>\n<li>并（UNIO）：R∪S</li>\n<li>交（INTERSECTION）：R∩S</li>\n<li>差（DIFFERENCE）：R-S</li>\n<li>笛卡儿积（Cartesian PRODUCT）：R×S</li>\n</ul>\n<ol start=\"2\">\n<li>纯关系操作</li>\n</ol>\n<ul>\n<li>选择（SELECT）：σF(R)</li>\n<li>投影（PROJECT）：ΠA(R)</li>\n<li>连接（JOIN）：R⋈S</li>\n<li>除（DIVISION）：R÷S</li>\n</ul>\n<h5 id=\"7-3-1-并-Union-操作\"><a href=\"#7-3-1-并-Union-操作\" class=\"headerlink\" title=\"7.3.1 并(Union) 操作\"></a>7.3.1 并(Union) 操作</h5><ul>\n<li>定义：设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：**<code>R∪S</code>**, 它由 或者出现在关系R中，或者出现在S中的元组构成。</li>\n<li>数学描述：<code>R∪S=&#123;t|t∈R∨t∈S&#125;</code>，其中t是元组</li>\n<li>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</li>\n<li>汉语中的“或者…或者…”通常意义是并运算的要求。</li>\n<li><code>R∪S</code> 与 <code>S∪R</code> 运算的结果是<strong>同</strong>一个关系</li>\n</ul>\n<h5 id=\"7-3-2-差-Difference-操作\"><a href=\"#7-3-2-差-Difference-操作\" class=\"headerlink\" title=\"7.3.2 差(Difference) 操作\"></a>7.3.2 差(Difference) 操作</h5><ul>\n<li>定义：设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：**<code>R-S</code>**, 它由出现在关系R中但不出现在关系S中的元组构成。</li>\n<li>数学描述：<code>R－S=&#123;t|t∈R∧t∉S&#125;</code>，其中t是元组</li>\n<li>汉语中的“是…但不含…”通常意义是差运算的要求。</li>\n<li><code>R-S</code> 与 <code>S-R</code> 是<strong>不同</strong>的</li>\n</ul>\n<h5 id=\"7-3-3-交（Intersection-Referential-integrity）-操作\"><a href=\"#7-3-3-交（Intersection-Referential-integrity）-操作\" class=\"headerlink\" title=\"7.3.3  交（Intersection Referential integrity） 操作\"></a>7.3.3  交（Intersection Referential integrity） 操作</h5><ul>\n<li>定义：设关系R和关系S具有相同的目n，且相应的属性取自同一个域，则关系R与关系S的交由既属于R又属于S的元组组成。其结果关系仍为n目关系。</li>\n<li>数学描述：<code>R∩S=&#123;t|t∈R∧t∈S&#125;</code>，其中t是元组</li>\n</ul>\n<h5 id=\"7-3-4-广义笛卡尔积-Extended-cartesian-product-操作\"><a href=\"#7-3-4-广义笛卡尔积-Extended-cartesian-product-操作\" class=\"headerlink\" title=\"7.3.4 广义笛卡尔积(Extended cartesian product) 操作\"></a>7.3.4 广义笛卡尔积(Extended cartesian product) 操作</h5><ul>\n<li>定义：关系<code>R(&lt;a1,a2, …,an&gt;)</code>与关系<code>S(&lt;b1,b2, …,bm &gt;)</code>的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：**<code>RxS</code>**；两个分别为n目和m目的关系R和S的广义笛卡尔积是一个(n+m)列的元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组，若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。</li>\n<li>数学描述：<code>RxS = &#123;&lt;a1,a2,…,an,b1,b2,…,bm&gt;|&lt;a1,a2,…,an&gt;∈R ∧ &lt;b1,b2,…,bm&gt;∈S&#125;</code></li>\n<li><code>RxS=SxR</code>：RxS为R中的每一个元组都和S中的所有元组进行串接。<code>SxR</code>为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。</li>\n<li>两个关系R和S，它们的<strong>属性个数</strong>分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).</li>\n<li>两个关系R和S，它们的<strong>元组个数</strong>分别为x和y(关系R的基数x,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).</li>\n</ul>\n<h5 id=\"7-3-5-选择-Select\"><a href=\"#7-3-5-选择-Select\" class=\"headerlink\" title=\"7.3.5 选择(Select)\"></a>7.3.5 选择(Select)</h5><ul>\n<li>定义：给定一个关系R, 同时给定一个选择的条件condition(简记F), 选择运算结果也是一个关系，记作**<code>σF(R)</code>**, 它从关系R中选择出满足给定条件condition的元组构成。</li>\n<li>数学描述：<code>σF(R) = &#123;t|t∈R ∧ F(t)=&#39;真&#39;&#125;</code>,其中F表示选择条件，它是一个逻辑表达式，取逻辑值‘真’或‘假’。</li>\n<li>选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ <code>括弧()；θ；¬；∧；∨</code> }</li>\n</ul>\n<h5 id=\"7-3-6-投影-Project\"><a href=\"#7-3-6-投影-Project\" class=\"headerlink\" title=\"7.3.6 投影(Project)\"></a>7.3.6 投影(Project)</h5><ul>\n<li>定义：给定一个关系R, 投影运算结果也是一个关系，记作**<code>A(R)</code>**, 它从关系R中选出属性包含在A中的列构成。</li>\n<li>数学描述：<code>ΠA(R) = &#123;t[A] | t∈R&#125;</code>,其中A为R中的属性列</li>\n<li>投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系</li>\n</ul>\n<h4 id=\"7-4-关系代数的扩展操作\"><a href=\"#7-4-关系代数的扩展操作\" class=\"headerlink\" title=\"7.4 关系代数的扩展操作\"></a>7.4 关系代数的扩展操作</h4><h5 id=\"7-4-1-交-Intersection\"><a href=\"#7-4-1-交-Intersection\" class=\"headerlink\" title=\"7.4.1 交(Intersection)\"></a>7.4.1 交(Intersection)</h5><ul>\n<li><strong>定义</strong>：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：**<code>R∩S</code>**, 它由同时出现在关系R和关系S中的元组构成。</li>\n<li>数学描述：<code>R∩S = &#123;t|t∈R ∧ t∈S&#125;</code>，其中t是元组</li>\n<li>R∩S 和 S∩R 运算的结果是同一个关系</li>\n<li>交运算可以通过差运算来实现：<code>R∩S = R-(R-S) = S-(S-R)</code></li>\n<li>汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求</li>\n</ul>\n<h5 id=\"7-4-2-θ-连接-θ-Join-theta-Join\"><a href=\"#7-4-2-θ-连接-θ-Join-theta-Join\" class=\"headerlink\" title=\"7.4.2 θ-连接(θ-Join, theta-Join)\"></a>7.4.2 θ-连接(θ-Join, theta-Join)</h5><ul>\n<li>投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作</li>\n<li><strong>定义</strong>：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 **<code>R⋈S[AθB]</code>**：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。</li>\n<li>数学描述：<code>R⋈S[AθB] = σ t[A]θs[B] (R×S)</code>，σF(RxS)其中t是R中的元组，s是S中的元组</li>\n<li>在实际应用中，θ-连接操作经常与投影Π、选择σ操作一起使用</li>\n<li><strong>特别注意</strong>：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。</li>\n</ul>\n<h5 id=\"7-4-3-等值连接-Equi-Join\"><a href=\"#7-4-3-等值连接-Equi-Join\" class=\"headerlink\" title=\"7.4.3 等值连接(Equi-Join)\"></a>7.4.3 等值连接(Equi-Join)</h5><ul>\n<li><strong>定义</strong>：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作**<code>R⋈S[A=B]</code>**：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。</li>\n<li>数学描述：<code>R⋈S[A=B] = σ t[A]=s[B] (R×S)</code></li>\n<li>当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；</li>\n<li>广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用<strong>θ-连接/等值连接</strong>运算可大幅度降低中间结果的保存量，提高速度。</li>\n</ul>\n<h5 id=\"7-4-4-自然连接-Natural-Join\"><a href=\"#7-4-4-自然连接-Natural-Join\" class=\"headerlink\" title=\"7.4.4 自然连接(Natural-Join)\"></a>7.4.4 自然连接(Natural-Join)</h5><ul>\n<li>定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。</li>\n<li>数学描述：<code>R⋈S = σ t[B]=s[B] (R×S)</code></li>\n<li>自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列</li>\n</ul>\n<h4 id=\"7-5-关系代数的基本书写思路\"><a href=\"#7-5-关系代数的基本书写思路\" class=\"headerlink\" title=\"7.5 关系代数的基本书写思路\"></a>7.5 关系代数的基本书写思路</h4><ol>\n<li>选出将用到的关系/表</li>\n<li>做”积”运算（可用连接运算替换）</li>\n<li>做选择运算保留所需的行/元组</li>\n<li>做投影运算保留所需的列/属性</li>\n</ol>\n<ul>\n<li>基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可</li>\n<li>如涉及多个表，则检查：<ul>\n<li>能否使用自然连接，将多个表连接起来(多数情况是这样的)</li>\n<li>如不能，能否使用等值或不等值连接(θ-连接)</li>\n<li>还不能，则使用广义笛卡尔积，注意相关条件的书写</li>\n</ul>\n</li>\n<li>连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作</li>\n</ul>\n<h4 id=\"7-6-关系代数之复杂扩展操作\"><a href=\"#7-6-关系代数之复杂扩展操作\" class=\"headerlink\" title=\"7.6 关系代数之复杂扩展操作\"></a>7.6 关系代数之复杂扩展操作</h4><h5 id=\"7-6-1-除-Division\"><a href=\"#7-6-1-除-Division\" class=\"headerlink\" title=\"7.6.1 除(Division)\"></a>7.6.1 除(Division)</h5><ul>\n<li>除法运算经常用于求解“查询… 全部的/所有的…”问题</li>\n<li>前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m &lt; n。</li>\n<li>定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。</li>\n<li>数学描述：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R÷S = &#123;t|t∈Π[R-S](R) ∧ ∀u∈S(tu∈R) &#125;</span><br><span class=\"line\">    = Π[R-S](R) - Π[R-S]((Π[R-S](R)×S)-R)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>其中[R-S]为投影Π的下标(属性)</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"7-6-2-外连接-Outer-Join\"><a href=\"#7-6-2-外连接-Outer-Join\" class=\"headerlink\" title=\"7.6.2 外连接(Outer-Join)\"></a>7.6.2 外连接(Outer-Join)</h5><ul>\n<li>定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。</li>\n<li>外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)</li>\n<li>外连接的形式：左外连接、右外连接、全外连接<ul>\n<li>左外连接 = 自然连接(或连接) + 左侧表中失配的元组</li>\n<li>右外连接 = 自然连接(或连接) + 右侧表中失配的元组</li>\n<li>全外连接 = 自然连接(或连接) + 两侧表中失配的元组</li>\n<li>左外连接(Left Outer Join)记为：⋊</li>\n<li>右外连接(Right Outer Join)记为：⋉</li>\n<li>全外连接(Full Outer Join)记为：⋊⋉</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id8\"><span></p>\n<h3 id=\"8-关系演算\"><a href=\"#8-关系演算\" class=\"headerlink\" title=\"8. 关系演算\"></a>8. 关系演算</h3><p>关系演算是<strong>描述关系运算</strong>的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的</p>\n<ul>\n<li>按照谓词变量的不同，可分为关系元组演算和关系域演算<ol>\n<li>关系元组演算是以<strong>元组变量</strong>作为谓词变量的基本对象</li>\n<li>关系域演算是以<strong>域变量</strong>作为谓词变量的基本对象</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"8-1-关系元组演算\"><a href=\"#8-1-关系元组演算\" class=\"headerlink\" title=\"8.1 关系元组演算\"></a>8.1 关系元组演算</h4><ol>\n<li>关系元组演算公式：{ t | P(t) }</li>\n</ol>\n<ul>\n<li>表示：所有使谓词 P 为真的元组 t 的集合</li>\n<li>t 是元组变量</li>\n<li>t ∈ r 表示元组 t 在关系 r 中</li>\n<li>t[A] 表示元组 t 的分量，即 t 在属性 A 上的值</li>\n<li>P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式</li>\n</ul>\n<ol start=\"2\">\n<li>关系元组演算公式的基本形式：{ t | P(t) }</li>\n<li>P(t)可以是如下三种形式之一的原子公式：</li>\n</ol>\n<ul>\n<li>t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}</li>\n<li>s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符&lt;,&lt;=,=,&lt;&gt;,&gt;,&gt;=</li>\n<li>s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，</li>\n</ul>\n<ol start=\"4\">\n<li>P(t)可以由公式加运算符 ∧(与)、∨(或)、¬(非)递归地构造</li>\n</ol>\n<ul>\n<li>如果F是一个公式，则 ¬F 也是公式</li>\n<li>如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式</li>\n</ul>\n<ol start=\"5\">\n<li>P(t)运算符优先次序(括弧；θ；∃；∀；¬；∧；∨)示例</li>\n<li>构造P(t)还有两个运算符：∃(存在)、∀(任意)</li>\n</ol>\n<ul>\n<li>如果F是一个公式，则 ∃(t∈r)(F(t)) 也是公式</li>\n<li>如果F是一个公式，则 ∀(t∈r)(F(t)) 也是公式</li>\n<li>运算符∃和∀，又称为量词，前者称“<strong>存在量词</strong>”，后者称“<strong>全称量词</strong>”</li>\n<li>而被∃或∀限定的元组变量 t , 或者说，元组变量 t 前有存在量词或全称量词，则该变量被称为“<strong>约束变量</strong>”，否则被称为“<strong>自由变量</strong>”。</li>\n</ul>\n<ol start=\"7\">\n<li>元组演算的等价性变换<ul>\n<li>符号<code>&lt;=&gt;</code>表示表示等价于,如：<code>¬(A&gt;B) &lt;=&gt; A&lt;=B  &lt;=&gt; A&lt;B∨A=B</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-2-关系域演算\"><a href=\"#8-2-关系域演算\" class=\"headerlink\" title=\"8.2 关系域演算\"></a>8.2 关系域演算</h4><ol>\n<li>关系域演算公式的基本形式：<code>&#123;&lt;x1,x2, …,xn&gt; | P(x1,x2, …,xn)&#125;</code>,其中 xi 代表域变量或常量, P为以xi为变量的公式。</li>\n<li>元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后再找到元组分量，进行谓词判断；</li>\n<li>域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变量组成的元组是否存在或是否满足谓词判断。</li>\n<li>公式的运算符(∧(与)、∨(或)、¬(非)、∀(全称量词)和∃(存在量词))是相同的，只是其中的变量不同。</li>\n<li>元组演算和域演算可以等价互换。</li>\n</ol>\n<h5 id=\"8-2-1-基于关系域演算的QBE语言\"><a href=\"#8-2-1-基于关系域演算的QBE语言\" class=\"headerlink\" title=\"8.2.1 基于关系域演算的QBE语言\"></a>8.2.1 基于关系域演算的QBE语言</h5><p>QBE: Query By Example，1975年由M. M. Zloof提出，1978年在IBM370上实现，是一种高度非过程化的查询语言，特别适合于终端用户的使用。</p>\n<ol>\n<li>特点：操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只需将条件填在表格中即可</li>\n<li>QBE操作框架由四个部分构成<ul>\n<li>关系名区：用于书写欲待查询的关系名</li>\n<li>属性名区：用于显示对应关系名区关系的所有属性名</li>\n<li>操作命令区：用于书写查询操作的命令</li>\n<li>查询条件区：用于书写查询条件</li>\n</ul>\n</li>\n<li>QBE的操作命令<ul>\n<li>Print 或 P.   —- 显示输出操作</li>\n<li>Delete或D.   —- 删除操作</li>\n<li>Insert或I.     —- 插入操作</li>\n<li>Update或U. —- 更新操作</li>\n</ul>\n</li>\n<li>构造查询的几个要素 <ul>\n<li>示例元素: 即域变量， 一定要加下划线 </li>\n<li>示例元素是这个域中可能的一个值， 它不必是查询结果中的元素</li>\n<li>打印操作符P.: 指定查询结果所含属性列 </li>\n<li>查询条件: 不用加下划线</li>\n<li>可使用比较运算符＞， ≥，＜， ≤，＝和≠  其中＝可以省略</li>\n<li>排序要求 <ul>\n<li>升序排序(AO.)，降序排序（DO.）,多列排序，用‚AO(i).‛ 或‚DO(i).‛ 表示 ，其中i为排序的优先级， i值越小，优先级越高</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-3-安全性\"><a href=\"#8-3-安全性\" class=\"headerlink\" title=\"8.3 安全性\"></a>8.3 安全性</h4><p>关系运算的安全性：不产生无限关系和无穷验证的运算被称为是安全的</p>\n<ol>\n<li>关系代数是一种集合运算，是安全的<ul>\n<li>集合本身是有限的，有限元素集合的有限次运算仍旧是有限的。</li>\n</ul>\n</li>\n<li>关系演算不一定是安全的<ul>\n<li>如：{t|¬(R(t))}, {t R(t)∨t[2]&gt;3}可能表示无限关系</li>\n</ul>\n</li>\n<li>需要对关系演算施加约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。</li>\n</ol>\n<h5 id=\"8-3-1-安全约束有限集合DOM\"><a href=\"#8-3-1-安全约束有限集合DOM\" class=\"headerlink\" title=\"8.3.1 安全约束有限集合DOM\"></a>8.3.1 安全约束有限集合DOM</h5><ol>\n<li>DOM(ψ)是一个有限集合，其中的每个符号要么是ψ中明显出现的符号，要么是出现在ψ中的某个关系R的某元组的分量。</li>\n<li>DOM主要用于约束ψ中一些谓词的计算范围，它不必是最小集合。</li>\n<li>安全元组演算表达式，满足三个条件：<ul>\n<li>只要t满足ψ，t的每个分量就是DOM(ψ)的一个成员。<ul>\n<li>{ t|ψ(t) }中t的取值只能是DOM中的值，有限的。</li>\n</ul>\n</li>\n<li>对于ψ中形如(∃u)(ω(u))的子表达式，若u满足ω,则u的每个分量都是DOM(ω)中的成员。<ul>\n<li>{ t|ψ(t) }中的每个(∃u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为真的元素。而对于DOM以外的元素，已经明确其都不满足ω(u)，无需验证。</li>\n</ul>\n</li>\n<li>对于ψ中形如(∀u)(ω(u))的子表达式，若u不满足ω,则u的每个分量都是DOM(ω)中的成员。<ul>\n<li>{ t|ψ(t) }中的每个(∀u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为假的元素。而对于DOM以外的元素，已经明确其都满足ω(u)，无需验证。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-4-关于三种关系运算的一些观点\"><a href=\"#8-4-关于三种关系运算的一些观点\" class=\"headerlink\" title=\"8.4 关于三种关系运算的一些观点\"></a>8.4 关于三种关系运算的一些观点</h4><ol>\n<li>关系运算有三种：关系代数、关系元组演算和关系域演算</li>\n<li>三种关系运算都是抽象的数学运算，体现了三种不同的思维<ul>\n<li>关系代数—以集合为对象的操作思维，由集合到集合的变换</li>\n<li>元组演算—以元组为对象的操作思维，取出关系的每一个元组进行验证，有一个元组变量则可能需要一个循环，多个元组变量则需要多个循环</li>\n<li>域演算—以域变量为对象的操作思维，取出域的每一个变量进行验证看其是否满足条件</li>\n</ul>\n</li>\n<li>三种运算之间是等价的<ul>\n<li>关系代数 与 安全的元组演算表达式 与 安全的域演算表达式 是等<br>价的。即一种形式的表达式可以被等价地转换为另一种形式</li>\n</ul>\n</li>\n<li>三种关系运算都可说是非过程性的<ul>\n<li>相比之下：域演算的非过程性最好，元组演算次之，关系代数最差</li>\n</ul>\n</li>\n<li>三种关系运算虽是抽象的，但却是衡量数据库语言完备性的基础<ul>\n<li>一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的</li>\n<li>目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他的操作，如赋值操作、聚集操作等</li>\n</ul>\n</li>\n<li>数据库语言可以基于这三种抽象运算来设计<ul>\n<li>用“键盘符号”来替换抽象的数学符号</li>\n<li>用易于理解的符号组合来表达抽象的数学符号</li>\n<li>例如：ISBL语言—基于关系代数的数据库语言</li>\n<li>再例如：Ingres系统的QUEL语言</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>数据库 是 电子化信息的集合</li>\n</ol>\n<ul>\n<li>将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li>\n</ul>\n<ol start=\"2\">\n<li>表(Table)：以按行按列形式组织及展现的数据","more":"</li>\n</ol>\n<ul>\n<li>数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据–&gt;关系</li>\n</ul>\n<ol start=\"3\">\n<li>数据库系统的构成（概念层次）:</li>\n<li>数据库(DB):Database：相互之间有关联关系的数据的集合</li>\n<li>数据库管理系统(DBMS):Database Management System</li>\n<li>数据库应用(DBAP):Database Application</li>\n<li>数据库管理员(DBA):Database Asministrator</li>\n<li>计算机基本系统</li>\n</ol>\n<h4 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h4><ol>\n<li><a href=\"#id1\">数据库管理系统(DBMS)</a></li>\n<li><a href=\"#id2\">数据库系统的标准结构</a></li>\n<li><a href=\"#id3\">三级模式两层映像</a></li>\n<li><a href=\"#id4\">数据模型</a></li>\n<li><a href=\"#id5\">关系模型</a></li>\n<li><a href=\"#id6\">关系模型中的完整性</a></li>\n<li><a href=\"#id7\">关系代数</a></li>\n<li><a href=\"#id8\">关系演算</a></li>\n</ol>\n<p><span id=\"id1\"><span></p>\n<h3 id=\"1-数据库管理系统-DBMS\"><a href=\"#1-数据库管理系统-DBMS\" class=\"headerlink\" title=\"1. 数据库管理系统(DBMS)\"></a>1. 数据库管理系统(DBMS)</h3><h4 id=\"1-1-从用户角度看DBMS-数据库管理系统\"><a href=\"#1-1-从用户角度看DBMS-数据库管理系统\" class=\"headerlink\" title=\"1.1 从用户角度看DBMS(数据库管理系统)\"></a>1.1 从用户角度看DBMS(数据库管理系统)</h4><ol>\n<li>数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等</li>\n</ol>\n<ul>\n<li>DBMS提供了一套<strong>数据定义语言(DDL</strong>: Data Definition Language)给用户</li>\n<li>用户使用DDL描述其所要建立的表的格式</li>\n<li>DBMS依照用户的定义，创建数据库及其中的表</li>\n</ul>\n<ol start=\"2\">\n<li>数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等</li>\n</ol>\n<ul>\n<li>DBMS提供了一套<strong>数据库操纵语言(DML</strong>: Data Manipulation Language)给用户</li>\n<li>用户使用DML描述其所要进行的增、删、改、查等操作</li>\n<li>DBMS依照用户的操作描述，实际执行这些操作</li>\n</ul>\n<ol start=\"3\">\n<li>数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)</li>\n</ol>\n<ul>\n<li>DBMS提供了一套<strong>数据控制语言(DCL</strong>: Data Control Language)给用户</li>\n<li>用户使用DCL描述其对数据库所要实施的控制</li>\n<li>DBMS依照用户描述，实际ijnx控制</li>\n</ul>\n<ol start=\"4\">\n<li>数据库维护：转储/恢复/重组/性能监测/分析…</li>\n</ol>\n<ul>\n<li>DBMS提供了一系列程序(实用程序/例行程序)给用户</li>\n<li>在这些程序中提供了对数据库维护的各种功能</li>\n<li>用户使用这些程序进行各种数据库维护操作</li>\n<li>(数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)</li>\n</ul>\n<h4 id=\"1-2-数据库语言\"><a href=\"#1-2-数据库语言\" class=\"headerlink\" title=\"1.2 数据库语言\"></a>1.2 数据库语言</h4><ul>\n<li>使用者使用数据库语言，利用DBMS操纵数据库</li>\n<li>SQL语言：结构化的数据库语言</li>\n<li>高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用</li>\n</ul>\n<h4 id=\"1-3-从系统实现角度看DBMS的功能\"><a href=\"#1-3-从系统实现角度看DBMS的功能\" class=\"headerlink\" title=\"1.3 从系统实现角度看DBMS的功能\"></a>1.3 从系统实现角度看DBMS的功能</h4><ol>\n<li>数据库管理系统的实现：形式 –&gt; 构造 –&gt; 自动化</li>\n<li>DBMS为完成DB管理，在后台运行着一系列程序…</li>\n</ol>\n<ul>\n<li><strong>语言编译器</strong>：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等</li>\n<li><strong>查询优化</strong>(执行引擎)与<strong>查询实现</strong>(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序</li>\n<li><strong>数据存取与索引</strong>：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等</li>\n<li><strong>通信控制</strong>：提供网络环境下数据库操作与数据传输的手段</li>\n<li><strong>事务管理</strong>：提供提高可靠性并避免并发操作错误的手段</li>\n<li><strong>故障恢复</strong>：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序</li>\n<li><strong>安全性控制</strong>：提供合法性检验，避免非授权非法用户访问数据库的手段</li>\n<li><strong>完整性控制</strong>：提供数据及数据操作正确性检查的手段</li>\n<li><strong>数据字典管理</strong>：管理用户已经定义的信息</li>\n<li>**应用程序接口(API)**：提供应用程序使用DBMS特定功能的二首段</li>\n<li><strong>数据库数据装载、重组等实用程序</strong></li>\n<li><strong>数据库性能分析</strong>：统计在运行过程中数据库的各种性能数据，便于优化运行</li>\n</ul>\n<blockquote>\n<p>典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL </p>\n</blockquote>\n<p><span id=\"id2\"><span></p>\n<h3 id=\"2-数据库系统的标准结构\"><a href=\"#2-数据库系统的标准结构\" class=\"headerlink\" title=\"2. 数据库系统的标准结构\"></a>2. 数据库系统的标准结构</h3><p>DBMS管理数据的三个层次：</p>\n<ol>\n<li>External Level = User Level（外部级别 = 用户级别）</li>\n</ol>\n<ul>\n<li>某一用户能够看到与处理的数据,   全局数据中的某一部分</li>\n</ul>\n<ol start=\"2\">\n<li>Conceptual Level = Logic level（概念级别 = 逻辑级别）</li>\n</ol>\n<ul>\n<li>从全局角度理解/管理的数据, 含相应的关联约束</li>\n</ul>\n<ol start=\"3\">\n<li>Internal Level = Physical level（内部级别 = 物理级别）</li>\n</ol>\n<ul>\n<li>存储在介质上的数据，含存储路径、存储方式 、索引方式等</li>\n</ul>\n<p><span id=\"id3\"><span></p>\n<h3 id=\"3-三级模式两层映像\"><a href=\"#3-三级模式两层映像\" class=\"headerlink\" title=\"3. 三级模式两层映像\"></a>3. 三级模式两层映像</h3><p>数据库的三级模式结构是指：数据库系统是由外模式、模式(概念模式)和内模式三级构成</p>\n<ul>\n<li>应用–&gt; 外模式(多个) –&gt; 模式(一个) –&gt; 内模式(一个) –&gt; 数据库</li>\n</ul>\n<h4 id=\"3-1-数据-视图-与模式-数据的结构\"><a href=\"#3-1-数据-视图-与模式-数据的结构\" class=\"headerlink\" title=\"3.1 数据(视图)与模式(数据的结构)\"></a>3.1 数据(视图)与模式(数据的结构)</h4><ul>\n<li>模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息</li>\n<li>视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据</li>\n</ul>\n<h4 id=\"3-2-三级模式-三级视图\"><a href=\"#3-2-三级模式-三级视图\" class=\"headerlink\" title=\"3.2 三级模式(三级视图)\"></a>3.2 三级模式(三级视图)</h4><ol>\n<li>External Schema —-(External) View</li>\n</ol>\n<ul>\n<li>外模式：某一用户能够看到与处理的数据的结构描述</li>\n</ul>\n<ol start=\"2\">\n<li>(Conceptual) Schema —- Conceptual View</li>\n</ol>\n<ul>\n<li>模式(概念模式)：从全局角度理解/管理的数据的结构描述, 含相应的关联约束</li>\n<li>体现在数据之间的内在本质联系</li>\n</ul>\n<ol start=\"3\">\n<li>Internal Schema —- Internal  View</li>\n</ol>\n<ul>\n<li>内模式：存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等</li>\n</ul>\n<h4 id=\"3-3-两层映像\"><a href=\"#3-3-两层映像\" class=\"headerlink\" title=\"3.3 两层映像\"></a>3.3 两层映像</h4><ol>\n<li>E-C Mapping：External Schema-Conceptual Schema Mapping </li>\n</ol>\n<ul>\n<li>将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换</li>\n<li>便于用户观察和使用</li>\n</ul>\n<ol start=\"2\">\n<li>C-I Mapping：Conceptual Schema-Internal Schema Mapping </li>\n</ol>\n<ul>\n<li>将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换</li>\n<li>便于计算机进行存储和处理</li>\n</ul>\n<h4 id=\"3-4-标准结构的两个独立性\"><a href=\"#3-4-标准结构的两个独立性\" class=\"headerlink\" title=\"3.4 标准结构的两个独立性\"></a>3.4 标准结构的两个独立性</h4><ol>\n<li>逻辑数据独立性</li>\n</ol>\n<ul>\n<li>当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序</li>\n</ul>\n<ol start=\"2\">\n<li>物理数据独立性</li>\n</ol>\n<ul>\n<li>当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式</li>\n</ul>\n<p><span id=\"id4\"><span></p>\n<h3 id=\"4-数据模型\"><a href=\"#4-数据模型\" class=\"headerlink\" title=\"4. 数据模型\"></a>4. 数据模型</h3><ol>\n<li>数据模型：模式 与 模式的结构</li>\n</ol>\n<ul>\n<li>规定模式统一描述方式的模型，包括：数据结构、操作和约束</li>\n<li>数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象</li>\n<li>比如：关系模型：所有模式都可为抽象表(Table)的形式[<strong>数据结构</strong>]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[<strong>操作</strong>]和[<strong>约束</strong>]</li>\n</ul>\n<ol start=\"2\">\n<li>三大经典数据模型</li>\n</ol>\n<ul>\n<li>关系模型：<strong>表</strong>的形式组织数据</li>\n<li>层次模型：<strong>树</strong>的形式组织数据</li>\n<li>网状模型：<strong>图</strong>的形式组织数据</li>\n</ul>\n<p><span id=\"id5\"><span></p>\n<h3 id=\"5-关系模型\"><a href=\"#5-关系模型\" class=\"headerlink\" title=\"5. 关系模型\"></a>5. 关系模型</h3><ol>\n<li>形象地说，<strong>一个关系(relation)就是一个Table</strong>，关系模型就是处理Table的，它由三个部分组成：</li>\n</ol>\n<ul>\n<li>描述DB各种数据的基本结构形式(Table/Relation)</li>\n<li>描述Table与Table之间所可能发生的各种操作(关系运算)</li>\n<li>描述这些操作所应遵循的约束条件(完整性约束)</li>\n</ul>\n<ol start=\"2\">\n<li>关系模型的三个要素：</li>\n</ol>\n<ul>\n<li>基本结构：Relation/Table</li>\n<li>基本操作：Relation Operator<ul>\n<li>基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。</li>\n<li>扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算</li>\n</ul>\n</li>\n<li>完整性约束：实体完整性、参照完整性和用户自定义的完整性</li>\n</ul>\n<ol start=\"3\">\n<li>表(Table)的基本构成要素</li>\n</ol>\n<ul>\n<li>列/字段/属性/数据项：列名，列值</li>\n<li>行/元组/记录</li>\n<li>标题/模式</li>\n</ul>\n<h4 id=\"5-1-“表”的严格定义\"><a href=\"#5-1-“表”的严格定义\" class=\"headerlink\" title=\"5.1 “表”的严格定义\"></a>5.1 “表”的严格定义</h4><ul>\n<li>域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型</li>\n<li>笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组</li>\n<li>关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)</li>\n</ul>\n<h4 id=\"5-2-关系模式与关系\"><a href=\"#5-2-关系模式与关系\" class=\"headerlink\" title=\"5.2 关系模式与关系\"></a>5.2 关系模式与关系</h4><ul>\n<li>同一关系模式下，可有很多的关系</li>\n<li>关系模式是关系的结构, 关系是关系模式在某一时刻的数据</li>\n<li>关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的</li>\n</ul>\n<h4 id=\"5-3-关系的特性\"><a href=\"#5-3-关系的特性\" class=\"headerlink\" title=\"5.3 关系的特性\"></a>5.3 关系的特性</h4><ul>\n<li>列是同质：即每一列中的分量来自同一域，是同一类型的数据</li>\n<li>不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</li>\n<li>列位置互换性：区分哪一列是靠列名</li>\n<li>行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)</li>\n<li>关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分</li>\n<li>理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。</li>\n<li>属性不可再分特性:又被称为关系第一范式</li>\n</ul>\n<h4 id=\"5-4-关系的一些重要概念\"><a href=\"#5-4-关系的一些重要概念\" class=\"headerlink\" title=\"5.4 关系的一些重要概念\"></a>5.4 关系的一些重要概念</h4><ol>\n<li>候选码(Candidate Key)/候选键</li>\n</ol>\n<ul>\n<li>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉<br>任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。</li>\n</ul>\n<ol start=\"2\">\n<li>主码(Primary Key)/主键</li>\n</ol>\n<ul>\n<li>当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组</li>\n</ul>\n<ol start=\"3\">\n<li>主属性与非主属性</li>\n</ol>\n<ul>\n<li>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性</li>\n<li>最简单的，候选码只包含一个属性；</li>\n<li>极端的，所有属性构成这个关系的候选码，称为全码(All-Key)</li>\n</ul>\n<ol start=\"4\">\n<li>外码(Foreign Key)/外键</li>\n</ol>\n<ul>\n<li>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</li>\n<li>两个关系通常是靠外码连接起来的。</li>\n</ul>\n<p><span id=\"id6\"><span></p>\n<h3 id=\"6-关系模型中的完整性\"><a href=\"#6-关系模型中的完整性\" class=\"headerlink\" title=\"6. 关系模型中的完整性\"></a>6. 关系模型中的完整性</h3><h4 id=\"6-1-实体完整性\"><a href=\"#6-1-实体完整性\" class=\"headerlink\" title=\"6.1 实体完整性\"></a>6.1 实体完整性</h4><ul>\n<li>关系的主码中的属性值不能为空值；</li>\n<li>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。</li>\n</ul>\n<h4 id=\"6-2-参照完整性\"><a href=\"#6-2-参照完整性\" class=\"headerlink\" title=\"6.2 参照完整性\"></a>6.2 参照完整性</h4><ul>\n<li>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值</li>\n<li>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在</li>\n</ul>\n<h4 id=\"6-3-用户自定义完整性\"><a href=\"#6-3-用户自定义完整性\" class=\"headerlink\" title=\"6.3 用户自定义完整性\"></a>6.3 用户自定义完整性</h4><ul>\n<li>用户针对具体的应用环境定义的完整性约束条件</li>\n</ul>\n<h4 id=\"6-4-DBMS对关系完整性的支持\"><a href=\"#6-4-DBMS对关系完整性的支持\" class=\"headerlink\" title=\"6.4 DBMS对关系完整性的支持\"></a>6.4 DBMS对关系完整性的支持</h4><ul>\n<li>实体完整性和参照完整性由DBMS系统自动支持</li>\n<li>DBMS系统通常提供了如下机制：<ol>\n<li>它使用户可以自行定义有关的完整性约束条件</li>\n<li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id7\"><span></p>\n<h3 id=\"7-关系代数\"><a href=\"#7-关系代数\" class=\"headerlink\" title=\"7. 关系代数\"></a>7. 关系代数</h3><h4 id=\"7-1-关系代数的特点\"><a href=\"#7-1-关系代数的特点\" class=\"headerlink\" title=\"7.1 关系代数的特点\"></a>7.1 关系代数的特点</h4><ul>\n<li>基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作</li>\n<li>以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。</li>\n<li>关系代数操作以一个或多个关系为输入，结果是一个新的关系。</li>\n<li>用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。</li>\n<li>是一种抽象的语言，是学习其他数据库语言，如SQL等的基础</li>\n</ul>\n<h4 id=\"7-2-关系代数的约束\"><a href=\"#7-2-关系代数的约束\" class=\"headerlink\" title=\"7.2 关系代数的约束\"></a>7.2 关系代数的约束</h4><p>某些关系代数操作，如并、差、交等，需满足”并相容性”</p>\n<ul>\n<li>并相容性：<ol>\n<li>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性</li>\n<li>定义：关系R与关系S存在相容性，当且仅当：</li>\n</ol>\n<ul>\n<li>(1) 关系R和关系S的属性数目必须相同；</li>\n<li>(2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同</li>\n</ul>\n<ul>\n<li>示例：关系R：STUDENT(SID <strong>char(10)</strong>, Sname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li>\n<li>示例：关系S：TEACHER(TID <strong>char(10)</strong>, Tname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-3-关系代数的基本操作\"><a href=\"#7-3-关系代数的基本操作\" class=\"headerlink\" title=\"7.3 关系代数的基本操作\"></a>7.3 关系代数的基本操作</h4><ol>\n<li>集合操作</li>\n</ol>\n<ul>\n<li>并（UNIO）：R∪S</li>\n<li>交（INTERSECTION）：R∩S</li>\n<li>差（DIFFERENCE）：R-S</li>\n<li>笛卡儿积（Cartesian PRODUCT）：R×S</li>\n</ul>\n<ol start=\"2\">\n<li>纯关系操作</li>\n</ol>\n<ul>\n<li>选择（SELECT）：σF(R)</li>\n<li>投影（PROJECT）：ΠA(R)</li>\n<li>连接（JOIN）：R⋈S</li>\n<li>除（DIVISION）：R÷S</li>\n</ul>\n<h5 id=\"7-3-1-并-Union-操作\"><a href=\"#7-3-1-并-Union-操作\" class=\"headerlink\" title=\"7.3.1 并(Union) 操作\"></a>7.3.1 并(Union) 操作</h5><ul>\n<li>定义：设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：**<code>R∪S</code>**, 它由 或者出现在关系R中，或者出现在S中的元组构成。</li>\n<li>数学描述：<code>R∪S=&#123;t|t∈R∨t∈S&#125;</code>，其中t是元组</li>\n<li>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</li>\n<li>汉语中的“或者…或者…”通常意义是并运算的要求。</li>\n<li><code>R∪S</code> 与 <code>S∪R</code> 运算的结果是<strong>同</strong>一个关系</li>\n</ul>\n<h5 id=\"7-3-2-差-Difference-操作\"><a href=\"#7-3-2-差-Difference-操作\" class=\"headerlink\" title=\"7.3.2 差(Difference) 操作\"></a>7.3.2 差(Difference) 操作</h5><ul>\n<li>定义：设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：**<code>R-S</code>**, 它由出现在关系R中但不出现在关系S中的元组构成。</li>\n<li>数学描述：<code>R－S=&#123;t|t∈R∧t∉S&#125;</code>，其中t是元组</li>\n<li>汉语中的“是…但不含…”通常意义是差运算的要求。</li>\n<li><code>R-S</code> 与 <code>S-R</code> 是<strong>不同</strong>的</li>\n</ul>\n<h5 id=\"7-3-3-交（Intersection-Referential-integrity）-操作\"><a href=\"#7-3-3-交（Intersection-Referential-integrity）-操作\" class=\"headerlink\" title=\"7.3.3  交（Intersection Referential integrity） 操作\"></a>7.3.3  交（Intersection Referential integrity） 操作</h5><ul>\n<li>定义：设关系R和关系S具有相同的目n，且相应的属性取自同一个域，则关系R与关系S的交由既属于R又属于S的元组组成。其结果关系仍为n目关系。</li>\n<li>数学描述：<code>R∩S=&#123;t|t∈R∧t∈S&#125;</code>，其中t是元组</li>\n</ul>\n<h5 id=\"7-3-4-广义笛卡尔积-Extended-cartesian-product-操作\"><a href=\"#7-3-4-广义笛卡尔积-Extended-cartesian-product-操作\" class=\"headerlink\" title=\"7.3.4 广义笛卡尔积(Extended cartesian product) 操作\"></a>7.3.4 广义笛卡尔积(Extended cartesian product) 操作</h5><ul>\n<li>定义：关系<code>R(&lt;a1,a2, …,an&gt;)</code>与关系<code>S(&lt;b1,b2, …,bm &gt;)</code>的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：**<code>RxS</code>**；两个分别为n目和m目的关系R和S的广义笛卡尔积是一个(n+m)列的元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组，若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。</li>\n<li>数学描述：<code>RxS = &#123;&lt;a1,a2,…,an,b1,b2,…,bm&gt;|&lt;a1,a2,…,an&gt;∈R ∧ &lt;b1,b2,…,bm&gt;∈S&#125;</code></li>\n<li><code>RxS=SxR</code>：RxS为R中的每一个元组都和S中的所有元组进行串接。<code>SxR</code>为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。</li>\n<li>两个关系R和S，它们的<strong>属性个数</strong>分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).</li>\n<li>两个关系R和S，它们的<strong>元组个数</strong>分别为x和y(关系R的基数x,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).</li>\n</ul>\n<h5 id=\"7-3-5-选择-Select\"><a href=\"#7-3-5-选择-Select\" class=\"headerlink\" title=\"7.3.5 选择(Select)\"></a>7.3.5 选择(Select)</h5><ul>\n<li>定义：给定一个关系R, 同时给定一个选择的条件condition(简记F), 选择运算结果也是一个关系，记作**<code>σF(R)</code>**, 它从关系R中选择出满足给定条件condition的元组构成。</li>\n<li>数学描述：<code>σF(R) = &#123;t|t∈R ∧ F(t)=&#39;真&#39;&#125;</code>,其中F表示选择条件，它是一个逻辑表达式，取逻辑值‘真’或‘假’。</li>\n<li>选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ <code>括弧()；θ；¬；∧；∨</code> }</li>\n</ul>\n<h5 id=\"7-3-6-投影-Project\"><a href=\"#7-3-6-投影-Project\" class=\"headerlink\" title=\"7.3.6 投影(Project)\"></a>7.3.6 投影(Project)</h5><ul>\n<li>定义：给定一个关系R, 投影运算结果也是一个关系，记作**<code>A(R)</code>**, 它从关系R中选出属性包含在A中的列构成。</li>\n<li>数学描述：<code>ΠA(R) = &#123;t[A] | t∈R&#125;</code>,其中A为R中的属性列</li>\n<li>投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系</li>\n</ul>\n<h4 id=\"7-4-关系代数的扩展操作\"><a href=\"#7-4-关系代数的扩展操作\" class=\"headerlink\" title=\"7.4 关系代数的扩展操作\"></a>7.4 关系代数的扩展操作</h4><h5 id=\"7-4-1-交-Intersection\"><a href=\"#7-4-1-交-Intersection\" class=\"headerlink\" title=\"7.4.1 交(Intersection)\"></a>7.4.1 交(Intersection)</h5><ul>\n<li><strong>定义</strong>：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：**<code>R∩S</code>**, 它由同时出现在关系R和关系S中的元组构成。</li>\n<li>数学描述：<code>R∩S = &#123;t|t∈R ∧ t∈S&#125;</code>，其中t是元组</li>\n<li>R∩S 和 S∩R 运算的结果是同一个关系</li>\n<li>交运算可以通过差运算来实现：<code>R∩S = R-(R-S) = S-(S-R)</code></li>\n<li>汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求</li>\n</ul>\n<h5 id=\"7-4-2-θ-连接-θ-Join-theta-Join\"><a href=\"#7-4-2-θ-连接-θ-Join-theta-Join\" class=\"headerlink\" title=\"7.4.2 θ-连接(θ-Join, theta-Join)\"></a>7.4.2 θ-连接(θ-Join, theta-Join)</h5><ul>\n<li>投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作</li>\n<li><strong>定义</strong>：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 **<code>R⋈S[AθB]</code>**：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。</li>\n<li>数学描述：<code>R⋈S[AθB] = σ t[A]θs[B] (R×S)</code>，σF(RxS)其中t是R中的元组，s是S中的元组</li>\n<li>在实际应用中，θ-连接操作经常与投影Π、选择σ操作一起使用</li>\n<li><strong>特别注意</strong>：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。</li>\n</ul>\n<h5 id=\"7-4-3-等值连接-Equi-Join\"><a href=\"#7-4-3-等值连接-Equi-Join\" class=\"headerlink\" title=\"7.4.3 等值连接(Equi-Join)\"></a>7.4.3 等值连接(Equi-Join)</h5><ul>\n<li><strong>定义</strong>：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作**<code>R⋈S[A=B]</code>**：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。</li>\n<li>数学描述：<code>R⋈S[A=B] = σ t[A]=s[B] (R×S)</code></li>\n<li>当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；</li>\n<li>广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用<strong>θ-连接/等值连接</strong>运算可大幅度降低中间结果的保存量，提高速度。</li>\n</ul>\n<h5 id=\"7-4-4-自然连接-Natural-Join\"><a href=\"#7-4-4-自然连接-Natural-Join\" class=\"headerlink\" title=\"7.4.4 自然连接(Natural-Join)\"></a>7.4.4 自然连接(Natural-Join)</h5><ul>\n<li>定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。</li>\n<li>数学描述：<code>R⋈S = σ t[B]=s[B] (R×S)</code></li>\n<li>自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列</li>\n</ul>\n<h4 id=\"7-5-关系代数的基本书写思路\"><a href=\"#7-5-关系代数的基本书写思路\" class=\"headerlink\" title=\"7.5 关系代数的基本书写思路\"></a>7.5 关系代数的基本书写思路</h4><ol>\n<li>选出将用到的关系/表</li>\n<li>做”积”运算（可用连接运算替换）</li>\n<li>做选择运算保留所需的行/元组</li>\n<li>做投影运算保留所需的列/属性</li>\n</ol>\n<ul>\n<li>基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可</li>\n<li>如涉及多个表，则检查：<ul>\n<li>能否使用自然连接，将多个表连接起来(多数情况是这样的)</li>\n<li>如不能，能否使用等值或不等值连接(θ-连接)</li>\n<li>还不能，则使用广义笛卡尔积，注意相关条件的书写</li>\n</ul>\n</li>\n<li>连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作</li>\n</ul>\n<h4 id=\"7-6-关系代数之复杂扩展操作\"><a href=\"#7-6-关系代数之复杂扩展操作\" class=\"headerlink\" title=\"7.6 关系代数之复杂扩展操作\"></a>7.6 关系代数之复杂扩展操作</h4><h5 id=\"7-6-1-除-Division\"><a href=\"#7-6-1-除-Division\" class=\"headerlink\" title=\"7.6.1 除(Division)\"></a>7.6.1 除(Division)</h5><ul>\n<li>除法运算经常用于求解“查询… 全部的/所有的…”问题</li>\n<li>前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m &lt; n。</li>\n<li>定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。</li>\n<li>数学描述：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R÷S = &#123;t|t∈Π[R-S](R) ∧ ∀u∈S(tu∈R) &#125;</span><br><span class=\"line\">    = Π[R-S](R) - Π[R-S]((Π[R-S](R)×S)-R)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>其中[R-S]为投影Π的下标(属性)</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"7-6-2-外连接-Outer-Join\"><a href=\"#7-6-2-外连接-Outer-Join\" class=\"headerlink\" title=\"7.6.2 外连接(Outer-Join)\"></a>7.6.2 外连接(Outer-Join)</h5><ul>\n<li>定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。</li>\n<li>外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)</li>\n<li>外连接的形式：左外连接、右外连接、全外连接<ul>\n<li>左外连接 = 自然连接(或连接) + 左侧表中失配的元组</li>\n<li>右外连接 = 自然连接(或连接) + 右侧表中失配的元组</li>\n<li>全外连接 = 自然连接(或连接) + 两侧表中失配的元组</li>\n<li>左外连接(Left Outer Join)记为：⋊</li>\n<li>右外连接(Right Outer Join)记为：⋉</li>\n<li>全外连接(Full Outer Join)记为：⋊⋉</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id8\"><span></p>\n<h3 id=\"8-关系演算\"><a href=\"#8-关系演算\" class=\"headerlink\" title=\"8. 关系演算\"></a>8. 关系演算</h3><p>关系演算是<strong>描述关系运算</strong>的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的</p>\n<ul>\n<li>按照谓词变量的不同，可分为关系元组演算和关系域演算<ol>\n<li>关系元组演算是以<strong>元组变量</strong>作为谓词变量的基本对象</li>\n<li>关系域演算是以<strong>域变量</strong>作为谓词变量的基本对象</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"8-1-关系元组演算\"><a href=\"#8-1-关系元组演算\" class=\"headerlink\" title=\"8.1 关系元组演算\"></a>8.1 关系元组演算</h4><ol>\n<li>关系元组演算公式：{ t | P(t) }</li>\n</ol>\n<ul>\n<li>表示：所有使谓词 P 为真的元组 t 的集合</li>\n<li>t 是元组变量</li>\n<li>t ∈ r 表示元组 t 在关系 r 中</li>\n<li>t[A] 表示元组 t 的分量，即 t 在属性 A 上的值</li>\n<li>P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式</li>\n</ul>\n<ol start=\"2\">\n<li>关系元组演算公式的基本形式：{ t | P(t) }</li>\n<li>P(t)可以是如下三种形式之一的原子公式：</li>\n</ol>\n<ul>\n<li>t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}</li>\n<li>s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符&lt;,&lt;=,=,&lt;&gt;,&gt;,&gt;=</li>\n<li>s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，</li>\n</ul>\n<ol start=\"4\">\n<li>P(t)可以由公式加运算符 ∧(与)、∨(或)、¬(非)递归地构造</li>\n</ol>\n<ul>\n<li>如果F是一个公式，则 ¬F 也是公式</li>\n<li>如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式</li>\n</ul>\n<ol start=\"5\">\n<li>P(t)运算符优先次序(括弧；θ；∃；∀；¬；∧；∨)示例</li>\n<li>构造P(t)还有两个运算符：∃(存在)、∀(任意)</li>\n</ol>\n<ul>\n<li>如果F是一个公式，则 ∃(t∈r)(F(t)) 也是公式</li>\n<li>如果F是一个公式，则 ∀(t∈r)(F(t)) 也是公式</li>\n<li>运算符∃和∀，又称为量词，前者称“<strong>存在量词</strong>”，后者称“<strong>全称量词</strong>”</li>\n<li>而被∃或∀限定的元组变量 t , 或者说，元组变量 t 前有存在量词或全称量词，则该变量被称为“<strong>约束变量</strong>”，否则被称为“<strong>自由变量</strong>”。</li>\n</ul>\n<ol start=\"7\">\n<li>元组演算的等价性变换<ul>\n<li>符号<code>&lt;=&gt;</code>表示表示等价于,如：<code>¬(A&gt;B) &lt;=&gt; A&lt;=B  &lt;=&gt; A&lt;B∨A=B</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-2-关系域演算\"><a href=\"#8-2-关系域演算\" class=\"headerlink\" title=\"8.2 关系域演算\"></a>8.2 关系域演算</h4><ol>\n<li>关系域演算公式的基本形式：<code>&#123;&lt;x1,x2, …,xn&gt; | P(x1,x2, …,xn)&#125;</code>,其中 xi 代表域变量或常量, P为以xi为变量的公式。</li>\n<li>元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后再找到元组分量，进行谓词判断；</li>\n<li>域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变量组成的元组是否存在或是否满足谓词判断。</li>\n<li>公式的运算符(∧(与)、∨(或)、¬(非)、∀(全称量词)和∃(存在量词))是相同的，只是其中的变量不同。</li>\n<li>元组演算和域演算可以等价互换。</li>\n</ol>\n<h5 id=\"8-2-1-基于关系域演算的QBE语言\"><a href=\"#8-2-1-基于关系域演算的QBE语言\" class=\"headerlink\" title=\"8.2.1 基于关系域演算的QBE语言\"></a>8.2.1 基于关系域演算的QBE语言</h5><p>QBE: Query By Example，1975年由M. M. Zloof提出，1978年在IBM370上实现，是一种高度非过程化的查询语言，特别适合于终端用户的使用。</p>\n<ol>\n<li>特点：操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只需将条件填在表格中即可</li>\n<li>QBE操作框架由四个部分构成<ul>\n<li>关系名区：用于书写欲待查询的关系名</li>\n<li>属性名区：用于显示对应关系名区关系的所有属性名</li>\n<li>操作命令区：用于书写查询操作的命令</li>\n<li>查询条件区：用于书写查询条件</li>\n</ul>\n</li>\n<li>QBE的操作命令<ul>\n<li>Print 或 P.   —- 显示输出操作</li>\n<li>Delete或D.   —- 删除操作</li>\n<li>Insert或I.     —- 插入操作</li>\n<li>Update或U. —- 更新操作</li>\n</ul>\n</li>\n<li>构造查询的几个要素 <ul>\n<li>示例元素: 即域变量， 一定要加下划线 </li>\n<li>示例元素是这个域中可能的一个值， 它不必是查询结果中的元素</li>\n<li>打印操作符P.: 指定查询结果所含属性列 </li>\n<li>查询条件: 不用加下划线</li>\n<li>可使用比较运算符＞， ≥，＜， ≤，＝和≠  其中＝可以省略</li>\n<li>排序要求 <ul>\n<li>升序排序(AO.)，降序排序（DO.）,多列排序，用‚AO(i).‛ 或‚DO(i).‛ 表示 ，其中i为排序的优先级， i值越小，优先级越高</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-3-安全性\"><a href=\"#8-3-安全性\" class=\"headerlink\" title=\"8.3 安全性\"></a>8.3 安全性</h4><p>关系运算的安全性：不产生无限关系和无穷验证的运算被称为是安全的</p>\n<ol>\n<li>关系代数是一种集合运算，是安全的<ul>\n<li>集合本身是有限的，有限元素集合的有限次运算仍旧是有限的。</li>\n</ul>\n</li>\n<li>关系演算不一定是安全的<ul>\n<li>如：{t|¬(R(t))}, {t R(t)∨t[2]&gt;3}可能表示无限关系</li>\n</ul>\n</li>\n<li>需要对关系演算施加约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。</li>\n</ol>\n<h5 id=\"8-3-1-安全约束有限集合DOM\"><a href=\"#8-3-1-安全约束有限集合DOM\" class=\"headerlink\" title=\"8.3.1 安全约束有限集合DOM\"></a>8.3.1 安全约束有限集合DOM</h5><ol>\n<li>DOM(ψ)是一个有限集合，其中的每个符号要么是ψ中明显出现的符号，要么是出现在ψ中的某个关系R的某元组的分量。</li>\n<li>DOM主要用于约束ψ中一些谓词的计算范围，它不必是最小集合。</li>\n<li>安全元组演算表达式，满足三个条件：<ul>\n<li>只要t满足ψ，t的每个分量就是DOM(ψ)的一个成员。<ul>\n<li>{ t|ψ(t) }中t的取值只能是DOM中的值，有限的。</li>\n</ul>\n</li>\n<li>对于ψ中形如(∃u)(ω(u))的子表达式，若u满足ω,则u的每个分量都是DOM(ω)中的成员。<ul>\n<li>{ t|ψ(t) }中的每个(∃u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为真的元素。而对于DOM以外的元素，已经明确其都不满足ω(u)，无需验证。</li>\n</ul>\n</li>\n<li>对于ψ中形如(∀u)(ω(u))的子表达式，若u不满足ω,则u的每个分量都是DOM(ω)中的成员。<ul>\n<li>{ t|ψ(t) }中的每个(∀u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为假的元素。而对于DOM以外的元素，已经明确其都满足ω(u)，无需验证。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-4-关于三种关系运算的一些观点\"><a href=\"#8-4-关于三种关系运算的一些观点\" class=\"headerlink\" title=\"8.4 关于三种关系运算的一些观点\"></a>8.4 关于三种关系运算的一些观点</h4><ol>\n<li>关系运算有三种：关系代数、关系元组演算和关系域演算</li>\n<li>三种关系运算都是抽象的数学运算，体现了三种不同的思维<ul>\n<li>关系代数—以集合为对象的操作思维，由集合到集合的变换</li>\n<li>元组演算—以元组为对象的操作思维，取出关系的每一个元组进行验证，有一个元组变量则可能需要一个循环，多个元组变量则需要多个循环</li>\n<li>域演算—以域变量为对象的操作思维，取出域的每一个变量进行验证看其是否满足条件</li>\n</ul>\n</li>\n<li>三种运算之间是等价的<ul>\n<li>关系代数 与 安全的元组演算表达式 与 安全的域演算表达式 是等<br>价的。即一种形式的表达式可以被等价地转换为另一种形式</li>\n</ul>\n</li>\n<li>三种关系运算都可说是非过程性的<ul>\n<li>相比之下：域演算的非过程性最好，元组演算次之，关系代数最差</li>\n</ul>\n</li>\n<li>三种关系运算虽是抽象的，但却是衡量数据库语言完备性的基础<ul>\n<li>一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的</li>\n<li>目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他的操作，如赋值操作、聚集操作等</li>\n</ul>\n</li>\n<li>数据库语言可以基于这三种抽象运算来设计<ul>\n<li>用“键盘符号”来替换抽象的数学符号</li>\n<li>用易于理解的符号组合来表达抽象的数学符号</li>\n<li>例如：ISBL语言—基于关系代数的数据库语言</li>\n<li>再例如：Ingres系统的QUEL语言</li>\n</ul>\n</li>\n</ol>"},{"title":"【数据库优化】MySQL事务处理与并发控制","date":"2019-09-07T15:31:48.000Z","_content":"\n\n### 1. MySQL事务\n1. 事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；<!-- more -->\n2. 事务的特性(ACID)：\n    + **原子性**（Atomicity，或称不可分割性）：最小的工作单元，整个工作单元要么一起提交成功，要么全部失败回滚\n    + **一致性**（Consistency）：事务中操作的数据及状态改变是一致的，即写入资料的结果必须完全符合预设的规则， 不会因为出现系统意外等原因导致状态的不一致\n    + **隔离性**（Isolation，又称独立性）：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）\n    + **持久性**（Durability）：事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失\n3. 事务的开启与提交模式\n    + 若参数autocommit=0，自动开启**手动提交**\n    + 若参数autocommit=1（系统默认值），又分为两种状态：\n        + **自动开启自动提交**：用户的每一个操作都是一个完整的事务周期。\n        + **手动开启手动提交**：从用户执行`start transaction`命令到用户执行`commit`命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。\n            * `begin` 或者 `start transaction`   -- 开启事务\n            * `commit` 或者 `rollback`           -- 事务提交或回滚\n    \n\n####  1.1 事务的隔离级别\n- 查看/设置隔离级别\n    + 查看：`SELECT @@tx_isolation`\n    + 设置：`set tx_isolation='xxx'`\n1.  **读未提交**（Read Uncommitted）\n    + 事务未提交对其他事务也是可见的，脏读（dirty read）\n2. **读提交**（Read Committed）--解决脏读问题 \n    + 一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读（nonrepeatable read）\n3. **可重复读**（Repeatable Read）--解决不可重复读问题\n    + 在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未定义解决幻读的问题\n4. **串行化**（Serializable）--解决所有问题\n    + 最高的隔离级别，通过强制事务的串行执行，但是会导致大量超时以及锁争用问题\n\n> Mysql默认采用`REPEATABLE_READ`隔离级别，Oracle默认采用`READ_COMMITTED`隔离级别。\n> 事务的隔离级别的实现：锁、MVCC（多版本并发控制 Multiversion Currency Control）。\n\n\n#### 1.2 事务的七大传播行为\nSpring在TransactionDefinition接口中规定了**7种**类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。\n- 事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时**事务如何传播**。\n    + `@Transactional(propagation = Propagation.REQUIRED)`\n1. 第一类：运行在同一个事务\n    + **`REQUIRED`**（required）：默认，支持当前事务，如果当前没有事务，就新建一个事务。\n    + `SUPPORTS`（supports）：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)\n    + `MANDATORY`（mandatory）：支持当前事务，如果当前没有事务，就抛出异常\n2. 第二类：运行在不同事务\n    + **`REQUIRES_NEW`**（requires new）：新建事务，如果当前存在事务，把当前事务挂起\n    + `NOT_SUPPORTED`(not supported)：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\n    + `NEVER`（never）：以非事务方式执行，如果当前存在事务，则抛出异常\n3. 第三类：嵌套执行--即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态\n    + **`NESTED`**（nested）：如果当前事务存在，则嵌套事务执行\n\n\n\n### 2. 锁\n锁是用于管理不同事务对共享资源的并发访问，InnoDB存储引擎支持行锁和表锁（InnoDB表锁是另类的行锁）\n- InnoDB行锁\n    + 共享锁（读锁）：Shared Locks\n    + 排它锁（写锁）：Exclusive Locks\n- InnoDB表锁\n    + 意向锁共享锁（IS）：Intention Shared Locks\n    + 意向锁排它锁（IX）：Intention Exclusive Locks\n    + 自增锁：AUTO-INC Locks\n- 行锁的算法\n    + 记录锁 Record Locks\n    + 间隙锁 Gap Locks\n    + 临键锁 Next-key Locks\n\n\n#### 2.1 共享锁(Shared) & 排他锁(Exclusive)\n它们都是标准的**行级锁**。\n- 共享锁（S锁）：读锁，读锁允许多个连接可以同一时刻**并发的读**取同一资源,互不干扰，但是只能读不能修改;\n    + 加锁： `select * from users WHERE id=1 `**`LOCK IN SHARE MODE`**; \n    + 解锁：**`commit`**或**`rollback`**\n- 排他锁（X锁）：写锁，一个写锁会**阻塞**其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。\n    + 加锁： `select * from users WHERE id=1 `**`FOR UPDATE`**; \n    + **`delete/update/insert 默认上 X 锁`**\n    + 解锁：**`commit`**或**`rollback`**\n\n> 注意：所谓共享锁、排他锁其实均是**锁机制本身的策略**，通过这两种策略对锁做了区分。\n- InnoDB的行锁是通过**给索引上的索引项加锁**来实现的。\n- 只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）\n\n\n#### 2.2 意向锁(Intention) & 自增锁(AUTO-INC)\n它们都是标准的**表级锁**。\n- **意向锁**（Intention Locks）：表级别的锁。先提前声明一个意向，并获取表级别的意向锁（IS或IX），如果获取成功，才被允许对该表加行锁(S或X)。(即一个数据行加锁前必须先取得该表的意向锁)\n    - 意向锁(IS、IX)是InnoDB数据操作之前**自动加的**，不需要用户干预 \n    - 意义：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁\n- **自增锁**（AUTO-INC Locks）：针对自增列自增长的一个特殊的表级别锁\n    - `show variables like 'innodb_autoinc_lock_mode'`;\n    - 默认取值1，代表连续，事务未提交ID永久丢失\n\n\n#### 2.3 记录锁(Record) & 间隙锁(Gap) & 临键锁(Next-key)\n- **临键锁 Next-key locks**： \n    + **锁住记录+区间（左开右闭）**\n    + Innodb**默认**行锁算法\n    + 当sql执行按照索引进行数据的检索时,查询条件为范围查找（between and、<、>等）并有数 据命中则此时SQL语句加上的锁为Next-key locks，**锁住索引的记录+区间（左开右闭）**\n- **间隙锁 Gap locks**：\n    + **锁住数据不存在的区间（左开右开）**\n    + 当记录不存在，临键锁**退化**为Gap锁\n    + 当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，Gap只在RR事务隔离级别存在，**锁住索引不存在的区间（左开右开**） \n- **记录锁 Record locks**： \n    + **锁住具体的索引项**\n    + 唯一性(主键/唯一)索引，条件为**精准匹配，退化**成Record锁\n    + 当sql执行按照唯一性（Primary key、Unique key）索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks，**锁住具体的索引项**\n\n\n#### 2.4 死锁的产生与避免\n- 死锁\n    + 在InnoDB中，锁是逐步获得的，就造成了死锁的可能（2个或以上并发事务）\n    + 每个事务都持有锁（或者是已经在等待锁）; \n    + 每个事务都需要再继续持有锁；**事务之间产生加锁的循环等待**，形成死锁。\n- 死锁的产生与避免\n    1. 类似的业务逻辑以固定的**顺序访问**表和行。\n    2. 大事务拆小。大事务更倾向于死锁，如果业务允许，将**大事务拆小**。\n    3. 在同**一个事务**中，尽可能做到**一次锁定**所需要的所有资源，减少死锁概 率。\n    4. 降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择\n    5. 为表添加**合理的索引**。可以看到如果不走索引将会为表的每一行记录添 加上锁（或者说是表锁）\n\n\n\n### 3. MVCC(多版本并发控制)\nMultiversion concurrency control (多版本并发控制)：\n+ **MVCC** 就是 **同一份数据临时保留多版本的一种方式，进而实现并发控制**\n+ 是行级锁的变种，它在普通读情况下**避免了加锁操作**，因此**开销更低**。\n+ MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用**时间戳或者事务ID**去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。**读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据**。\n\n#### 3.1 MVCC逻辑流程\n+ 在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列\n    * `DB_TRX_ID`：数据行的版本号\n    * `DB_ROLL_PT`：删除版本号\n1. MVCC逻辑流程-插入\n    + 在插入数据的时候，会把全局事务ID记录到列`DB_TRX_ID`中去\n2. MVCC逻辑流程-删除\n    + 执行完删除SQL之后数据并没有被真正删除，而是对删除版本号(`DB_ROLL_PT`)做改变\n3. MVCC逻辑流程-修改\n    + 修改数据的时候 会先复制一条当前记录行数据，同时标记这条数据的数据行版本号为当前事务ID，最后把旧数据的删除版本号标记为新数据行版本号的值(即当前事务ID)。\n4. MVCC逻辑流程-查询\n    + 查找数据行版本号早于当前事务ID的数据行记录\n    + 也就是说，数据行的版本号要小于或等于 当前事务ID，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据\n    + 查找删除版本号要么为NULL，要么大于当前事务版本号的记录\n    + 这样确保查询出来的数据行记录在事务开启之前没有被删除\n\n> MySQL解决不可重复读和脏读并不是单纯利用 MVCC 机制来实现的。\n\n\n### 4. MySQL事务日志(Undo Log和Redo Log)\ninnodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。\nundo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：\n1. redo log通常是**物理日志**，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。\n2. undo用来回滚行记录到某个版本。undo log一般是**逻辑日志**，根据每行记录进行记录。\n\ns\n#### 4.1 Undo Log\n- Undo Log定义：\n    + undo意为取消，以撤销操作为目的，返回指定某个状态的操作\n    + undo log指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到一个地方 (Undo Log) \n- **UndoLog是为了实现事务的原子性而出现的产物**\n- Undo Log实现事务原子性：\n    + 事务处理过程中如果出现了错误或者用户执行了 ROLLBACK语句,Mysql可以利用Undo Log中的备份 将数据恢复到事务开始之前的状态\n- **UndoLog在Mysql innodb存储引擎中用来实现多版本并发控制**\n- Undo log实现多版本并发控制：\n    + 事务未提交之前，Undo保存了未提交之前的版本数据，Undo中的数据可作为数据旧版本快照供 其他并发事务进行快照读\n\n\n#### 4.2 当前读 & 快照读\n- 快照读：\n    + SQL读取的数据是快照版本，也就是历史版本，普通的SELECT就是快照读 innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改过的数据) 两部分组成 \n- 当前读：\n    + SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改 UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读\n\n\n#### 4.3 Redo Log\n- Undo Log定义： \n    - Redo，顾名思义就是重做。以恢复操作为目的，重现操作；\n    - Redo log指事务中操作的任何数据,将最新的数据备份到一个地方 (Redo Log)\n- Redo log的持久： \n    - 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo 中。具体 的落盘策略可以进行配置\n- **RedoLog是为了实现事务的持久性而出现的产物**\n- Redo Log实现事务持久性： \n    - 防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。\n- 一旦事务成功提交且数据持久化落盘之后，此时Redo log中的对应事务数据记录就失去了意义，所 以Redo log的写入是日志文件循环写入的\n\n\n### 附: 58同城数据库设计30条军规\n- 军规适用场景：并发量大、数据量大的互联网业务 \n- 解读：讲解原因，**解读比军规更重要** \n\n#### 一、基础规范\n1. 必须使用InnoDB存储引擎\n    - 解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高\n2. 必须使用UTF8字符集 UTF-8MB4\n    - 解读：万国码，无需转码，无乱码风险，节省空间\n3. 数据表、数据字段必须加入中文注释\n    - 解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的\n4. 禁止使用存储过程、视图、触发器、Event\n    - 解读：**高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务 层”**，并发量大的情况下，这些功能很可能将数据库拖死，**业务逻辑放到服务层具备更好的 扩展性，能够轻易实现“增机器就加性能”**。数据库擅长存储与索引，CPU计算还是上移吧\n5. 禁止存储大文件或者大照片\n    - 解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI 多好\n\n#### 二、命名规范\n6. 只允许**使用内网域名，而不是ip连接数据库**\n7. 线上环境、开发环境、测试环境数据库内网域名遵循命名规范\n    + 业务名称：xxx，线上环境：xxx.db，开发环境：xxx.rdb，测试环境：xxx.tdb \n    + 从库在名称后加-s标识，备库在名称后加-ss标识 线上从库：xxx-s.db 线上备库：xxx-sss.db\n8. 库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止 拼音英文混用\n9. 表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx\n\n#### 三、表设计规范\n10. 单实例表数目必须小于500\n11. 单表列数目必须小于30\n12. 表必须有主键，例如自增主键\n    - 解读：\n        1. 主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和 内存的使用\n        2. 主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类 型可以有效的减少索引的磁盘空间，提高索引的缓存效率\n        3. 无主键的表删除，在row模式的主从架构，会导致备库夯住\n13. 禁止使用外键，如果有外键完整性约束，需要应用程序控制\n    - 解读：**外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响 sql 的性能**，甚至会造成死锁。高并发情况下容易造成数据库性能，**大数据高并发业务场景 数据库使用以性能优先**\n\n#### 四、字段设计规范\n14. 必须把字段定义为NOT NULL并且提供默认值\n    - 解读： \n        1. null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化\n        2. null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条 件下，表中有较多空字段的时候，数据库的处理性能会降低很多\n        3. null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标 识\n        4. 对null 的处理时候，只能采用is null或is not null，而不能采用=、in、<、<>、!=、 not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记 录，查询结果就不会包含name为null值的记录\n15. 禁止使用TEXT、BLOB类型\n    - 解读：会浪费更多的磁盘和内存空间，**非必要的大量的大字段查询会淘汰掉热数据，导致内 存命中率急剧降低，影响数据库性能**\n16. 禁止使用小数存储货币\n    - 解读：使用整数吧，小数容易导致钱对不上\n17. 必须使用varchar(20)存储手机号\n    - 解读：\n        1. 涉及到区号或者国家代号，可能出现+-()\n        2. 手机号会去做数学运算么？\n        3. varchar可以支持模糊查询，例如：like“138%”\n18. 禁止使用ENUM，可使用TINYINT代替\n    - 解读：\n        1. 增加新的ENUM值要做DDL操作\n        2. ENUM的内部实际存储就是整数，你以为自己定义的是字符串？\n\n#### 五、索引设计规范\n19. 单表索引建议控制在5个以内\n20. 单索引字段数不允许超过5个\n    - 解读：字段超过5个时，实际已经起不到有效过滤数据的作用了\n21. 禁止在更新十分频繁、区分度不高的属性上建立索引\n    - 解读：\n        1. 更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能\n        2. “性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性 能与全表扫描类似\n22. 建立组合索引，必须把区分度高的字段放在前面\n    - 解读：能够更加有效的过滤数据\n\n#### 六、SQL使用规范\n23. 禁止使用SELECT *，只获取必要的字段，需要显示说明列属性\n    - 解读：\n        1. 读取不需要的列会增加CPU、IO、NET消耗\n        2. 不能有效的利用覆盖索引\n24. 禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性\n    - 解读：容易在增加或者删除字段后出现程序BUG\n25. 禁止使用属性隐式转换\n    - 解读：SELECT uid FROM t_user WHERE phone=13812345678 **会导致全表扫描**，而不 能命中phone索引\n26. 禁止在WHERE条件的属性上使用函数或者表达式\n    - 解读：SELECT uid FROM t_user WHERE from_unixtime(day)>='2017-02-15' 会导致全 表扫描 正确的写法是：SELECT uid FROM t_user WHERE day>= unix_timestamp('2017-02-15 00:00:00')\n27. 禁止负向查询，以及%开头的模糊查询\n    - 解读：\n        1. 负向查询条件：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等，会导致全表扫描\n        2. %开头的模糊查询，会导致全表扫描\n28. 禁止大表使用JOIN查询，禁止大表使用子查询\n    - 解读：**会产生临时表**，消耗较多内存与CPU，极大影响数据库性能\n29. 禁止使用OR条件，必须改为IN查询\n    - 解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费 更多的CPU帮助实施查询优化呢？\n30. 应用程序必须捕获SQL异常，并有相应处理\n\n","source":"_posts/【数据库优化】MySQL事务处理与并发控制.md","raw":"---\ntitle: 【数据库优化】MySQL事务处理与并发控制\ndate: 2019-09-07 23:31:48\ntags: [数据库, 后端开发]\ncategories: 数据库\n---\n\n\n### 1. MySQL事务\n1. 事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；<!-- more -->\n2. 事务的特性(ACID)：\n    + **原子性**（Atomicity，或称不可分割性）：最小的工作单元，整个工作单元要么一起提交成功，要么全部失败回滚\n    + **一致性**（Consistency）：事务中操作的数据及状态改变是一致的，即写入资料的结果必须完全符合预设的规则， 不会因为出现系统意外等原因导致状态的不一致\n    + **隔离性**（Isolation，又称独立性）：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）\n    + **持久性**（Durability）：事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失\n3. 事务的开启与提交模式\n    + 若参数autocommit=0，自动开启**手动提交**\n    + 若参数autocommit=1（系统默认值），又分为两种状态：\n        + **自动开启自动提交**：用户的每一个操作都是一个完整的事务周期。\n        + **手动开启手动提交**：从用户执行`start transaction`命令到用户执行`commit`命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。\n            * `begin` 或者 `start transaction`   -- 开启事务\n            * `commit` 或者 `rollback`           -- 事务提交或回滚\n    \n\n####  1.1 事务的隔离级别\n- 查看/设置隔离级别\n    + 查看：`SELECT @@tx_isolation`\n    + 设置：`set tx_isolation='xxx'`\n1.  **读未提交**（Read Uncommitted）\n    + 事务未提交对其他事务也是可见的，脏读（dirty read）\n2. **读提交**（Read Committed）--解决脏读问题 \n    + 一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读（nonrepeatable read）\n3. **可重复读**（Repeatable Read）--解决不可重复读问题\n    + 在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未定义解决幻读的问题\n4. **串行化**（Serializable）--解决所有问题\n    + 最高的隔离级别，通过强制事务的串行执行，但是会导致大量超时以及锁争用问题\n\n> Mysql默认采用`REPEATABLE_READ`隔离级别，Oracle默认采用`READ_COMMITTED`隔离级别。\n> 事务的隔离级别的实现：锁、MVCC（多版本并发控制 Multiversion Currency Control）。\n\n\n#### 1.2 事务的七大传播行为\nSpring在TransactionDefinition接口中规定了**7种**类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。\n- 事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时**事务如何传播**。\n    + `@Transactional(propagation = Propagation.REQUIRED)`\n1. 第一类：运行在同一个事务\n    + **`REQUIRED`**（required）：默认，支持当前事务，如果当前没有事务，就新建一个事务。\n    + `SUPPORTS`（supports）：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)\n    + `MANDATORY`（mandatory）：支持当前事务，如果当前没有事务，就抛出异常\n2. 第二类：运行在不同事务\n    + **`REQUIRES_NEW`**（requires new）：新建事务，如果当前存在事务，把当前事务挂起\n    + `NOT_SUPPORTED`(not supported)：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\n    + `NEVER`（never）：以非事务方式执行，如果当前存在事务，则抛出异常\n3. 第三类：嵌套执行--即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态\n    + **`NESTED`**（nested）：如果当前事务存在，则嵌套事务执行\n\n\n\n### 2. 锁\n锁是用于管理不同事务对共享资源的并发访问，InnoDB存储引擎支持行锁和表锁（InnoDB表锁是另类的行锁）\n- InnoDB行锁\n    + 共享锁（读锁）：Shared Locks\n    + 排它锁（写锁）：Exclusive Locks\n- InnoDB表锁\n    + 意向锁共享锁（IS）：Intention Shared Locks\n    + 意向锁排它锁（IX）：Intention Exclusive Locks\n    + 自增锁：AUTO-INC Locks\n- 行锁的算法\n    + 记录锁 Record Locks\n    + 间隙锁 Gap Locks\n    + 临键锁 Next-key Locks\n\n\n#### 2.1 共享锁(Shared) & 排他锁(Exclusive)\n它们都是标准的**行级锁**。\n- 共享锁（S锁）：读锁，读锁允许多个连接可以同一时刻**并发的读**取同一资源,互不干扰，但是只能读不能修改;\n    + 加锁： `select * from users WHERE id=1 `**`LOCK IN SHARE MODE`**; \n    + 解锁：**`commit`**或**`rollback`**\n- 排他锁（X锁）：写锁，一个写锁会**阻塞**其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。\n    + 加锁： `select * from users WHERE id=1 `**`FOR UPDATE`**; \n    + **`delete/update/insert 默认上 X 锁`**\n    + 解锁：**`commit`**或**`rollback`**\n\n> 注意：所谓共享锁、排他锁其实均是**锁机制本身的策略**，通过这两种策略对锁做了区分。\n- InnoDB的行锁是通过**给索引上的索引项加锁**来实现的。\n- 只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）\n\n\n#### 2.2 意向锁(Intention) & 自增锁(AUTO-INC)\n它们都是标准的**表级锁**。\n- **意向锁**（Intention Locks）：表级别的锁。先提前声明一个意向，并获取表级别的意向锁（IS或IX），如果获取成功，才被允许对该表加行锁(S或X)。(即一个数据行加锁前必须先取得该表的意向锁)\n    - 意向锁(IS、IX)是InnoDB数据操作之前**自动加的**，不需要用户干预 \n    - 意义：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁\n- **自增锁**（AUTO-INC Locks）：针对自增列自增长的一个特殊的表级别锁\n    - `show variables like 'innodb_autoinc_lock_mode'`;\n    - 默认取值1，代表连续，事务未提交ID永久丢失\n\n\n#### 2.3 记录锁(Record) & 间隙锁(Gap) & 临键锁(Next-key)\n- **临键锁 Next-key locks**： \n    + **锁住记录+区间（左开右闭）**\n    + Innodb**默认**行锁算法\n    + 当sql执行按照索引进行数据的检索时,查询条件为范围查找（between and、<、>等）并有数 据命中则此时SQL语句加上的锁为Next-key locks，**锁住索引的记录+区间（左开右闭）**\n- **间隙锁 Gap locks**：\n    + **锁住数据不存在的区间（左开右开）**\n    + 当记录不存在，临键锁**退化**为Gap锁\n    + 当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，Gap只在RR事务隔离级别存在，**锁住索引不存在的区间（左开右开**） \n- **记录锁 Record locks**： \n    + **锁住具体的索引项**\n    + 唯一性(主键/唯一)索引，条件为**精准匹配，退化**成Record锁\n    + 当sql执行按照唯一性（Primary key、Unique key）索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks，**锁住具体的索引项**\n\n\n#### 2.4 死锁的产生与避免\n- 死锁\n    + 在InnoDB中，锁是逐步获得的，就造成了死锁的可能（2个或以上并发事务）\n    + 每个事务都持有锁（或者是已经在等待锁）; \n    + 每个事务都需要再继续持有锁；**事务之间产生加锁的循环等待**，形成死锁。\n- 死锁的产生与避免\n    1. 类似的业务逻辑以固定的**顺序访问**表和行。\n    2. 大事务拆小。大事务更倾向于死锁，如果业务允许，将**大事务拆小**。\n    3. 在同**一个事务**中，尽可能做到**一次锁定**所需要的所有资源，减少死锁概 率。\n    4. 降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择\n    5. 为表添加**合理的索引**。可以看到如果不走索引将会为表的每一行记录添 加上锁（或者说是表锁）\n\n\n\n### 3. MVCC(多版本并发控制)\nMultiversion concurrency control (多版本并发控制)：\n+ **MVCC** 就是 **同一份数据临时保留多版本的一种方式，进而实现并发控制**\n+ 是行级锁的变种，它在普通读情况下**避免了加锁操作**，因此**开销更低**。\n+ MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用**时间戳或者事务ID**去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。**读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据**。\n\n#### 3.1 MVCC逻辑流程\n+ 在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列\n    * `DB_TRX_ID`：数据行的版本号\n    * `DB_ROLL_PT`：删除版本号\n1. MVCC逻辑流程-插入\n    + 在插入数据的时候，会把全局事务ID记录到列`DB_TRX_ID`中去\n2. MVCC逻辑流程-删除\n    + 执行完删除SQL之后数据并没有被真正删除，而是对删除版本号(`DB_ROLL_PT`)做改变\n3. MVCC逻辑流程-修改\n    + 修改数据的时候 会先复制一条当前记录行数据，同时标记这条数据的数据行版本号为当前事务ID，最后把旧数据的删除版本号标记为新数据行版本号的值(即当前事务ID)。\n4. MVCC逻辑流程-查询\n    + 查找数据行版本号早于当前事务ID的数据行记录\n    + 也就是说，数据行的版本号要小于或等于 当前事务ID，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据\n    + 查找删除版本号要么为NULL，要么大于当前事务版本号的记录\n    + 这样确保查询出来的数据行记录在事务开启之前没有被删除\n\n> MySQL解决不可重复读和脏读并不是单纯利用 MVCC 机制来实现的。\n\n\n### 4. MySQL事务日志(Undo Log和Redo Log)\ninnodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。\nundo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：\n1. redo log通常是**物理日志**，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。\n2. undo用来回滚行记录到某个版本。undo log一般是**逻辑日志**，根据每行记录进行记录。\n\ns\n#### 4.1 Undo Log\n- Undo Log定义：\n    + undo意为取消，以撤销操作为目的，返回指定某个状态的操作\n    + undo log指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到一个地方 (Undo Log) \n- **UndoLog是为了实现事务的原子性而出现的产物**\n- Undo Log实现事务原子性：\n    + 事务处理过程中如果出现了错误或者用户执行了 ROLLBACK语句,Mysql可以利用Undo Log中的备份 将数据恢复到事务开始之前的状态\n- **UndoLog在Mysql innodb存储引擎中用来实现多版本并发控制**\n- Undo log实现多版本并发控制：\n    + 事务未提交之前，Undo保存了未提交之前的版本数据，Undo中的数据可作为数据旧版本快照供 其他并发事务进行快照读\n\n\n#### 4.2 当前读 & 快照读\n- 快照读：\n    + SQL读取的数据是快照版本，也就是历史版本，普通的SELECT就是快照读 innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改过的数据) 两部分组成 \n- 当前读：\n    + SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改 UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读\n\n\n#### 4.3 Redo Log\n- Undo Log定义： \n    - Redo，顾名思义就是重做。以恢复操作为目的，重现操作；\n    - Redo log指事务中操作的任何数据,将最新的数据备份到一个地方 (Redo Log)\n- Redo log的持久： \n    - 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo 中。具体 的落盘策略可以进行配置\n- **RedoLog是为了实现事务的持久性而出现的产物**\n- Redo Log实现事务持久性： \n    - 防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。\n- 一旦事务成功提交且数据持久化落盘之后，此时Redo log中的对应事务数据记录就失去了意义，所 以Redo log的写入是日志文件循环写入的\n\n\n### 附: 58同城数据库设计30条军规\n- 军规适用场景：并发量大、数据量大的互联网业务 \n- 解读：讲解原因，**解读比军规更重要** \n\n#### 一、基础规范\n1. 必须使用InnoDB存储引擎\n    - 解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高\n2. 必须使用UTF8字符集 UTF-8MB4\n    - 解读：万国码，无需转码，无乱码风险，节省空间\n3. 数据表、数据字段必须加入中文注释\n    - 解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的\n4. 禁止使用存储过程、视图、触发器、Event\n    - 解读：**高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务 层”**，并发量大的情况下，这些功能很可能将数据库拖死，**业务逻辑放到服务层具备更好的 扩展性，能够轻易实现“增机器就加性能”**。数据库擅长存储与索引，CPU计算还是上移吧\n5. 禁止存储大文件或者大照片\n    - 解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI 多好\n\n#### 二、命名规范\n6. 只允许**使用内网域名，而不是ip连接数据库**\n7. 线上环境、开发环境、测试环境数据库内网域名遵循命名规范\n    + 业务名称：xxx，线上环境：xxx.db，开发环境：xxx.rdb，测试环境：xxx.tdb \n    + 从库在名称后加-s标识，备库在名称后加-ss标识 线上从库：xxx-s.db 线上备库：xxx-sss.db\n8. 库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止 拼音英文混用\n9. 表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx\n\n#### 三、表设计规范\n10. 单实例表数目必须小于500\n11. 单表列数目必须小于30\n12. 表必须有主键，例如自增主键\n    - 解读：\n        1. 主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和 内存的使用\n        2. 主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类 型可以有效的减少索引的磁盘空间，提高索引的缓存效率\n        3. 无主键的表删除，在row模式的主从架构，会导致备库夯住\n13. 禁止使用外键，如果有外键完整性约束，需要应用程序控制\n    - 解读：**外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响 sql 的性能**，甚至会造成死锁。高并发情况下容易造成数据库性能，**大数据高并发业务场景 数据库使用以性能优先**\n\n#### 四、字段设计规范\n14. 必须把字段定义为NOT NULL并且提供默认值\n    - 解读： \n        1. null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化\n        2. null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条 件下，表中有较多空字段的时候，数据库的处理性能会降低很多\n        3. null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标 识\n        4. 对null 的处理时候，只能采用is null或is not null，而不能采用=、in、<、<>、!=、 not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记 录，查询结果就不会包含name为null值的记录\n15. 禁止使用TEXT、BLOB类型\n    - 解读：会浪费更多的磁盘和内存空间，**非必要的大量的大字段查询会淘汰掉热数据，导致内 存命中率急剧降低，影响数据库性能**\n16. 禁止使用小数存储货币\n    - 解读：使用整数吧，小数容易导致钱对不上\n17. 必须使用varchar(20)存储手机号\n    - 解读：\n        1. 涉及到区号或者国家代号，可能出现+-()\n        2. 手机号会去做数学运算么？\n        3. varchar可以支持模糊查询，例如：like“138%”\n18. 禁止使用ENUM，可使用TINYINT代替\n    - 解读：\n        1. 增加新的ENUM值要做DDL操作\n        2. ENUM的内部实际存储就是整数，你以为自己定义的是字符串？\n\n#### 五、索引设计规范\n19. 单表索引建议控制在5个以内\n20. 单索引字段数不允许超过5个\n    - 解读：字段超过5个时，实际已经起不到有效过滤数据的作用了\n21. 禁止在更新十分频繁、区分度不高的属性上建立索引\n    - 解读：\n        1. 更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能\n        2. “性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性 能与全表扫描类似\n22. 建立组合索引，必须把区分度高的字段放在前面\n    - 解读：能够更加有效的过滤数据\n\n#### 六、SQL使用规范\n23. 禁止使用SELECT *，只获取必要的字段，需要显示说明列属性\n    - 解读：\n        1. 读取不需要的列会增加CPU、IO、NET消耗\n        2. 不能有效的利用覆盖索引\n24. 禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性\n    - 解读：容易在增加或者删除字段后出现程序BUG\n25. 禁止使用属性隐式转换\n    - 解读：SELECT uid FROM t_user WHERE phone=13812345678 **会导致全表扫描**，而不 能命中phone索引\n26. 禁止在WHERE条件的属性上使用函数或者表达式\n    - 解读：SELECT uid FROM t_user WHERE from_unixtime(day)>='2017-02-15' 会导致全 表扫描 正确的写法是：SELECT uid FROM t_user WHERE day>= unix_timestamp('2017-02-15 00:00:00')\n27. 禁止负向查询，以及%开头的模糊查询\n    - 解读：\n        1. 负向查询条件：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等，会导致全表扫描\n        2. %开头的模糊查询，会导致全表扫描\n28. 禁止大表使用JOIN查询，禁止大表使用子查询\n    - 解读：**会产生临时表**，消耗较多内存与CPU，极大影响数据库性能\n29. 禁止使用OR条件，必须改为IN查询\n    - 解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费 更多的CPU帮助实施查询优化呢？\n30. 应用程序必须捕获SQL异常，并有相应处理\n\n","slug":"【数据库优化】MySQL事务处理与并发控制","published":1,"updated":"2021-12-12T02:50:23.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6wl0022vcue6flldowv","content":"<h3 id=\"1-MySQL事务\"><a href=\"#1-MySQL事务\" class=\"headerlink\" title=\"1. MySQL事务\"></a>1. MySQL事务</h3><ol>\n<li>事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；<span id=\"more\"></span></li>\n<li>事务的特性(ACID)：<ul>\n<li><strong>原子性</strong>（Atomicity，或称不可分割性）：最小的工作单元，整个工作单元要么一起提交成功，要么全部失败回滚</li>\n<li><strong>一致性</strong>（Consistency）：事务中操作的数据及状态改变是一致的，即写入资料的结果必须完全符合预设的规则， 不会因为出现系统意外等原因导致状态的不一致</li>\n<li><strong>隔离性</strong>（Isolation，又称独立性）：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）</li>\n<li><strong>持久性</strong>（Durability）：事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失</li>\n</ul>\n</li>\n<li>事务的开启与提交模式<ul>\n<li>若参数autocommit=0，自动开启<strong>手动提交</strong></li>\n<li>若参数autocommit=1（系统默认值），又分为两种状态：<ul>\n<li><strong>自动开启自动提交</strong>：用户的每一个操作都是一个完整的事务周期。</li>\n<li><strong>手动开启手动提交</strong>：从用户执行<code>start transaction</code>命令到用户执行<code>commit</code>命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。<ul>\n<li><code>begin</code> 或者 <code>start transaction</code>   – 开启事务</li>\n<li><code>commit</code> 或者 <code>rollback</code>           – 事务提交或回滚</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-1-事务的隔离级别\"><a href=\"#1-1-事务的隔离级别\" class=\"headerlink\" title=\"1.1 事务的隔离级别\"></a>1.1 事务的隔离级别</h4><ul>\n<li>查看/设置隔离级别<ul>\n<li>查看：<code>SELECT @@tx_isolation</code></li>\n<li>设置：<code>set tx_isolation=&#39;xxx&#39;</code></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><strong>读未提交</strong>（Read Uncommitted）<ul>\n<li>事务未提交对其他事务也是可见的，脏读（dirty read）</li>\n</ul>\n</li>\n<li><strong>读提交</strong>（Read Committed）–解决脏读问题 <ul>\n<li>一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读（nonrepeatable read）</li>\n</ul>\n</li>\n<li><strong>可重复读</strong>（Repeatable Read）–解决不可重复读问题<ul>\n<li>在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未定义解决幻读的问题</li>\n</ul>\n</li>\n<li><strong>串行化</strong>（Serializable）–解决所有问题<ul>\n<li>最高的隔离级别，通过强制事务的串行执行，但是会导致大量超时以及锁争用问题</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别。<br>事务的隔离级别的实现：锁、MVCC（多版本并发控制 Multiversion Currency Control）。</p>\n</blockquote>\n<h4 id=\"1-2-事务的七大传播行为\"><a href=\"#1-2-事务的七大传播行为\" class=\"headerlink\" title=\"1.2 事务的七大传播行为\"></a>1.2 事务的七大传播行为</h4><p>Spring在TransactionDefinition接口中规定了<strong>7种</strong>类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。</p>\n<ul>\n<li>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时<strong>事务如何传播</strong>。<ul>\n<li><code>@Transactional(propagation = Propagation.REQUIRED)</code></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>第一类：运行在同一个事务<ul>\n<li>**<code>REQUIRED</code>**（required）：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li>\n<li><code>SUPPORTS</code>（supports）：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li>\n<li><code>MANDATORY</code>（mandatory）：支持当前事务，如果当前没有事务，就抛出异常</li>\n</ul>\n</li>\n<li>第二类：运行在不同事务<ul>\n<li>**<code>REQUIRES_NEW</code>**（requires new）：新建事务，如果当前存在事务，把当前事务挂起</li>\n<li><code>NOT_SUPPORTED</code>(not supported)：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>\n<li><code>NEVER</code>（never）：以非事务方式执行，如果当前存在事务，则抛出异常</li>\n</ul>\n</li>\n<li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul>\n<li>**<code>NESTED</code>**（nested）：如果当前事务存在，则嵌套事务执行</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-锁\"><a href=\"#2-锁\" class=\"headerlink\" title=\"2. 锁\"></a>2. 锁</h3><p>锁是用于管理不同事务对共享资源的并发访问，InnoDB存储引擎支持行锁和表锁（InnoDB表锁是另类的行锁）</p>\n<ul>\n<li>InnoDB行锁<ul>\n<li>共享锁（读锁）：Shared Locks</li>\n<li>排它锁（写锁）：Exclusive Locks</li>\n</ul>\n</li>\n<li>InnoDB表锁<ul>\n<li>意向锁共享锁（IS）：Intention Shared Locks</li>\n<li>意向锁排它锁（IX）：Intention Exclusive Locks</li>\n<li>自增锁：AUTO-INC Locks</li>\n</ul>\n</li>\n<li>行锁的算法<ul>\n<li>记录锁 Record Locks</li>\n<li>间隙锁 Gap Locks</li>\n<li>临键锁 Next-key Locks</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-1-共享锁-Shared-amp-排他锁-Exclusive\"><a href=\"#2-1-共享锁-Shared-amp-排他锁-Exclusive\" class=\"headerlink\" title=\"2.1 共享锁(Shared) &amp; 排他锁(Exclusive)\"></a>2.1 共享锁(Shared) &amp; 排他锁(Exclusive)</h4><p>它们都是标准的<strong>行级锁</strong>。</p>\n<ul>\n<li>共享锁（S锁）：读锁，读锁允许多个连接可以同一时刻<strong>并发的读</strong>取同一资源,互不干扰，但是只能读不能修改;<ul>\n<li>加锁： <code>select * from users WHERE id=1 </code><strong><code>LOCK IN SHARE MODE</code></strong>; </li>\n<li>解锁：**<code>commit</code><strong>或</strong><code>rollback</code>**</li>\n</ul>\n</li>\n<li>排他锁（X锁）：写锁，一个写锁会<strong>阻塞</strong>其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。<ul>\n<li>加锁： <code>select * from users WHERE id=1 </code><strong><code>FOR UPDATE</code></strong>; </li>\n<li><strong><code>delete/update/insert 默认上 X 锁</code></strong></li>\n<li>解锁：**<code>commit</code><strong>或</strong><code>rollback</code>**</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：所谓共享锁、排他锁其实均是<strong>锁机制本身的策略</strong>，通过这两种策略对锁做了区分。</p>\n</blockquote>\n<ul>\n<li>InnoDB的行锁是通过<strong>给索引上的索引项加锁</strong>来实现的。</li>\n<li>只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）</li>\n</ul>\n<h4 id=\"2-2-意向锁-Intention-amp-自增锁-AUTO-INC\"><a href=\"#2-2-意向锁-Intention-amp-自增锁-AUTO-INC\" class=\"headerlink\" title=\"2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)\"></a>2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)</h4><p>它们都是标准的<strong>表级锁</strong>。</p>\n<ul>\n<li><strong>意向锁</strong>（Intention Locks）：表级别的锁。先提前声明一个意向，并获取表级别的意向锁（IS或IX），如果获取成功，才被允许对该表加行锁(S或X)。(即一个数据行加锁前必须先取得该表的意向锁)<ul>\n<li>意向锁(IS、IX)是InnoDB数据操作之前<strong>自动加的</strong>，不需要用户干预 </li>\n<li>意义：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</li>\n</ul>\n</li>\n<li><strong>自增锁</strong>（AUTO-INC Locks）：针对自增列自增长的一个特殊的表级别锁<ul>\n<li><code>show variables like &#39;innodb_autoinc_lock_mode&#39;</code>;</li>\n<li>默认取值1，代表连续，事务未提交ID永久丢失</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key\"><a href=\"#2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key\" class=\"headerlink\" title=\"2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)\"></a>2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)</h4><ul>\n<li><strong>临键锁 Next-key locks</strong>： <ul>\n<li><strong>锁住记录+区间（左开右闭）</strong></li>\n<li>Innodb<strong>默认</strong>行锁算法</li>\n<li>当sql执行按照索引进行数据的检索时,查询条件为范围查找（between and、&lt;、&gt;等）并有数 据命中则此时SQL语句加上的锁为Next-key locks，<strong>锁住索引的记录+区间（左开右闭）</strong></li>\n</ul>\n</li>\n<li><strong>间隙锁 Gap locks</strong>：<ul>\n<li><strong>锁住数据不存在的区间（左开右开）</strong></li>\n<li>当记录不存在，临键锁<strong>退化</strong>为Gap锁</li>\n<li>当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，Gap只在RR事务隔离级别存在，<strong>锁住索引不存在的区间（左开右开</strong>） </li>\n</ul>\n</li>\n<li><strong>记录锁 Record locks</strong>： <ul>\n<li><strong>锁住具体的索引项</strong></li>\n<li>唯一性(主键/唯一)索引，条件为<strong>精准匹配，退化</strong>成Record锁</li>\n<li>当sql执行按照唯一性（Primary key、Unique key）索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks，<strong>锁住具体的索引项</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-4-死锁的产生与避免\"><a href=\"#2-4-死锁的产生与避免\" class=\"headerlink\" title=\"2.4 死锁的产生与避免\"></a>2.4 死锁的产生与避免</h4><ul>\n<li>死锁<ul>\n<li>在InnoDB中，锁是逐步获得的，就造成了死锁的可能（2个或以上并发事务）</li>\n<li>每个事务都持有锁（或者是已经在等待锁）; </li>\n<li>每个事务都需要再继续持有锁；<strong>事务之间产生加锁的循环等待</strong>，形成死锁。</li>\n</ul>\n</li>\n<li>死锁的产生与避免<ol>\n<li>类似的业务逻辑以固定的<strong>顺序访问</strong>表和行。</li>\n<li>大事务拆小。大事务更倾向于死锁，如果业务允许，将<strong>大事务拆小</strong>。</li>\n<li>在同<strong>一个事务</strong>中，尽可能做到<strong>一次锁定</strong>所需要的所有资源，减少死锁概 率。</li>\n<li>降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择</li>\n<li>为表添加<strong>合理的索引</strong>。可以看到如果不走索引将会为表的每一行记录添 加上锁（或者说是表锁）</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"3-MVCC-多版本并发控制\"><a href=\"#3-MVCC-多版本并发控制\" class=\"headerlink\" title=\"3. MVCC(多版本并发控制)\"></a>3. MVCC(多版本并发控制)</h3><p>Multiversion concurrency control (多版本并发控制)：</p>\n<ul>\n<li><strong>MVCC</strong> 就是 <strong>同一份数据临时保留多版本的一种方式，进而实现并发控制</strong></li>\n<li>是行级锁的变种，它在普通读情况下<strong>避免了加锁操作</strong>，因此<strong>开销更低</strong>。</li>\n<li>MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用<strong>时间戳或者事务ID</strong>去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。<strong>读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据</strong>。</li>\n</ul>\n<h4 id=\"3-1-MVCC逻辑流程\"><a href=\"#3-1-MVCC逻辑流程\" class=\"headerlink\" title=\"3.1 MVCC逻辑流程\"></a>3.1 MVCC逻辑流程</h4><ul>\n<li>在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列<ul>\n<li><code>DB_TRX_ID</code>：数据行的版本号</li>\n<li><code>DB_ROLL_PT</code>：删除版本号</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>MVCC逻辑流程-插入<ul>\n<li>在插入数据的时候，会把全局事务ID记录到列<code>DB_TRX_ID</code>中去</li>\n</ul>\n</li>\n<li>MVCC逻辑流程-删除<ul>\n<li>执行完删除SQL之后数据并没有被真正删除，而是对删除版本号(<code>DB_ROLL_PT</code>)做改变</li>\n</ul>\n</li>\n<li>MVCC逻辑流程-修改<ul>\n<li>修改数据的时候 会先复制一条当前记录行数据，同时标记这条数据的数据行版本号为当前事务ID，最后把旧数据的删除版本号标记为新数据行版本号的值(即当前事务ID)。</li>\n</ul>\n</li>\n<li>MVCC逻辑流程-查询<ul>\n<li>查找数据行版本号早于当前事务ID的数据行记录</li>\n<li>也就是说，数据行的版本号要小于或等于 当前事务ID，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据</li>\n<li>查找删除版本号要么为NULL，要么大于当前事务版本号的记录</li>\n<li>这样确保查询出来的数据行记录在事务开启之前没有被删除</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>MySQL解决不可重复读和脏读并不是单纯利用 MVCC 机制来实现的。</p>\n</blockquote>\n<h3 id=\"4-MySQL事务日志-Undo-Log和Redo-Log\"><a href=\"#4-MySQL事务日志-Undo-Log和Redo-Log\" class=\"headerlink\" title=\"4. MySQL事务日志(Undo Log和Redo Log)\"></a>4. MySQL事务日志(Undo Log和Redo Log)</h3><p>innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。<br>undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：</p>\n<ol>\n<li>redo log通常是<strong>物理日志</strong>，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</li>\n<li>undo用来回滚行记录到某个版本。undo log一般是<strong>逻辑日志</strong>，根据每行记录进行记录。</li>\n</ol>\n<p>s</p>\n<h4 id=\"4-1-Undo-Log\"><a href=\"#4-1-Undo-Log\" class=\"headerlink\" title=\"4.1 Undo Log\"></a>4.1 Undo Log</h4><ul>\n<li>Undo Log定义：<ul>\n<li>undo意为取消，以撤销操作为目的，返回指定某个状态的操作</li>\n<li>undo log指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到一个地方 (Undo Log) </li>\n</ul>\n</li>\n<li><strong>UndoLog是为了实现事务的原子性而出现的产物</strong></li>\n<li>Undo Log实现事务原子性：<ul>\n<li>事务处理过程中如果出现了错误或者用户执行了 ROLLBACK语句,Mysql可以利用Undo Log中的备份 将数据恢复到事务开始之前的状态</li>\n</ul>\n</li>\n<li><strong>UndoLog在Mysql innodb存储引擎中用来实现多版本并发控制</strong></li>\n<li>Undo log实现多版本并发控制：<ul>\n<li>事务未提交之前，Undo保存了未提交之前的版本数据，Undo中的数据可作为数据旧版本快照供 其他并发事务进行快照读</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-2-当前读-amp-快照读\"><a href=\"#4-2-当前读-amp-快照读\" class=\"headerlink\" title=\"4.2 当前读 &amp; 快照读\"></a>4.2 当前读 &amp; 快照读</h4><ul>\n<li>快照读：<ul>\n<li>SQL读取的数据是快照版本，也就是历史版本，普通的SELECT就是快照读 innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改过的数据) 两部分组成 </li>\n</ul>\n</li>\n<li>当前读：<ul>\n<li>SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改 UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-3-Redo-Log\"><a href=\"#4-3-Redo-Log\" class=\"headerlink\" title=\"4.3 Redo Log\"></a>4.3 Redo Log</h4><ul>\n<li>Undo Log定义： <ul>\n<li>Redo，顾名思义就是重做。以恢复操作为目的，重现操作；</li>\n<li>Redo log指事务中操作的任何数据,将最新的数据备份到一个地方 (Redo Log)</li>\n</ul>\n</li>\n<li>Redo log的持久： <ul>\n<li>不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo 中。具体 的落盘策略可以进行配置</li>\n</ul>\n</li>\n<li><strong>RedoLog是为了实现事务的持久性而出现的产物</strong></li>\n<li>Redo Log实现事务持久性： <ul>\n<li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。</li>\n</ul>\n</li>\n<li>一旦事务成功提交且数据持久化落盘之后，此时Redo log中的对应事务数据记录就失去了意义，所 以Redo log的写入是日志文件循环写入的</li>\n</ul>\n<h3 id=\"附-58同城数据库设计30条军规\"><a href=\"#附-58同城数据库设计30条军规\" class=\"headerlink\" title=\"附: 58同城数据库设计30条军规\"></a>附: 58同城数据库设计30条军规</h3><ul>\n<li>军规适用场景：并发量大、数据量大的互联网业务 </li>\n<li>解读：讲解原因，<strong>解读比军规更重要</strong> </li>\n</ul>\n<h4 id=\"一、基础规范\"><a href=\"#一、基础规范\" class=\"headerlink\" title=\"一、基础规范\"></a>一、基础规范</h4><ol>\n<li>必须使用InnoDB存储引擎<ul>\n<li>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</li>\n</ul>\n</li>\n<li>必须使用UTF8字符集 UTF-8MB4<ul>\n<li>解读：万国码，无需转码，无乱码风险，节省空间</li>\n</ul>\n</li>\n<li>数据表、数据字段必须加入中文注释<ul>\n<li>解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的</li>\n</ul>\n</li>\n<li>禁止使用存储过程、视图、触发器、Event<ul>\n<li>解读：<strong>高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务 层”</strong>，并发量大的情况下，这些功能很可能将数据库拖死，<strong>业务逻辑放到服务层具备更好的 扩展性，能够轻易实现“增机器就加性能”</strong>。数据库擅长存储与索引，CPU计算还是上移吧</li>\n</ul>\n</li>\n<li>禁止存储大文件或者大照片<ul>\n<li>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI 多好</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二、命名规范\"><a href=\"#二、命名规范\" class=\"headerlink\" title=\"二、命名规范\"></a>二、命名规范</h4><ol start=\"6\">\n<li>只允许<strong>使用内网域名，而不是ip连接数据库</strong></li>\n<li>线上环境、开发环境、测试环境数据库内网域名遵循命名规范<ul>\n<li>业务名称：xxx，线上环境：xxx.db，开发环境：xxx.rdb，测试环境：xxx.tdb </li>\n<li>从库在名称后加-s标识，备库在名称后加-ss标识 线上从库：xxx-s.db 线上备库：xxx-sss.db</li>\n</ul>\n</li>\n<li>库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止 拼音英文混用</li>\n<li>表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</li>\n</ol>\n<h4 id=\"三、表设计规范\"><a href=\"#三、表设计规范\" class=\"headerlink\" title=\"三、表设计规范\"></a>三、表设计规范</h4><ol start=\"10\">\n<li>单实例表数目必须小于500</li>\n<li>单表列数目必须小于30</li>\n<li>表必须有主键，例如自增主键<ul>\n<li>解读：<ol>\n<li>主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和 内存的使用</li>\n<li>主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类 型可以有效的减少索引的磁盘空间，提高索引的缓存效率</li>\n<li>无主键的表删除，在row模式的主从架构，会导致备库夯住</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>禁止使用外键，如果有外键完整性约束，需要应用程序控制<ul>\n<li>解读：<strong>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响 sql 的性能</strong>，甚至会造成死锁。高并发情况下容易造成数据库性能，<strong>大数据高并发业务场景 数据库使用以性能优先</strong></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"四、字段设计规范\"><a href=\"#四、字段设计规范\" class=\"headerlink\" title=\"四、字段设计规范\"></a>四、字段设计规范</h4><ol start=\"14\">\n<li>必须把字段定义为NOT NULL并且提供默认值<ul>\n<li>解读： <ol>\n<li>null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化</li>\n<li>null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条 件下，表中有较多空字段的时候，数据库的处理性能会降低很多</li>\n<li>null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标 识</li>\n<li>对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、 not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记 录，查询结果就不会包含name为null值的记录</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>禁止使用TEXT、BLOB类型<ul>\n<li>解读：会浪费更多的磁盘和内存空间，<strong>非必要的大量的大字段查询会淘汰掉热数据，导致内 存命中率急剧降低，影响数据库性能</strong></li>\n</ul>\n</li>\n<li>禁止使用小数存储货币<ul>\n<li>解读：使用整数吧，小数容易导致钱对不上</li>\n</ul>\n</li>\n<li>必须使用varchar(20)存储手机号<ul>\n<li>解读：<ol>\n<li>涉及到区号或者国家代号，可能出现+-()</li>\n<li>手机号会去做数学运算么？</li>\n<li>varchar可以支持模糊查询，例如：like“138%”</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>禁止使用ENUM，可使用TINYINT代替<ul>\n<li>解读：<ol>\n<li>增加新的ENUM值要做DDL操作</li>\n<li>ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"五、索引设计规范\"><a href=\"#五、索引设计规范\" class=\"headerlink\" title=\"五、索引设计规范\"></a>五、索引设计规范</h4><ol start=\"19\">\n<li>单表索引建议控制在5个以内</li>\n<li>单索引字段数不允许超过5个<ul>\n<li>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</li>\n</ul>\n</li>\n<li>禁止在更新十分频繁、区分度不高的属性上建立索引<ul>\n<li>解读：<ol>\n<li>更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</li>\n<li>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性 能与全表扫描类似</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>建立组合索引，必须把区分度高的字段放在前面<ul>\n<li>解读：能够更加有效的过滤数据</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"六、SQL使用规范\"><a href=\"#六、SQL使用规范\" class=\"headerlink\" title=\"六、SQL使用规范\"></a>六、SQL使用规范</h4><ol start=\"23\">\n<li>禁止使用SELECT *，只获取必要的字段，需要显示说明列属性<ul>\n<li>解读：<ol>\n<li>读取不需要的列会增加CPU、IO、NET消耗</li>\n<li>不能有效的利用覆盖索引</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性<ul>\n<li>解读：容易在增加或者删除字段后出现程序BUG</li>\n</ul>\n</li>\n<li>禁止使用属性隐式转换<ul>\n<li>解读：SELECT uid FROM t_user WHERE phone=13812345678 <strong>会导致全表扫描</strong>，而不 能命中phone索引</li>\n</ul>\n</li>\n<li>禁止在WHERE条件的属性上使用函数或者表达式<ul>\n<li>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全 表扫描 正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</li>\n</ul>\n</li>\n<li>禁止负向查询，以及%开头的模糊查询<ul>\n<li>解读：<ol>\n<li>负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描</li>\n<li>%开头的模糊查询，会导致全表扫描</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>禁止大表使用JOIN查询，禁止大表使用子查询<ul>\n<li>解读：<strong>会产生临时表</strong>，消耗较多内存与CPU，极大影响数据库性能</li>\n</ul>\n</li>\n<li>禁止使用OR条件，必须改为IN查询<ul>\n<li>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费 更多的CPU帮助实施查询优化呢？</li>\n</ul>\n</li>\n<li>应用程序必须捕获SQL异常，并有相应处理</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h3 id=\"1-MySQL事务\"><a href=\"#1-MySQL事务\" class=\"headerlink\" title=\"1. MySQL事务\"></a>1. MySQL事务</h3><ol>\n<li>事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；","more":"</li>\n<li>事务的特性(ACID)：<ul>\n<li><strong>原子性</strong>（Atomicity，或称不可分割性）：最小的工作单元，整个工作单元要么一起提交成功，要么全部失败回滚</li>\n<li><strong>一致性</strong>（Consistency）：事务中操作的数据及状态改变是一致的，即写入资料的结果必须完全符合预设的规则， 不会因为出现系统意外等原因导致状态的不一致</li>\n<li><strong>隔离性</strong>（Isolation，又称独立性）：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）</li>\n<li><strong>持久性</strong>（Durability）：事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失</li>\n</ul>\n</li>\n<li>事务的开启与提交模式<ul>\n<li>若参数autocommit=0，自动开启<strong>手动提交</strong></li>\n<li>若参数autocommit=1（系统默认值），又分为两种状态：<ul>\n<li><strong>自动开启自动提交</strong>：用户的每一个操作都是一个完整的事务周期。</li>\n<li><strong>手动开启手动提交</strong>：从用户执行<code>start transaction</code>命令到用户执行<code>commit</code>命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。<ul>\n<li><code>begin</code> 或者 <code>start transaction</code>   – 开启事务</li>\n<li><code>commit</code> 或者 <code>rollback</code>           – 事务提交或回滚</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-1-事务的隔离级别\"><a href=\"#1-1-事务的隔离级别\" class=\"headerlink\" title=\"1.1 事务的隔离级别\"></a>1.1 事务的隔离级别</h4><ul>\n<li>查看/设置隔离级别<ul>\n<li>查看：<code>SELECT @@tx_isolation</code></li>\n<li>设置：<code>set tx_isolation=&#39;xxx&#39;</code></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><strong>读未提交</strong>（Read Uncommitted）<ul>\n<li>事务未提交对其他事务也是可见的，脏读（dirty read）</li>\n</ul>\n</li>\n<li><strong>读提交</strong>（Read Committed）–解决脏读问题 <ul>\n<li>一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读（nonrepeatable read）</li>\n</ul>\n</li>\n<li><strong>可重复读</strong>（Repeatable Read）–解决不可重复读问题<ul>\n<li>在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未定义解决幻读的问题</li>\n</ul>\n</li>\n<li><strong>串行化</strong>（Serializable）–解决所有问题<ul>\n<li>最高的隔离级别，通过强制事务的串行执行，但是会导致大量超时以及锁争用问题</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别。<br>事务的隔离级别的实现：锁、MVCC（多版本并发控制 Multiversion Currency Control）。</p>\n</blockquote>\n<h4 id=\"1-2-事务的七大传播行为\"><a href=\"#1-2-事务的七大传播行为\" class=\"headerlink\" title=\"1.2 事务的七大传播行为\"></a>1.2 事务的七大传播行为</h4><p>Spring在TransactionDefinition接口中规定了<strong>7种</strong>类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。</p>\n<ul>\n<li>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时<strong>事务如何传播</strong>。<ul>\n<li><code>@Transactional(propagation = Propagation.REQUIRED)</code></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>第一类：运行在同一个事务<ul>\n<li>**<code>REQUIRED</code>**（required）：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li>\n<li><code>SUPPORTS</code>（supports）：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li>\n<li><code>MANDATORY</code>（mandatory）：支持当前事务，如果当前没有事务，就抛出异常</li>\n</ul>\n</li>\n<li>第二类：运行在不同事务<ul>\n<li>**<code>REQUIRES_NEW</code>**（requires new）：新建事务，如果当前存在事务，把当前事务挂起</li>\n<li><code>NOT_SUPPORTED</code>(not supported)：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>\n<li><code>NEVER</code>（never）：以非事务方式执行，如果当前存在事务，则抛出异常</li>\n</ul>\n</li>\n<li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul>\n<li>**<code>NESTED</code>**（nested）：如果当前事务存在，则嵌套事务执行</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-锁\"><a href=\"#2-锁\" class=\"headerlink\" title=\"2. 锁\"></a>2. 锁</h3><p>锁是用于管理不同事务对共享资源的并发访问，InnoDB存储引擎支持行锁和表锁（InnoDB表锁是另类的行锁）</p>\n<ul>\n<li>InnoDB行锁<ul>\n<li>共享锁（读锁）：Shared Locks</li>\n<li>排它锁（写锁）：Exclusive Locks</li>\n</ul>\n</li>\n<li>InnoDB表锁<ul>\n<li>意向锁共享锁（IS）：Intention Shared Locks</li>\n<li>意向锁排它锁（IX）：Intention Exclusive Locks</li>\n<li>自增锁：AUTO-INC Locks</li>\n</ul>\n</li>\n<li>行锁的算法<ul>\n<li>记录锁 Record Locks</li>\n<li>间隙锁 Gap Locks</li>\n<li>临键锁 Next-key Locks</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-1-共享锁-Shared-amp-排他锁-Exclusive\"><a href=\"#2-1-共享锁-Shared-amp-排他锁-Exclusive\" class=\"headerlink\" title=\"2.1 共享锁(Shared) &amp; 排他锁(Exclusive)\"></a>2.1 共享锁(Shared) &amp; 排他锁(Exclusive)</h4><p>它们都是标准的<strong>行级锁</strong>。</p>\n<ul>\n<li>共享锁（S锁）：读锁，读锁允许多个连接可以同一时刻<strong>并发的读</strong>取同一资源,互不干扰，但是只能读不能修改;<ul>\n<li>加锁： <code>select * from users WHERE id=1 </code><strong><code>LOCK IN SHARE MODE</code></strong>; </li>\n<li>解锁：**<code>commit</code><strong>或</strong><code>rollback</code>**</li>\n</ul>\n</li>\n<li>排他锁（X锁）：写锁，一个写锁会<strong>阻塞</strong>其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。<ul>\n<li>加锁： <code>select * from users WHERE id=1 </code><strong><code>FOR UPDATE</code></strong>; </li>\n<li><strong><code>delete/update/insert 默认上 X 锁</code></strong></li>\n<li>解锁：**<code>commit</code><strong>或</strong><code>rollback</code>**</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：所谓共享锁、排他锁其实均是<strong>锁机制本身的策略</strong>，通过这两种策略对锁做了区分。</p>\n</blockquote>\n<ul>\n<li>InnoDB的行锁是通过<strong>给索引上的索引项加锁</strong>来实现的。</li>\n<li>只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）</li>\n</ul>\n<h4 id=\"2-2-意向锁-Intention-amp-自增锁-AUTO-INC\"><a href=\"#2-2-意向锁-Intention-amp-自增锁-AUTO-INC\" class=\"headerlink\" title=\"2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)\"></a>2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)</h4><p>它们都是标准的<strong>表级锁</strong>。</p>\n<ul>\n<li><strong>意向锁</strong>（Intention Locks）：表级别的锁。先提前声明一个意向，并获取表级别的意向锁（IS或IX），如果获取成功，才被允许对该表加行锁(S或X)。(即一个数据行加锁前必须先取得该表的意向锁)<ul>\n<li>意向锁(IS、IX)是InnoDB数据操作之前<strong>自动加的</strong>，不需要用户干预 </li>\n<li>意义：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</li>\n</ul>\n</li>\n<li><strong>自增锁</strong>（AUTO-INC Locks）：针对自增列自增长的一个特殊的表级别锁<ul>\n<li><code>show variables like &#39;innodb_autoinc_lock_mode&#39;</code>;</li>\n<li>默认取值1，代表连续，事务未提交ID永久丢失</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key\"><a href=\"#2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key\" class=\"headerlink\" title=\"2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)\"></a>2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)</h4><ul>\n<li><strong>临键锁 Next-key locks</strong>： <ul>\n<li><strong>锁住记录+区间（左开右闭）</strong></li>\n<li>Innodb<strong>默认</strong>行锁算法</li>\n<li>当sql执行按照索引进行数据的检索时,查询条件为范围查找（between and、&lt;、&gt;等）并有数 据命中则此时SQL语句加上的锁为Next-key locks，<strong>锁住索引的记录+区间（左开右闭）</strong></li>\n</ul>\n</li>\n<li><strong>间隙锁 Gap locks</strong>：<ul>\n<li><strong>锁住数据不存在的区间（左开右开）</strong></li>\n<li>当记录不存在，临键锁<strong>退化</strong>为Gap锁</li>\n<li>当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，Gap只在RR事务隔离级别存在，<strong>锁住索引不存在的区间（左开右开</strong>） </li>\n</ul>\n</li>\n<li><strong>记录锁 Record locks</strong>： <ul>\n<li><strong>锁住具体的索引项</strong></li>\n<li>唯一性(主键/唯一)索引，条件为<strong>精准匹配，退化</strong>成Record锁</li>\n<li>当sql执行按照唯一性（Primary key、Unique key）索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks，<strong>锁住具体的索引项</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-4-死锁的产生与避免\"><a href=\"#2-4-死锁的产生与避免\" class=\"headerlink\" title=\"2.4 死锁的产生与避免\"></a>2.4 死锁的产生与避免</h4><ul>\n<li>死锁<ul>\n<li>在InnoDB中，锁是逐步获得的，就造成了死锁的可能（2个或以上并发事务）</li>\n<li>每个事务都持有锁（或者是已经在等待锁）; </li>\n<li>每个事务都需要再继续持有锁；<strong>事务之间产生加锁的循环等待</strong>，形成死锁。</li>\n</ul>\n</li>\n<li>死锁的产生与避免<ol>\n<li>类似的业务逻辑以固定的<strong>顺序访问</strong>表和行。</li>\n<li>大事务拆小。大事务更倾向于死锁，如果业务允许，将<strong>大事务拆小</strong>。</li>\n<li>在同<strong>一个事务</strong>中，尽可能做到<strong>一次锁定</strong>所需要的所有资源，减少死锁概 率。</li>\n<li>降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择</li>\n<li>为表添加<strong>合理的索引</strong>。可以看到如果不走索引将会为表的每一行记录添 加上锁（或者说是表锁）</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"3-MVCC-多版本并发控制\"><a href=\"#3-MVCC-多版本并发控制\" class=\"headerlink\" title=\"3. MVCC(多版本并发控制)\"></a>3. MVCC(多版本并发控制)</h3><p>Multiversion concurrency control (多版本并发控制)：</p>\n<ul>\n<li><strong>MVCC</strong> 就是 <strong>同一份数据临时保留多版本的一种方式，进而实现并发控制</strong></li>\n<li>是行级锁的变种，它在普通读情况下<strong>避免了加锁操作</strong>，因此<strong>开销更低</strong>。</li>\n<li>MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用<strong>时间戳或者事务ID</strong>去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。<strong>读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据</strong>。</li>\n</ul>\n<h4 id=\"3-1-MVCC逻辑流程\"><a href=\"#3-1-MVCC逻辑流程\" class=\"headerlink\" title=\"3.1 MVCC逻辑流程\"></a>3.1 MVCC逻辑流程</h4><ul>\n<li>在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列<ul>\n<li><code>DB_TRX_ID</code>：数据行的版本号</li>\n<li><code>DB_ROLL_PT</code>：删除版本号</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>MVCC逻辑流程-插入<ul>\n<li>在插入数据的时候，会把全局事务ID记录到列<code>DB_TRX_ID</code>中去</li>\n</ul>\n</li>\n<li>MVCC逻辑流程-删除<ul>\n<li>执行完删除SQL之后数据并没有被真正删除，而是对删除版本号(<code>DB_ROLL_PT</code>)做改变</li>\n</ul>\n</li>\n<li>MVCC逻辑流程-修改<ul>\n<li>修改数据的时候 会先复制一条当前记录行数据，同时标记这条数据的数据行版本号为当前事务ID，最后把旧数据的删除版本号标记为新数据行版本号的值(即当前事务ID)。</li>\n</ul>\n</li>\n<li>MVCC逻辑流程-查询<ul>\n<li>查找数据行版本号早于当前事务ID的数据行记录</li>\n<li>也就是说，数据行的版本号要小于或等于 当前事务ID，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据</li>\n<li>查找删除版本号要么为NULL，要么大于当前事务版本号的记录</li>\n<li>这样确保查询出来的数据行记录在事务开启之前没有被删除</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>MySQL解决不可重复读和脏读并不是单纯利用 MVCC 机制来实现的。</p>\n</blockquote>\n<h3 id=\"4-MySQL事务日志-Undo-Log和Redo-Log\"><a href=\"#4-MySQL事务日志-Undo-Log和Redo-Log\" class=\"headerlink\" title=\"4. MySQL事务日志(Undo Log和Redo Log)\"></a>4. MySQL事务日志(Undo Log和Redo Log)</h3><p>innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。<br>undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：</p>\n<ol>\n<li>redo log通常是<strong>物理日志</strong>，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</li>\n<li>undo用来回滚行记录到某个版本。undo log一般是<strong>逻辑日志</strong>，根据每行记录进行记录。</li>\n</ol>\n<p>s</p>\n<h4 id=\"4-1-Undo-Log\"><a href=\"#4-1-Undo-Log\" class=\"headerlink\" title=\"4.1 Undo Log\"></a>4.1 Undo Log</h4><ul>\n<li>Undo Log定义：<ul>\n<li>undo意为取消，以撤销操作为目的，返回指定某个状态的操作</li>\n<li>undo log指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到一个地方 (Undo Log) </li>\n</ul>\n</li>\n<li><strong>UndoLog是为了实现事务的原子性而出现的产物</strong></li>\n<li>Undo Log实现事务原子性：<ul>\n<li>事务处理过程中如果出现了错误或者用户执行了 ROLLBACK语句,Mysql可以利用Undo Log中的备份 将数据恢复到事务开始之前的状态</li>\n</ul>\n</li>\n<li><strong>UndoLog在Mysql innodb存储引擎中用来实现多版本并发控制</strong></li>\n<li>Undo log实现多版本并发控制：<ul>\n<li>事务未提交之前，Undo保存了未提交之前的版本数据，Undo中的数据可作为数据旧版本快照供 其他并发事务进行快照读</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-2-当前读-amp-快照读\"><a href=\"#4-2-当前读-amp-快照读\" class=\"headerlink\" title=\"4.2 当前读 &amp; 快照读\"></a>4.2 当前读 &amp; 快照读</h4><ul>\n<li>快照读：<ul>\n<li>SQL读取的数据是快照版本，也就是历史版本，普通的SELECT就是快照读 innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改过的数据) 两部分组成 </li>\n</ul>\n</li>\n<li>当前读：<ul>\n<li>SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改 UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-3-Redo-Log\"><a href=\"#4-3-Redo-Log\" class=\"headerlink\" title=\"4.3 Redo Log\"></a>4.3 Redo Log</h4><ul>\n<li>Undo Log定义： <ul>\n<li>Redo，顾名思义就是重做。以恢复操作为目的，重现操作；</li>\n<li>Redo log指事务中操作的任何数据,将最新的数据备份到一个地方 (Redo Log)</li>\n</ul>\n</li>\n<li>Redo log的持久： <ul>\n<li>不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo 中。具体 的落盘策略可以进行配置</li>\n</ul>\n</li>\n<li><strong>RedoLog是为了实现事务的持久性而出现的产物</strong></li>\n<li>Redo Log实现事务持久性： <ul>\n<li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。</li>\n</ul>\n</li>\n<li>一旦事务成功提交且数据持久化落盘之后，此时Redo log中的对应事务数据记录就失去了意义，所 以Redo log的写入是日志文件循环写入的</li>\n</ul>\n<h3 id=\"附-58同城数据库设计30条军规\"><a href=\"#附-58同城数据库设计30条军规\" class=\"headerlink\" title=\"附: 58同城数据库设计30条军规\"></a>附: 58同城数据库设计30条军规</h3><ul>\n<li>军规适用场景：并发量大、数据量大的互联网业务 </li>\n<li>解读：讲解原因，<strong>解读比军规更重要</strong> </li>\n</ul>\n<h4 id=\"一、基础规范\"><a href=\"#一、基础规范\" class=\"headerlink\" title=\"一、基础规范\"></a>一、基础规范</h4><ol>\n<li>必须使用InnoDB存储引擎<ul>\n<li>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</li>\n</ul>\n</li>\n<li>必须使用UTF8字符集 UTF-8MB4<ul>\n<li>解读：万国码，无需转码，无乱码风险，节省空间</li>\n</ul>\n</li>\n<li>数据表、数据字段必须加入中文注释<ul>\n<li>解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的</li>\n</ul>\n</li>\n<li>禁止使用存储过程、视图、触发器、Event<ul>\n<li>解读：<strong>高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务 层”</strong>，并发量大的情况下，这些功能很可能将数据库拖死，<strong>业务逻辑放到服务层具备更好的 扩展性，能够轻易实现“增机器就加性能”</strong>。数据库擅长存储与索引，CPU计算还是上移吧</li>\n</ul>\n</li>\n<li>禁止存储大文件或者大照片<ul>\n<li>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI 多好</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二、命名规范\"><a href=\"#二、命名规范\" class=\"headerlink\" title=\"二、命名规范\"></a>二、命名规范</h4><ol start=\"6\">\n<li>只允许<strong>使用内网域名，而不是ip连接数据库</strong></li>\n<li>线上环境、开发环境、测试环境数据库内网域名遵循命名规范<ul>\n<li>业务名称：xxx，线上环境：xxx.db，开发环境：xxx.rdb，测试环境：xxx.tdb </li>\n<li>从库在名称后加-s标识，备库在名称后加-ss标识 线上从库：xxx-s.db 线上备库：xxx-sss.db</li>\n</ul>\n</li>\n<li>库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止 拼音英文混用</li>\n<li>表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</li>\n</ol>\n<h4 id=\"三、表设计规范\"><a href=\"#三、表设计规范\" class=\"headerlink\" title=\"三、表设计规范\"></a>三、表设计规范</h4><ol start=\"10\">\n<li>单实例表数目必须小于500</li>\n<li>单表列数目必须小于30</li>\n<li>表必须有主键，例如自增主键<ul>\n<li>解读：<ol>\n<li>主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和 内存的使用</li>\n<li>主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类 型可以有效的减少索引的磁盘空间，提高索引的缓存效率</li>\n<li>无主键的表删除，在row模式的主从架构，会导致备库夯住</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>禁止使用外键，如果有外键完整性约束，需要应用程序控制<ul>\n<li>解读：<strong>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响 sql 的性能</strong>，甚至会造成死锁。高并发情况下容易造成数据库性能，<strong>大数据高并发业务场景 数据库使用以性能优先</strong></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"四、字段设计规范\"><a href=\"#四、字段设计规范\" class=\"headerlink\" title=\"四、字段设计规范\"></a>四、字段设计规范</h4><ol start=\"14\">\n<li>必须把字段定义为NOT NULL并且提供默认值<ul>\n<li>解读： <ol>\n<li>null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化</li>\n<li>null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条 件下，表中有较多空字段的时候，数据库的处理性能会降低很多</li>\n<li>null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标 识</li>\n<li>对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、 not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记 录，查询结果就不会包含name为null值的记录</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>禁止使用TEXT、BLOB类型<ul>\n<li>解读：会浪费更多的磁盘和内存空间，<strong>非必要的大量的大字段查询会淘汰掉热数据，导致内 存命中率急剧降低，影响数据库性能</strong></li>\n</ul>\n</li>\n<li>禁止使用小数存储货币<ul>\n<li>解读：使用整数吧，小数容易导致钱对不上</li>\n</ul>\n</li>\n<li>必须使用varchar(20)存储手机号<ul>\n<li>解读：<ol>\n<li>涉及到区号或者国家代号，可能出现+-()</li>\n<li>手机号会去做数学运算么？</li>\n<li>varchar可以支持模糊查询，例如：like“138%”</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>禁止使用ENUM，可使用TINYINT代替<ul>\n<li>解读：<ol>\n<li>增加新的ENUM值要做DDL操作</li>\n<li>ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"五、索引设计规范\"><a href=\"#五、索引设计规范\" class=\"headerlink\" title=\"五、索引设计规范\"></a>五、索引设计规范</h4><ol start=\"19\">\n<li>单表索引建议控制在5个以内</li>\n<li>单索引字段数不允许超过5个<ul>\n<li>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</li>\n</ul>\n</li>\n<li>禁止在更新十分频繁、区分度不高的属性上建立索引<ul>\n<li>解读：<ol>\n<li>更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</li>\n<li>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性 能与全表扫描类似</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>建立组合索引，必须把区分度高的字段放在前面<ul>\n<li>解读：能够更加有效的过滤数据</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"六、SQL使用规范\"><a href=\"#六、SQL使用规范\" class=\"headerlink\" title=\"六、SQL使用规范\"></a>六、SQL使用规范</h4><ol start=\"23\">\n<li>禁止使用SELECT *，只获取必要的字段，需要显示说明列属性<ul>\n<li>解读：<ol>\n<li>读取不需要的列会增加CPU、IO、NET消耗</li>\n<li>不能有效的利用覆盖索引</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性<ul>\n<li>解读：容易在增加或者删除字段后出现程序BUG</li>\n</ul>\n</li>\n<li>禁止使用属性隐式转换<ul>\n<li>解读：SELECT uid FROM t_user WHERE phone=13812345678 <strong>会导致全表扫描</strong>，而不 能命中phone索引</li>\n</ul>\n</li>\n<li>禁止在WHERE条件的属性上使用函数或者表达式<ul>\n<li>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全 表扫描 正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</li>\n</ul>\n</li>\n<li>禁止负向查询，以及%开头的模糊查询<ul>\n<li>解读：<ol>\n<li>负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描</li>\n<li>%开头的模糊查询，会导致全表扫描</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>禁止大表使用JOIN查询，禁止大表使用子查询<ul>\n<li>解读：<strong>会产生临时表</strong>，消耗较多内存与CPU，极大影响数据库性能</li>\n</ul>\n</li>\n<li>禁止使用OR条件，必须改为IN查询<ul>\n<li>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费 更多的CPU帮助实施查询优化呢？</li>\n</ul>\n</li>\n<li>应用程序必须捕获SQL异常，并有相应处理</li>\n</ol>"},{"title":"【数据库优化】MySQL慢日志查询分析","date":"2019-08-28T16:26:43.000Z","_content":"\n同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。<!-- more -->\n+ 错误日志：记录启动、运行或停止mysqld时出现的问题。\n+ 通用日志：记录建立的客户端连接和执行的语句。\n+ 更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。\n+ 二进制日志：记录所有更改数据的语句。还用于复制。\n+ 慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询\n+ Innodb日志：InnoDB redo log(记录了事务的行为，可以很好的通过其对页进行“重做”操作)\n\n### 1. 开启慢查询日志\n开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。\n通过`show variables like 'slow_query%';`查询是否开了慢查询(默认禁用OFF)\n``` sql\nmysql> show variables like '%slow_query_log%';\n+---------------------+------------------------------------------------------+\n| Variable_name       | Value                                                |\n+---------------------+------------------------------------------------------+\n| slow_query_log      | OFF                                                  |\n| slow_query_log_file | D:\\mysql-5.7.27-winx64\\data\\DESKTOP-E9F062A-slow.log |\n+---------------------+------------------------------------------------------+\n```\n> `slow_query_log` 慢查询开启状态  OFF 未开启 ON 为开启\n> `slow_query_log_file` 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）\n\n开启慢查询，需要设置`slow_query_log`参数。当然，如果不是调优需要的话，一般不建议开启该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志写入文件。\n``` sql\nmysql> set global slow_query_log = 1; //设置开启或者关闭，0为关闭，1为开启\nmysql> set global long_query_time = 3;  //设置慢的阙值时间，默认10秒\n```\n> 如果通过终端命令设定的话，需要重新连接或新开一个会话才能看到修改值\n\n使用set global slow_query_log 命令开启慢查询日志，只对当前数据库生效，如果Mysql重启后则会失效。如果要永久生效，必须修改my.cnf配置文件(其他系统变量也是如此)\n``` sql\n[mysqld]\nslow_query_log = 1 #开启\nslow_query_log_file = /mysql-5.7.27-winx64/data/mysql-slow.log #默认host_name_show.log\nlong_query_time = 3 #默认10秒（查询超过多少秒才记录）\nlog-queries-not-using-indexes = on #如果值设置为ON，则会记录所有没有利用索引的查询，一般在性能调优的时候会暂时开启。\nlog_output = 'FILE,TABLE' #输出的格式(FILE:文本, TABLE:表中, FILE,TABLE:同时输出到文本和表中)\n```\n\n插入一条测试慢查询\n``` sql\nmysql> select sleep(5);\n```\n\n通过MySQL命令查看有多少慢查询\n``` sql\nmysql> show global status like '%Slow_queries%';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| Slow_queries  | 1     |\n+---------------+-------+\n```\n\n\n### 2. 慢查询日志分析工具\n|工具                |一般统计 |高级统计 |语言 |优势          |针对log |\n|----------------------|---|--------|----------|-------------|-----|\n|mysqldumpslow         | `√` | `×` |perl  |mysql官方自带 |slow      |\n|myprofi               | `√`  | `×`    |php   |简单         |slow      |\n|mysql-log-filter      | `√`  |部分`√` |python|简单         |slow      |\n|mysql-explain-slow-log| `√`  | `×`    |perl  |无           |slow      |\n|mysqlbinlog           | `√`  | `×`    |二进制 |mysql官方自带 |binary log|\n|mysqlsla              | `√`  | `√`   |perl  |总能强大，使用简单，自定义能力强 |所有日志，包括自定义日志 |\n|pt-query-digest       | `√`  | `√`   |perl  |总能强大，使用简单，自定义能力强 |所有日志，包括自定义日志 |\n\n\n#### 2.1 mysqldumpslow\n* MySQL自带的慢查询日志分析工具mysqldumpslow主要功能是, 统计不同慢sql的:\n    - 出现次数(Count),\n    - 执行最长时间(Time), \n    - 累计总耗费时间(Time),\n    - 等待锁的时间(Lock), \n    - 发送给客户端的行总数(Rows),\n    - 扫描的行总数(Rows), \n    - 用户以及sql语句本身(抽象了一下格式, 比如 limit 1, 20 用 limit N,N 表示).\n安装后基本使用：\n``` sql\nmysqldumpslow -s r -t 10 /data/mysql/mysql-slow.log  //得到返回记录集最多的10个SQL\nmysqldumpslow -s c -t 10 /data/mysql/mysql-slow.log //得到访问次数最多的10个SQL \nmysqldumpslow -s t -t 10 -g \"left join\" /data/mysql/mysql-slow.log  //得到按照时间排序的前10条里面含有做了连接的查询SQL\nmysqldumpslow -s r -t 10 /data/mysql/mysql-slow.log | more  //另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况\n```\n\n\n#### 2.2 mysqlsla\nhackmysql.com推出的一款日志分析工具(该网站还维护了 mysqlreport, mysqlidxchk 等比较实用的mysql工具)\n* 整体来说, 功能非常强大. 数据报表,非常有利于分析慢查询的原因, 包括执行频率, 数据量, 查询消耗等.\n\n安装后基本使用方法：\n``` sql\nmysqlsla -lt slow -sort t_sum -top 1000  /tmp/slow_query.log\n```\n\n* 结果选项说明：\n    + 总查询次数 (queries total),\n    + 去重后的sql数量 (unique),\n    + 输出报表的内容排序(sorted by),\n    + 最重大的慢sql统计信息(包括 平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数)\n    + Count, sql的执行次数及占总的slow log数量的百分比.\n    + Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.\n    + 95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.\n    + Lock Time, 等待锁的时间.\n    + 95% of Lock , 95%的慢sql等待锁时间.\n    + Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.\n    + Rows examined, 扫描的行数量.\n    + Database, 属于哪个数据库\n    + Users, 哪个用户,IP, 占到所有用户执行的sql百分比\n    + Query abstract, 抽象后的sql语句\n    + Query sample, sql语句\n* mysqlsla常用参数说明：\n    1. `-log-type (-lt) type logs`:通过这个参数来制定log的类型，主要有slow, general, binary, msl, udl,分析slow log时通过制定为slow\n    2. `-sort`:t_sum:按总时间排序(默认)，c_sum:按总次数排序c_sum_p: sql语句执行次数占总执行次数的百分比。\n    3. `-top`:显示sql的数量，默认是10,表示按规则取排序的前多少条\n    4. `–statement-filter (-sf) [+-][TYPE]`:过滤sql语句的类型，比如select、update、drop，[TYPE] 有SELECT, CREATE, DROP, UPDATE, INSERT，例如\"+SELECT,INSERT\"，不出现的默认是-，即不包括。\n    5. `-db`：要处理哪个库的日志：\n\n``` sql\n# 举个例子，只取funsion数据库的select语句，并按照总时间排序，取前1000条数据\n# 保存到当前目录下的 slow_query.pretty.log文件中\nmysqlsla -lt slow  -sort t_sum  -sf \"+select\"  -db funsion  -top 1000  /tmp/slow_query.log > ./slow_query.pretty.log\n```\n\n> 深度使用可参考： [MySQL日志分析神器之mysqlsla](https://yq.aliyun.com/articles/59260)\n\n\n#### 2.3 pt-query-digest\npt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。\n``` sql\n# 分析最近12小时内的查询：\npt-query-digest  --since=12h  slow.log > slow_report2.log\n```\n\n1. pt-query-digest语法及重要选项\n``` sql\npt-query-digest [OPTIONS] [FILES] [DSN]\n    --create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。\n    --create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。\n    --filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析\n    --limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。\n    --host  mysql服务器地址\n    --user  mysql用户名\n    --password  mysql用户密码\n    --history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。\n    --review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。\n    --output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。\n    --since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。\n    --until 截止时间，配合—since可以分析一段时间内的慢查询。\n```\n\n\n分析pt-query-digest输出结果\n1. 总体统计结果\n    - Overall：总共有多少条查询\n    - Time range：查询执行的时间范围\n    - unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询\n    - total：总计   min：最小   max：最大  avg：平均\n    - 95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值\n    - median：中位数，把所有值从小到大排列，位置位于中间那个数\n2. 查询分组统计结果\n    - Rank：所有语句的排名，默认按查询时间降序排列，通过--order-by指定\n    - Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）\n    - Response：总的响应时间\n    - time：该查询在本次分析中总的时间占比\n    - calls：执行次数，即本次分析总共有多少条这种类型的查询语句\n    - R/Call：平均每次执行的响应时间\n    - V/M：响应时间Variance-to-mean的比率\n    - Item：查询对象\n3. 每一种查询的详细统计结果\n    - 由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。\n    - ID：查询的ID号，和上图的Query ID对应\n    - Databases：数据库名\n    - Users：各个用户执行的次数（占比）\n    - Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。\n    - Tables：查询中涉及到的表\n    - Explain：SQL语句\n\n\n### 3. explain查看执行计划\n在上面的慢查询中，我们已经将查询时间超过阀值的sql语句过滤了出来，`explain+查询语句`具体分析是哪里出了问题。\nMySQL 提供了一个 `Explain` 命令, 它可以对 select 语句进行分析, 并输出 select 执行的详细信息, 以供开发人员针对性优化.\n``` sql\nmysql> explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.06 sec)\n```\n\n1. 各列的含义如下:\n    - `id`: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n    - `select_type`: SELECT 查询的类型.\n        + SIMPLE, 表示此查询不包含 UNION 查询或子查询\n        + PRIMARY, 表示此查询是最外层的查询\n        + UNION, 表示此查询是 UNION 的第二或随后的查询\n        + DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询\n        + UNION RESULT, UNION 的结果\n        + SUBQUERY, 子查询中的第一个 SELECT\n        + DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.\n    - `table`: 查询的是哪个表\n    - `partitions`: 匹配的分区\n    - `type`: join 类型\n        + type字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过`type`字段, 我们判断此次查询是 `全表扫描` 还是 `索引扫描` 等.\n        + system: 表中只有一条数据. 这个类型是特殊的 const 类型.\n        + const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.\n        + eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. \n        + ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.\n        + range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.\n        + index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.\n        + ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难.\n    - `possible_keys`: 此次查询中可能选用的索引\n        + 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\n    - `key`: 此字段是 MySQL 在当前查询时所真正使用到的索引.\n    - `key_len`: 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\n    - `ref`: 哪个字段或常数与 key 一起被使用\n    - `rows`: 显示此查询一共扫描了多少行. 这个是一个估计值.\n        + rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数, 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n    - `filtered`: 表示此查询条件所过滤的数据的百分比\n    - `extra`: EXplain 中的很多额外的信息会在 Extra 字段显示\n        + Using filesort: 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\n        + Using index: \"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\n        + Using temporary: 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.\n\n2. type 类型的性能比较\n通常来说, 不同的 type 类型的性能关系如下:\n* `ALL < index < range ~ index_merge < ref < eq_ref < const < system`\n    + ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.\n    + 而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\n    + 后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.\n\n\n### 4. MySQL性能分析语句show profile\nQuery Profile是MySQL自带的一种Query诊断分析工具，可以完整的显示一条sql执行的各方面的详细信息，默认关闭;\n1. 看看当前的MySQL版本是否支持: `show variables like 'profiling';`或`show variables like 'profiling%';`\n``` SQL\nmysql> show variables like 'profiling%';\n+------------------------+-------+\n| Variable_name          | Value |\n+------------------------+-------+\n| profiling              | OFF   |\n| profiling_history_size | 15    |\n+------------------------+-------+\n```\n\n2. 使用前需要开启: `set profiling = 1; (1:开 / 0:关)`\n``` sql\nmysql> set profiling = 1;\n```\n\n3. **运行sql后**，查询结果`show profiles;`\n``` sql\nmysql> SHOW PROFILES\\G\n*************************** 1. row ***************************\nQuery_ID: 1\nDuration: 0.02949950\n   Query: explain select * from user\n*************************** 2. row ***************************\nQuery_ID: 2\nDuration: 0.03405350\n   Query: select * from housedemo\n*************************** 3. row ***************************\nQuery_ID: 3\nDuration: 0.07813800\n   Query: select * from house\n*************************** 4. row ***************************\nQuery_ID: 4\nDuration: 0.00018150\n   Query: show prifiles\n```\n\n4. 诊断SQL, show profile `Type` io for query `Query_ID`\n    + LIMIT部分的用法与SELECT中LIMIT子句一致，不赘述。\n    + Type是可选的，取值范围可以如下：\n        * `ALL` 显示所有性能信息\n        * `BLOCK IO` 显示块IO操作的次数\n        * `CONTEXT SWITCHES` 显示上下文切换次数，不管是主动还是被动\n        * `CPU` 显示用户CPU时间、系统CPU时间\n        * `IPC` 显示发送和接收的消息数量\n        * `MEMORY` [暂未实现]\n        * `PAGE FAULTS` 显示页错误数量\n        * `SOURCE` 显示源码中的函数名称与位置\n        * `SWAPS` 显示SWAP的次数\n\n``` sql\nmysql> show profile cpu,block io for query 3;\n+----------------------+----------+----------+------------+--------------+---------------+\n| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |\n+----------------------+----------+----------+------------+--------------+---------------+\n| starting             | 0.000077 | 0.000000 |   0.000000 |         NULL |          NULL |\n| checking permissions | 0.000013 | 0.000000 |   0.000000 |         NULL |          NULL |\n| Opening tables       | 0.031992 | 0.000000 |   0.000000 |         NULL |          NULL |\n| init                 | 0.000059 | 0.000000 |   0.000000 |         NULL |          NULL |\n| System lock          | 0.000016 | 0.000000 |   0.000000 |         NULL |          NULL |\n| optimizing           | 0.000007 | 0.000000 |   0.000000 |         NULL |          NULL |\n| statistics           | 0.000017 | 0.000000 |   0.000000 |         NULL |          NULL |\n| preparing            | 0.008535 | 0.000000 |   0.000000 |         NULL |          NULL |\n| executing            | 0.000016 | 0.000000 |   0.000000 |         NULL |          NULL |\n| Sending data         | 0.037234 | 0.000000 |   0.000000 |         NULL |          NULL |\n| end                  | 0.000011 | 0.000000 |   0.000000 |         NULL |          NULL |\n| query end            | 0.000012 | 0.000000 |   0.000000 |         NULL |          NULL |\n| closing tables       | 0.000014 | 0.000000 |   0.000000 |         NULL |          NULL |\n| freeing items        | 0.000108 | 0.000000 |   0.000000 |         NULL |          NULL |\n| cleaning up          | 0.000030 | 0.000000 |   0.000000 |         NULL |          NULL |\n+----------------------+----------+----------+------------+--------------+---------------+\n```\n\n从图中可以看到开始，打开表，加载，关闭表，释放资源、记录日志，清理的你工作，在这完全可以看到一条SQL的完整生命周期。\n\n\n5. 日常开发需要注意\n    + 如果show profile ... for query id；出现了如下四个，则必须优化这条sql。\n        1. `converting HEAP to MyISAM` 查询结果太大， 内存都不够用了网磁盘上搬了\n        2. `Creating tmp table` 创建临时表\n        3. 拷贝数据到临时表：假设要查询两百万数据，刚好匹配的条件有一百万，恰巧要把这一百万的数据拷贝到临时表，然后再把数据推送给用户，最后再把临时表删掉，这个时候就是导致SQL变慢的罪魁祸首\n        4. 用完再删除\n        5. `Copying to tmp table on disk` 把内存中临时表复制到磁盘，危险！！！\n        6. `locked`\n\n\n### 5. 全局查询日志\n切记：**永远不要再生产环境开启这个功能**。\n全局查询日志有时也能帮助我们来调SQL。但是，切记，这家伙只能在测试环境使用，绝不可以在生产环境使用。\n1. 命令启用\n``` sql\nmysql> set global general_log=1; #开启后会把所有的SQL偷偷的记录\nmysql> set global log_output='TABLE';\n```\n\n2. 配置启用,  在MySQL的my.cnf中，设置如下：\n``` sql\n#开启\ngeneral_log=1\n#记录日志文件的路径\ngeneral_log_file=/path/logfile\n#输出格式\nlog_output=file\n```\n\n3. 此后，你所编写的SQL语句，将会记录到MySQL库里的general_log表，可以用下面的命令查看。\n``` sql\nselect * from mysql.general_log;\n```\n> 场景：如果需要做系统的定案分析(今天下午2点-3点出的故障），如果要观察和复现的话，可以在测试环境下模拟一遍，然后把所有的问题复现一下。那么用general_log这个表来收集什么时间段发生了什么样的SQL，帮助我们定位收集。\n\n\n\n","source":"_posts/【数据库优化】MySQL慢日志查询分析.md","raw":"---\ntitle: 【数据库优化】MySQL慢日志查询分析\ndate: 2019-08-29 00:26:43\ntags: [数据库, 后端开发]\ncategories: 数据库\n---\n\n同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。<!-- more -->\n+ 错误日志：记录启动、运行或停止mysqld时出现的问题。\n+ 通用日志：记录建立的客户端连接和执行的语句。\n+ 更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。\n+ 二进制日志：记录所有更改数据的语句。还用于复制。\n+ 慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询\n+ Innodb日志：InnoDB redo log(记录了事务的行为，可以很好的通过其对页进行“重做”操作)\n\n### 1. 开启慢查询日志\n开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。\n通过`show variables like 'slow_query%';`查询是否开了慢查询(默认禁用OFF)\n``` sql\nmysql> show variables like '%slow_query_log%';\n+---------------------+------------------------------------------------------+\n| Variable_name       | Value                                                |\n+---------------------+------------------------------------------------------+\n| slow_query_log      | OFF                                                  |\n| slow_query_log_file | D:\\mysql-5.7.27-winx64\\data\\DESKTOP-E9F062A-slow.log |\n+---------------------+------------------------------------------------------+\n```\n> `slow_query_log` 慢查询开启状态  OFF 未开启 ON 为开启\n> `slow_query_log_file` 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）\n\n开启慢查询，需要设置`slow_query_log`参数。当然，如果不是调优需要的话，一般不建议开启该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志写入文件。\n``` sql\nmysql> set global slow_query_log = 1; //设置开启或者关闭，0为关闭，1为开启\nmysql> set global long_query_time = 3;  //设置慢的阙值时间，默认10秒\n```\n> 如果通过终端命令设定的话，需要重新连接或新开一个会话才能看到修改值\n\n使用set global slow_query_log 命令开启慢查询日志，只对当前数据库生效，如果Mysql重启后则会失效。如果要永久生效，必须修改my.cnf配置文件(其他系统变量也是如此)\n``` sql\n[mysqld]\nslow_query_log = 1 #开启\nslow_query_log_file = /mysql-5.7.27-winx64/data/mysql-slow.log #默认host_name_show.log\nlong_query_time = 3 #默认10秒（查询超过多少秒才记录）\nlog-queries-not-using-indexes = on #如果值设置为ON，则会记录所有没有利用索引的查询，一般在性能调优的时候会暂时开启。\nlog_output = 'FILE,TABLE' #输出的格式(FILE:文本, TABLE:表中, FILE,TABLE:同时输出到文本和表中)\n```\n\n插入一条测试慢查询\n``` sql\nmysql> select sleep(5);\n```\n\n通过MySQL命令查看有多少慢查询\n``` sql\nmysql> show global status like '%Slow_queries%';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| Slow_queries  | 1     |\n+---------------+-------+\n```\n\n\n### 2. 慢查询日志分析工具\n|工具                |一般统计 |高级统计 |语言 |优势          |针对log |\n|----------------------|---|--------|----------|-------------|-----|\n|mysqldumpslow         | `√` | `×` |perl  |mysql官方自带 |slow      |\n|myprofi               | `√`  | `×`    |php   |简单         |slow      |\n|mysql-log-filter      | `√`  |部分`√` |python|简单         |slow      |\n|mysql-explain-slow-log| `√`  | `×`    |perl  |无           |slow      |\n|mysqlbinlog           | `√`  | `×`    |二进制 |mysql官方自带 |binary log|\n|mysqlsla              | `√`  | `√`   |perl  |总能强大，使用简单，自定义能力强 |所有日志，包括自定义日志 |\n|pt-query-digest       | `√`  | `√`   |perl  |总能强大，使用简单，自定义能力强 |所有日志，包括自定义日志 |\n\n\n#### 2.1 mysqldumpslow\n* MySQL自带的慢查询日志分析工具mysqldumpslow主要功能是, 统计不同慢sql的:\n    - 出现次数(Count),\n    - 执行最长时间(Time), \n    - 累计总耗费时间(Time),\n    - 等待锁的时间(Lock), \n    - 发送给客户端的行总数(Rows),\n    - 扫描的行总数(Rows), \n    - 用户以及sql语句本身(抽象了一下格式, 比如 limit 1, 20 用 limit N,N 表示).\n安装后基本使用：\n``` sql\nmysqldumpslow -s r -t 10 /data/mysql/mysql-slow.log  //得到返回记录集最多的10个SQL\nmysqldumpslow -s c -t 10 /data/mysql/mysql-slow.log //得到访问次数最多的10个SQL \nmysqldumpslow -s t -t 10 -g \"left join\" /data/mysql/mysql-slow.log  //得到按照时间排序的前10条里面含有做了连接的查询SQL\nmysqldumpslow -s r -t 10 /data/mysql/mysql-slow.log | more  //另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况\n```\n\n\n#### 2.2 mysqlsla\nhackmysql.com推出的一款日志分析工具(该网站还维护了 mysqlreport, mysqlidxchk 等比较实用的mysql工具)\n* 整体来说, 功能非常强大. 数据报表,非常有利于分析慢查询的原因, 包括执行频率, 数据量, 查询消耗等.\n\n安装后基本使用方法：\n``` sql\nmysqlsla -lt slow -sort t_sum -top 1000  /tmp/slow_query.log\n```\n\n* 结果选项说明：\n    + 总查询次数 (queries total),\n    + 去重后的sql数量 (unique),\n    + 输出报表的内容排序(sorted by),\n    + 最重大的慢sql统计信息(包括 平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数)\n    + Count, sql的执行次数及占总的slow log数量的百分比.\n    + Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.\n    + 95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.\n    + Lock Time, 等待锁的时间.\n    + 95% of Lock , 95%的慢sql等待锁时间.\n    + Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.\n    + Rows examined, 扫描的行数量.\n    + Database, 属于哪个数据库\n    + Users, 哪个用户,IP, 占到所有用户执行的sql百分比\n    + Query abstract, 抽象后的sql语句\n    + Query sample, sql语句\n* mysqlsla常用参数说明：\n    1. `-log-type (-lt) type logs`:通过这个参数来制定log的类型，主要有slow, general, binary, msl, udl,分析slow log时通过制定为slow\n    2. `-sort`:t_sum:按总时间排序(默认)，c_sum:按总次数排序c_sum_p: sql语句执行次数占总执行次数的百分比。\n    3. `-top`:显示sql的数量，默认是10,表示按规则取排序的前多少条\n    4. `–statement-filter (-sf) [+-][TYPE]`:过滤sql语句的类型，比如select、update、drop，[TYPE] 有SELECT, CREATE, DROP, UPDATE, INSERT，例如\"+SELECT,INSERT\"，不出现的默认是-，即不包括。\n    5. `-db`：要处理哪个库的日志：\n\n``` sql\n# 举个例子，只取funsion数据库的select语句，并按照总时间排序，取前1000条数据\n# 保存到当前目录下的 slow_query.pretty.log文件中\nmysqlsla -lt slow  -sort t_sum  -sf \"+select\"  -db funsion  -top 1000  /tmp/slow_query.log > ./slow_query.pretty.log\n```\n\n> 深度使用可参考： [MySQL日志分析神器之mysqlsla](https://yq.aliyun.com/articles/59260)\n\n\n#### 2.3 pt-query-digest\npt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。\n``` sql\n# 分析最近12小时内的查询：\npt-query-digest  --since=12h  slow.log > slow_report2.log\n```\n\n1. pt-query-digest语法及重要选项\n``` sql\npt-query-digest [OPTIONS] [FILES] [DSN]\n    --create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。\n    --create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。\n    --filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析\n    --limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。\n    --host  mysql服务器地址\n    --user  mysql用户名\n    --password  mysql用户密码\n    --history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。\n    --review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。\n    --output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。\n    --since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。\n    --until 截止时间，配合—since可以分析一段时间内的慢查询。\n```\n\n\n分析pt-query-digest输出结果\n1. 总体统计结果\n    - Overall：总共有多少条查询\n    - Time range：查询执行的时间范围\n    - unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询\n    - total：总计   min：最小   max：最大  avg：平均\n    - 95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值\n    - median：中位数，把所有值从小到大排列，位置位于中间那个数\n2. 查询分组统计结果\n    - Rank：所有语句的排名，默认按查询时间降序排列，通过--order-by指定\n    - Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）\n    - Response：总的响应时间\n    - time：该查询在本次分析中总的时间占比\n    - calls：执行次数，即本次分析总共有多少条这种类型的查询语句\n    - R/Call：平均每次执行的响应时间\n    - V/M：响应时间Variance-to-mean的比率\n    - Item：查询对象\n3. 每一种查询的详细统计结果\n    - 由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。\n    - ID：查询的ID号，和上图的Query ID对应\n    - Databases：数据库名\n    - Users：各个用户执行的次数（占比）\n    - Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。\n    - Tables：查询中涉及到的表\n    - Explain：SQL语句\n\n\n### 3. explain查看执行计划\n在上面的慢查询中，我们已经将查询时间超过阀值的sql语句过滤了出来，`explain+查询语句`具体分析是哪里出了问题。\nMySQL 提供了一个 `Explain` 命令, 它可以对 select 语句进行分析, 并输出 select 执行的详细信息, 以供开发人员针对性优化.\n``` sql\nmysql> explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.06 sec)\n```\n\n1. 各列的含义如下:\n    - `id`: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n    - `select_type`: SELECT 查询的类型.\n        + SIMPLE, 表示此查询不包含 UNION 查询或子查询\n        + PRIMARY, 表示此查询是最外层的查询\n        + UNION, 表示此查询是 UNION 的第二或随后的查询\n        + DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询\n        + UNION RESULT, UNION 的结果\n        + SUBQUERY, 子查询中的第一个 SELECT\n        + DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.\n    - `table`: 查询的是哪个表\n    - `partitions`: 匹配的分区\n    - `type`: join 类型\n        + type字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过`type`字段, 我们判断此次查询是 `全表扫描` 还是 `索引扫描` 等.\n        + system: 表中只有一条数据. 这个类型是特殊的 const 类型.\n        + const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.\n        + eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. \n        + ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.\n        + range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.\n        + index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.\n        + ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难.\n    - `possible_keys`: 此次查询中可能选用的索引\n        + 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\n    - `key`: 此字段是 MySQL 在当前查询时所真正使用到的索引.\n    - `key_len`: 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\n    - `ref`: 哪个字段或常数与 key 一起被使用\n    - `rows`: 显示此查询一共扫描了多少行. 这个是一个估计值.\n        + rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数, 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n    - `filtered`: 表示此查询条件所过滤的数据的百分比\n    - `extra`: EXplain 中的很多额外的信息会在 Extra 字段显示\n        + Using filesort: 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\n        + Using index: \"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\n        + Using temporary: 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.\n\n2. type 类型的性能比较\n通常来说, 不同的 type 类型的性能关系如下:\n* `ALL < index < range ~ index_merge < ref < eq_ref < const < system`\n    + ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.\n    + 而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\n    + 后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.\n\n\n### 4. MySQL性能分析语句show profile\nQuery Profile是MySQL自带的一种Query诊断分析工具，可以完整的显示一条sql执行的各方面的详细信息，默认关闭;\n1. 看看当前的MySQL版本是否支持: `show variables like 'profiling';`或`show variables like 'profiling%';`\n``` SQL\nmysql> show variables like 'profiling%';\n+------------------------+-------+\n| Variable_name          | Value |\n+------------------------+-------+\n| profiling              | OFF   |\n| profiling_history_size | 15    |\n+------------------------+-------+\n```\n\n2. 使用前需要开启: `set profiling = 1; (1:开 / 0:关)`\n``` sql\nmysql> set profiling = 1;\n```\n\n3. **运行sql后**，查询结果`show profiles;`\n``` sql\nmysql> SHOW PROFILES\\G\n*************************** 1. row ***************************\nQuery_ID: 1\nDuration: 0.02949950\n   Query: explain select * from user\n*************************** 2. row ***************************\nQuery_ID: 2\nDuration: 0.03405350\n   Query: select * from housedemo\n*************************** 3. row ***************************\nQuery_ID: 3\nDuration: 0.07813800\n   Query: select * from house\n*************************** 4. row ***************************\nQuery_ID: 4\nDuration: 0.00018150\n   Query: show prifiles\n```\n\n4. 诊断SQL, show profile `Type` io for query `Query_ID`\n    + LIMIT部分的用法与SELECT中LIMIT子句一致，不赘述。\n    + Type是可选的，取值范围可以如下：\n        * `ALL` 显示所有性能信息\n        * `BLOCK IO` 显示块IO操作的次数\n        * `CONTEXT SWITCHES` 显示上下文切换次数，不管是主动还是被动\n        * `CPU` 显示用户CPU时间、系统CPU时间\n        * `IPC` 显示发送和接收的消息数量\n        * `MEMORY` [暂未实现]\n        * `PAGE FAULTS` 显示页错误数量\n        * `SOURCE` 显示源码中的函数名称与位置\n        * `SWAPS` 显示SWAP的次数\n\n``` sql\nmysql> show profile cpu,block io for query 3;\n+----------------------+----------+----------+------------+--------------+---------------+\n| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |\n+----------------------+----------+----------+------------+--------------+---------------+\n| starting             | 0.000077 | 0.000000 |   0.000000 |         NULL |          NULL |\n| checking permissions | 0.000013 | 0.000000 |   0.000000 |         NULL |          NULL |\n| Opening tables       | 0.031992 | 0.000000 |   0.000000 |         NULL |          NULL |\n| init                 | 0.000059 | 0.000000 |   0.000000 |         NULL |          NULL |\n| System lock          | 0.000016 | 0.000000 |   0.000000 |         NULL |          NULL |\n| optimizing           | 0.000007 | 0.000000 |   0.000000 |         NULL |          NULL |\n| statistics           | 0.000017 | 0.000000 |   0.000000 |         NULL |          NULL |\n| preparing            | 0.008535 | 0.000000 |   0.000000 |         NULL |          NULL |\n| executing            | 0.000016 | 0.000000 |   0.000000 |         NULL |          NULL |\n| Sending data         | 0.037234 | 0.000000 |   0.000000 |         NULL |          NULL |\n| end                  | 0.000011 | 0.000000 |   0.000000 |         NULL |          NULL |\n| query end            | 0.000012 | 0.000000 |   0.000000 |         NULL |          NULL |\n| closing tables       | 0.000014 | 0.000000 |   0.000000 |         NULL |          NULL |\n| freeing items        | 0.000108 | 0.000000 |   0.000000 |         NULL |          NULL |\n| cleaning up          | 0.000030 | 0.000000 |   0.000000 |         NULL |          NULL |\n+----------------------+----------+----------+------------+--------------+---------------+\n```\n\n从图中可以看到开始，打开表，加载，关闭表，释放资源、记录日志，清理的你工作，在这完全可以看到一条SQL的完整生命周期。\n\n\n5. 日常开发需要注意\n    + 如果show profile ... for query id；出现了如下四个，则必须优化这条sql。\n        1. `converting HEAP to MyISAM` 查询结果太大， 内存都不够用了网磁盘上搬了\n        2. `Creating tmp table` 创建临时表\n        3. 拷贝数据到临时表：假设要查询两百万数据，刚好匹配的条件有一百万，恰巧要把这一百万的数据拷贝到临时表，然后再把数据推送给用户，最后再把临时表删掉，这个时候就是导致SQL变慢的罪魁祸首\n        4. 用完再删除\n        5. `Copying to tmp table on disk` 把内存中临时表复制到磁盘，危险！！！\n        6. `locked`\n\n\n### 5. 全局查询日志\n切记：**永远不要再生产环境开启这个功能**。\n全局查询日志有时也能帮助我们来调SQL。但是，切记，这家伙只能在测试环境使用，绝不可以在生产环境使用。\n1. 命令启用\n``` sql\nmysql> set global general_log=1; #开启后会把所有的SQL偷偷的记录\nmysql> set global log_output='TABLE';\n```\n\n2. 配置启用,  在MySQL的my.cnf中，设置如下：\n``` sql\n#开启\ngeneral_log=1\n#记录日志文件的路径\ngeneral_log_file=/path/logfile\n#输出格式\nlog_output=file\n```\n\n3. 此后，你所编写的SQL语句，将会记录到MySQL库里的general_log表，可以用下面的命令查看。\n``` sql\nselect * from mysql.general_log;\n```\n> 场景：如果需要做系统的定案分析(今天下午2点-3点出的故障），如果要观察和复现的话，可以在测试环境下模拟一遍，然后把所有的问题复现一下。那么用general_log这个表来收集什么时间段发生了什么样的SQL，帮助我们定位收集。\n\n\n\n","slug":"【数据库优化】MySQL慢日志查询分析","published":1,"updated":"2021-12-12T02:50:23.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6wn0024vcue145jcdnu","content":"<p>同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。<span id=\"more\"></span></p>\n<ul>\n<li>错误日志：记录启动、运行或停止mysqld时出现的问题。</li>\n<li>通用日志：记录建立的客户端连接和执行的语句。</li>\n<li>更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。</li>\n<li>二进制日志：记录所有更改数据的语句。还用于复制。</li>\n<li>慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询</li>\n<li>Innodb日志：InnoDB redo log(记录了事务的行为，可以很好的通过其对页进行“重做”操作)</li>\n</ul>\n<h3 id=\"1-开启慢查询日志\"><a href=\"#1-开启慢查询日志\" class=\"headerlink\" title=\"1. 开启慢查询日志\"></a>1. 开启慢查询日志</h3><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。<br>通过<code>show variables like &#39;slow_query%&#39;;</code>查询是否开了慢查询(默认禁用OFF)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------+------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Variable_name       <span class=\"operator\">|</span> <span class=\"keyword\">Value</span>                                                <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------+------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> slow_query_log      <span class=\"operator\">|</span> OFF                                                  <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> slow_query_log_file <span class=\"operator\">|</span> D:\\mysql<span class=\"number\">-5.7</span><span class=\"number\">.27</span><span class=\"operator\">-</span>winx64\\data\\DESKTOP<span class=\"operator\">-</span>E9F062A<span class=\"operator\">-</span>slow.log <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------+------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>slow_query_log</code> 慢查询开启状态  OFF 未开启 ON 为开启<br><code>slow_query_log_file</code> 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</p>\n</blockquote>\n<p>开启慢查询，需要设置<code>slow_query_log</code>参数。当然，如果不是调优需要的话，一般不建议开启该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志写入文件。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"operator\">/</span><span class=\"operator\">/</span>设置开启或者关闭，<span class=\"number\">0</span>为关闭，<span class=\"number\">1</span>为开启</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time <span class=\"operator\">=</span> <span class=\"number\">3</span>;  <span class=\"operator\">/</span><span class=\"operator\">/</span>设置慢的阙值时间，默认<span class=\"number\">10</span>秒</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果通过终端命令设定的话，需要重新连接或新开一个会话才能看到修改值</p>\n</blockquote>\n<p>使用set global slow_query_log 命令开启慢查询日志，只对当前数据库生效，如果Mysql重启后则会失效。如果要永久生效，必须修改my.cnf配置文件(其他系统变量也是如此)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">slow_query_log <span class=\"operator\">=</span> <span class=\"number\">1</span> #开启</span><br><span class=\"line\">slow_query_log_file <span class=\"operator\">=</span> <span class=\"operator\">/</span>mysql<span class=\"number\">-5.7</span><span class=\"number\">.27</span><span class=\"operator\">-</span>winx64<span class=\"operator\">/</span>data<span class=\"operator\">/</span>mysql<span class=\"operator\">-</span>slow.log #默认host_name_show.log</span><br><span class=\"line\">long_query_time <span class=\"operator\">=</span> <span class=\"number\">3</span> #默认<span class=\"number\">10</span>秒（查询超过多少秒才记录）</span><br><span class=\"line\">log<span class=\"operator\">-</span>queries<span class=\"operator\">-</span><span class=\"keyword\">not</span><span class=\"operator\">-</span><span class=\"keyword\">using</span><span class=\"operator\">-</span>indexes <span class=\"operator\">=</span> <span class=\"keyword\">on</span> #如果值设置为<span class=\"keyword\">ON</span>，则会记录所有没有利用索引的查询，一般在性能调优的时候会暂时开启。</span><br><span class=\"line\">log_output <span class=\"operator\">=</span> <span class=\"string\">&#x27;FILE,TABLE&#x27;</span> #输出的格式(FILE:文本, <span class=\"keyword\">TABLE</span>:表中, FILE,<span class=\"keyword\">TABLE</span>:同时输出到文本和表中)</span><br></pre></td></tr></table></figure>\n\n<p>插入一条测试慢查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> sleep(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>通过MySQL命令查看有多少慢查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%Slow_queries%&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------+-------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Variable_name <span class=\"operator\">|</span> <span class=\"keyword\">Value</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------+-------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Slow_queries  <span class=\"operator\">|</span> <span class=\"number\">1</span>     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------+-------+</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-慢查询日志分析工具\"><a href=\"#2-慢查询日志分析工具\" class=\"headerlink\" title=\"2. 慢查询日志分析工具\"></a>2. 慢查询日志分析工具</h3><table>\n<thead>\n<tr>\n<th>工具</th>\n<th>一般统计</th>\n<th>高级统计</th>\n<th>语言</th>\n<th>优势</th>\n<th>针对log</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mysqldumpslow</td>\n<td><code>√</code></td>\n<td><code>×</code></td>\n<td>perl</td>\n<td>mysql官方自带</td>\n<td>slow</td>\n</tr>\n<tr>\n<td>myprofi</td>\n<td><code>√</code></td>\n<td><code>×</code></td>\n<td>php</td>\n<td>简单</td>\n<td>slow</td>\n</tr>\n<tr>\n<td>mysql-log-filter</td>\n<td><code>√</code></td>\n<td>部分<code>√</code></td>\n<td>python</td>\n<td>简单</td>\n<td>slow</td>\n</tr>\n<tr>\n<td>mysql-explain-slow-log</td>\n<td><code>√</code></td>\n<td><code>×</code></td>\n<td>perl</td>\n<td>无</td>\n<td>slow</td>\n</tr>\n<tr>\n<td>mysqlbinlog</td>\n<td><code>√</code></td>\n<td><code>×</code></td>\n<td>二进制</td>\n<td>mysql官方自带</td>\n<td>binary log</td>\n</tr>\n<tr>\n<td>mysqlsla</td>\n<td><code>√</code></td>\n<td><code>√</code></td>\n<td>perl</td>\n<td>总能强大，使用简单，自定义能力强</td>\n<td>所有日志，包括自定义日志</td>\n</tr>\n<tr>\n<td>pt-query-digest</td>\n<td><code>√</code></td>\n<td><code>√</code></td>\n<td>perl</td>\n<td>总能强大，使用简单，自定义能力强</td>\n<td>所有日志，包括自定义日志</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-1-mysqldumpslow\"><a href=\"#2-1-mysqldumpslow\" class=\"headerlink\" title=\"2.1 mysqldumpslow\"></a>2.1 mysqldumpslow</h4><ul>\n<li>MySQL自带的慢查询日志分析工具mysqldumpslow主要功能是, 统计不同慢sql的:<ul>\n<li>出现次数(Count),</li>\n<li>执行最长时间(Time), </li>\n<li>累计总耗费时间(Time),</li>\n<li>等待锁的时间(Lock), </li>\n<li>发送给客户端的行总数(Rows),</li>\n<li>扫描的行总数(Rows), </li>\n<li>用户以及sql语句本身(抽象了一下格式, 比如 limit 1, 20 用 limit N,N 表示).<br>安装后基本使用：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>data<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql<span class=\"operator\">-</span>slow.log  <span class=\"operator\">/</span><span class=\"operator\">/</span>得到返回记录集最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s c <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>data<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql<span class=\"operator\">-</span>slow.log <span class=\"operator\">/</span><span class=\"operator\">/</span>得到访问次数最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span> </span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s t <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">-</span>g &quot;left join&quot; <span class=\"operator\">/</span>data<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql<span class=\"operator\">-</span>slow.log  <span class=\"operator\">/</span><span class=\"operator\">/</span>得到按照时间排序的前<span class=\"number\">10</span>条里面含有做了连接的查询<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>data<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql<span class=\"operator\">-</span>slow.log <span class=\"operator\">|</span> more  <span class=\"operator\">/</span><span class=\"operator\">/</span>另外建议在使用这些命令时结合<span class=\"operator\">|</span>和more使用，否则有可能出现爆屏情况</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-mysqlsla\"><a href=\"#2-2-mysqlsla\" class=\"headerlink\" title=\"2.2 mysqlsla\"></a>2.2 mysqlsla</h4><p>hackmysql.com推出的一款日志分析工具(该网站还维护了 mysqlreport, mysqlidxchk 等比较实用的mysql工具)</p>\n<ul>\n<li>整体来说, 功能非常强大. 数据报表,非常有利于分析慢查询的原因, 包括执行频率, 数据量, 查询消耗等.</li>\n</ul>\n<p>安装后基本使用方法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqlsla <span class=\"operator\">-</span>lt slow <span class=\"operator\">-</span>sort t_sum <span class=\"operator\">-</span>top <span class=\"number\">1000</span>  <span class=\"operator\">/</span>tmp<span class=\"operator\">/</span>slow_query.log</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>结果选项说明：<ul>\n<li>总查询次数 (queries total),</li>\n<li>去重后的sql数量 (unique),</li>\n<li>输出报表的内容排序(sorted by),</li>\n<li>最重大的慢sql统计信息(包括 平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数)</li>\n<li>Count, sql的执行次数及占总的slow log数量的百分比.</li>\n<li>Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.</li>\n<li>95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.</li>\n<li>Lock Time, 等待锁的时间.</li>\n<li>95% of Lock , 95%的慢sql等待锁时间.</li>\n<li>Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.</li>\n<li>Rows examined, 扫描的行数量.</li>\n<li>Database, 属于哪个数据库</li>\n<li>Users, 哪个用户,IP, 占到所有用户执行的sql百分比</li>\n<li>Query abstract, 抽象后的sql语句</li>\n<li>Query sample, sql语句</li>\n</ul>\n</li>\n<li>mysqlsla常用参数说明：<ol>\n<li><code>-log-type (-lt) type logs</code>:通过这个参数来制定log的类型，主要有slow, general, binary, msl, udl,分析slow log时通过制定为slow</li>\n<li><code>-sort</code>:t_sum:按总时间排序(默认)，c_sum:按总次数排序c_sum_p: sql语句执行次数占总执行次数的百分比。</li>\n<li><code>-top</code>:显示sql的数量，默认是10,表示按规则取排序的前多少条</li>\n<li><code>–statement-filter (-sf) [+-][TYPE]</code>:过滤sql语句的类型，比如select、update、drop，[TYPE] 有SELECT, CREATE, DROP, UPDATE, INSERT，例如”+SELECT,INSERT”，不出现的默认是-，即不包括。</li>\n<li><code>-db</code>：要处理哪个库的日志：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 举个例子，只取funsion数据库的<span class=\"keyword\">select</span>语句，并按照总时间排序，取前<span class=\"number\">1000</span>条数据</span><br><span class=\"line\"># 保存到当前目录下的 slow_query.pretty.log文件中</span><br><span class=\"line\">mysqlsla <span class=\"operator\">-</span>lt slow  <span class=\"operator\">-</span>sort t_sum  <span class=\"operator\">-</span>sf &quot;+select&quot;  <span class=\"operator\">-</span>db funsion  <span class=\"operator\">-</span>top <span class=\"number\">1000</span>  <span class=\"operator\">/</span>tmp<span class=\"operator\">/</span>slow_query.log <span class=\"operator\">&gt;</span> .<span class=\"operator\">/</span>slow_query.pretty.log</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>深度使用可参考： <a href=\"https://yq.aliyun.com/articles/59260\">MySQL日志分析神器之mysqlsla</a></p>\n</blockquote>\n<h4 id=\"2-3-pt-query-digest\"><a href=\"#2-3-pt-query-digest\" class=\"headerlink\" title=\"2.3 pt-query-digest\"></a>2.3 pt-query-digest</h4><p>pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 分析最近<span class=\"number\">12</span>小时内的查询：</span><br><span class=\"line\">pt<span class=\"operator\">-</span>query<span class=\"operator\">-</span>digest  <span class=\"comment\">--since=12h  slow.log &gt; slow_report2.log</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>pt-query-digest语法及重要选项<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pt<span class=\"operator\">-</span>query<span class=\"operator\">-</span>digest [OPTIONS] [FILES] [DSN]</span><br><span class=\"line\">    <span class=\"comment\">--create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class=\"line\">    <span class=\"comment\">--create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class=\"line\">    <span class=\"comment\">--filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span></span><br><span class=\"line\">    <span class=\"comment\">--limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span></span><br><span class=\"line\">    <span class=\"comment\">--host  mysql服务器地址</span></span><br><span class=\"line\">    <span class=\"comment\">--user  mysql用户名</span></span><br><span class=\"line\">    <span class=\"comment\">--password  mysql用户密码</span></span><br><span class=\"line\">    <span class=\"comment\">--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span></span><br><span class=\"line\">    <span class=\"comment\">--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。</span></span><br><span class=\"line\">    <span class=\"comment\">--output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</span></span><br><span class=\"line\">    <span class=\"comment\">--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span></span><br><span class=\"line\">    <span class=\"comment\">--until 截止时间，配合—since可以分析一段时间内的慢查询。</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>分析pt-query-digest输出结果</p>\n<ol>\n<li>总体统计结果<ul>\n<li>Overall：总共有多少条查询</li>\n<li>Time range：查询执行的时间范围</li>\n<li>unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</li>\n<li>total：总计   min：最小   max：最大  avg：平均</li>\n<li>95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</li>\n<li>median：中位数，把所有值从小到大排列，位置位于中间那个数</li>\n</ul>\n</li>\n<li>查询分组统计结果<ul>\n<li>Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定</li>\n<li>Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</li>\n<li>Response：总的响应时间</li>\n<li>time：该查询在本次分析中总的时间占比</li>\n<li>calls：执行次数，即本次分析总共有多少条这种类型的查询语句</li>\n<li>R/Call：平均每次执行的响应时间</li>\n<li>V/M：响应时间Variance-to-mean的比率</li>\n<li>Item：查询对象</li>\n</ul>\n</li>\n<li>每一种查询的详细统计结果<ul>\n<li>由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。</li>\n<li>ID：查询的ID号，和上图的Query ID对应</li>\n<li>Databases：数据库名</li>\n<li>Users：各个用户执行的次数（占比）</li>\n<li>Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。</li>\n<li>Tables：查询中涉及到的表</li>\n<li>Explain：SQL语句</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-explain查看执行计划\"><a href=\"#3-explain查看执行计划\" class=\"headerlink\" title=\"3. explain查看执行计划\"></a>3. explain查看执行计划</h3><p>在上面的慢查询中，我们已经将查询时间超过阀值的sql语句过滤了出来，<code>explain+查询语句</code>具体分析是哪里出了问题。<br>MySQL 提供了一个 <code>Explain</code> 命令, 它可以对 select 语句进行分析, 并输出 select 执行的详细信息, 以供开发人员针对性优化.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> explain <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> user_info <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">2</span>\\G</span><br><span class=\"line\"><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span> <span class=\"number\">1.</span> <span class=\"type\">row</span> <span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">           id: <span class=\"number\">1</span></span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">        <span class=\"keyword\">table</span>: user_info</span><br><span class=\"line\">   partitions: <span class=\"keyword\">NULL</span></span><br><span class=\"line\">         type: const</span><br><span class=\"line\">possible_keys: <span class=\"keyword\">PRIMARY</span></span><br><span class=\"line\">          key: <span class=\"keyword\">PRIMARY</span></span><br><span class=\"line\">      key_len: <span class=\"number\">8</span></span><br><span class=\"line\">          <span class=\"keyword\">ref</span>: const</span><br><span class=\"line\">         <span class=\"keyword\">rows</span>: <span class=\"number\">1</span></span><br><span class=\"line\">     filtered: <span class=\"number\">100.00</span></span><br><span class=\"line\">        Extra: <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"type\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span>, <span class=\"number\">1</span> warning (<span class=\"number\">0.06</span> sec)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>各列的含义如下:</p>\n<ul>\n<li><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>\n<li><code>select_type</code>: SELECT 查询的类型.<ul>\n<li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li>\n<li>PRIMARY, 表示此查询是最外层的查询</li>\n<li>UNION, 表示此查询是 UNION 的第二或随后的查询</li>\n<li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li>\n<li>UNION RESULT, UNION 的结果</li>\n<li>SUBQUERY, 子查询中的第一个 SELECT</li>\n<li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li>\n</ul>\n</li>\n<li><code>table</code>: 查询的是哪个表</li>\n<li><code>partitions</code>: 匹配的分区</li>\n<li><code>type</code>: join 类型<ul>\n<li>type字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过<code>type</code>字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</li>\n<li>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</li>\n<li>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li>\n<li>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. </li>\n<li>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.</li>\n<li>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li>\n<li>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li>\n<li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难.</li>\n</ul>\n</li>\n<li><code>possible_keys</code>: 此次查询中可能选用的索引<ul>\n<li>表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</li>\n</ul>\n</li>\n<li><code>key</code>: 此字段是 MySQL 在当前查询时所真正使用到的索引.</li>\n<li><code>key_len</code>: 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.</li>\n<li><code>ref</code>: 哪个字段或常数与 key 一起被使用</li>\n<li><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.<ul>\n<li>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数, 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</li>\n</ul>\n</li>\n<li><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</li>\n<li><code>extra</code>: EXplain 中的很多额外的信息会在 Extra 字段显示<ul>\n<li>Using filesort: 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li>\n<li>Using index: “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>\n<li>Using temporary: 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:</p>\n</li>\n</ol>\n<ul>\n<li><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><ul>\n<li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</li>\n<li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</li>\n<li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-MySQL性能分析语句show-profile\"><a href=\"#4-MySQL性能分析语句show-profile\" class=\"headerlink\" title=\"4. MySQL性能分析语句show profile\"></a>4. MySQL性能分析语句show profile</h3><p>Query Profile是MySQL自带的一种Query诊断分析工具，可以完整的显示一条sql执行的各方面的详细信息，默认关闭;</p>\n<ol>\n<li><p>看看当前的MySQL版本是否支持: <code>show variables like &#39;profiling&#39;;</code>或<code>show variables like &#39;profiling%&#39;;</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;profiling%&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------------+-------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Variable_name          <span class=\"operator\">|</span> <span class=\"keyword\">Value</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------------+-------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> profiling              <span class=\"operator\">|</span> OFF   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> profiling_history_size <span class=\"operator\">|</span> <span class=\"number\">15</span>    <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------------+-------+</span></span><br></pre></td></tr></table></figure></li>\n<li><p>使用前需要开启: <code>set profiling = 1; (1:开 / 0:关)</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> profiling <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>运行sql后</strong>，查询结果<code>show profiles;</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SHOW</span> PROFILES\\G</span><br><span class=\"line\"><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span> <span class=\"number\">1.</span> <span class=\"type\">row</span> <span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">Query_ID: <span class=\"number\">1</span></span><br><span class=\"line\">Duration: <span class=\"number\">0.02949950</span></span><br><span class=\"line\">   Query: explain <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span> <span class=\"number\">2.</span> <span class=\"type\">row</span> <span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">Query_ID: <span class=\"number\">2</span></span><br><span class=\"line\">Duration: <span class=\"number\">0.03405350</span></span><br><span class=\"line\">   Query: <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> housedemo</span><br><span class=\"line\"><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span> <span class=\"number\">3.</span> <span class=\"type\">row</span> <span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">Query_ID: <span class=\"number\">3</span></span><br><span class=\"line\">Duration: <span class=\"number\">0.07813800</span></span><br><span class=\"line\">   Query: <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> house</span><br><span class=\"line\"><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span> <span class=\"number\">4.</span> <span class=\"type\">row</span> <span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">Query_ID: <span class=\"number\">4</span></span><br><span class=\"line\">Duration: <span class=\"number\">0.00018150</span></span><br><span class=\"line\">   Query: <span class=\"keyword\">show</span> prifiles</span><br></pre></td></tr></table></figure></li>\n<li><p>诊断SQL, show profile <code>Type</code> io for query <code>Query_ID</code></p>\n<ul>\n<li>LIMIT部分的用法与SELECT中LIMIT子句一致，不赘述。</li>\n<li>Type是可选的，取值范围可以如下：<ul>\n<li><code>ALL</code> 显示所有性能信息</li>\n<li><code>BLOCK IO</code> 显示块IO操作的次数</li>\n<li><code>CONTEXT SWITCHES</code> 显示上下文切换次数，不管是主动还是被动</li>\n<li><code>CPU</code> 显示用户CPU时间、系统CPU时间</li>\n<li><code>IPC</code> 显示发送和接收的消息数量</li>\n<li><code>MEMORY</code> [暂未实现]</li>\n<li><code>PAGE FAULTS</code> 显示页错误数量</li>\n<li><code>SOURCE</code> 显示源码中的函数名称与位置</li>\n<li><code>SWAPS</code> 显示SWAP的次数</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> profile cpu,block io <span class=\"keyword\">for</span> query <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Status               <span class=\"operator\">|</span> Duration <span class=\"operator\">|</span> CPU_user <span class=\"operator\">|</span> CPU_system <span class=\"operator\">|</span> Block_ops_in <span class=\"operator\">|</span> Block_ops_out <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> starting             <span class=\"operator\">|</span> <span class=\"number\">0.000077</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> checking permissions <span class=\"operator\">|</span> <span class=\"number\">0.000013</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Opening tables       <span class=\"operator\">|</span> <span class=\"number\">0.031992</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> init                 <span class=\"operator\">|</span> <span class=\"number\">0.000059</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">System</span> lock          <span class=\"operator\">|</span> <span class=\"number\">0.000016</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> optimizing           <span class=\"operator\">|</span> <span class=\"number\">0.000007</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> statistics           <span class=\"operator\">|</span> <span class=\"number\">0.000017</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> preparing            <span class=\"operator\">|</span> <span class=\"number\">0.008535</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> executing            <span class=\"operator\">|</span> <span class=\"number\">0.000016</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Sending data         <span class=\"operator\">|</span> <span class=\"number\">0.037234</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">end</span>                  <span class=\"operator\">|</span> <span class=\"number\">0.000011</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> query <span class=\"keyword\">end</span>            <span class=\"operator\">|</span> <span class=\"number\">0.000012</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> closing tables       <span class=\"operator\">|</span> <span class=\"number\">0.000014</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> freeing items        <span class=\"operator\">|</span> <span class=\"number\">0.000108</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> cleaning up          <span class=\"operator\">|</span> <span class=\"number\">0.000030</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----------------------+----------+----------+------------+--------------+---------------+</span></span><br></pre></td></tr></table></figure>\n\n<p>从图中可以看到开始，打开表，加载，关闭表，释放资源、记录日志，清理的你工作，在这完全可以看到一条SQL的完整生命周期。</p>\n<ol start=\"5\">\n<li>日常开发需要注意<ul>\n<li>如果show profile … for query id；出现了如下四个，则必须优化这条sql。<ol>\n<li><code>converting HEAP to MyISAM</code> 查询结果太大， 内存都不够用了网磁盘上搬了</li>\n<li><code>Creating tmp table</code> 创建临时表</li>\n<li>拷贝数据到临时表：假设要查询两百万数据，刚好匹配的条件有一百万，恰巧要把这一百万的数据拷贝到临时表，然后再把数据推送给用户，最后再把临时表删掉，这个时候就是导致SQL变慢的罪魁祸首</li>\n<li>用完再删除</li>\n<li><code>Copying to tmp table on disk</code> 把内存中临时表复制到磁盘，危险！！！</li>\n<li><code>locked</code></li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-全局查询日志\"><a href=\"#5-全局查询日志\" class=\"headerlink\" title=\"5. 全局查询日志\"></a>5. 全局查询日志</h3><p>切记：<strong>永远不要再生产环境开启这个功能</strong>。<br>全局查询日志有时也能帮助我们来调SQL。但是，切记，这家伙只能在测试环境使用，绝不可以在生产环境使用。</p>\n<ol>\n<li><p>命令启用</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #开启后会把所有的<span class=\"keyword\">SQL</span>偷偷的记录</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_output<span class=\"operator\">=</span><span class=\"string\">&#x27;TABLE&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>配置启用,  在MySQL的my.cnf中，设置如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#开启</span><br><span class=\"line\">general_log<span class=\"operator\">=</span><span class=\"number\">1</span></span><br><span class=\"line\">#记录日志文件的路径</span><br><span class=\"line\">general_log_file<span class=\"operator\">=</span><span class=\"operator\">/</span>path<span class=\"operator\">/</span>logfile</span><br><span class=\"line\">#输出格式</span><br><span class=\"line\">log_output<span class=\"operator\">=</span>file</span><br></pre></td></tr></table></figure></li>\n<li><p>此后，你所编写的SQL语句，将会记录到MySQL库里的general_log表，可以用下面的命令查看。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> mysql.general_log;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>场景：如果需要做系统的定案分析(今天下午2点-3点出的故障），如果要观察和复现的话，可以在测试环境下模拟一遍，然后把所有的问题复现一下。那么用general_log这个表来收集什么时间段发生了什么样的SQL，帮助我们定位收集。</p>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<p>同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。","more":"</p>\n<ul>\n<li>错误日志：记录启动、运行或停止mysqld时出现的问题。</li>\n<li>通用日志：记录建立的客户端连接和执行的语句。</li>\n<li>更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。</li>\n<li>二进制日志：记录所有更改数据的语句。还用于复制。</li>\n<li>慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询</li>\n<li>Innodb日志：InnoDB redo log(记录了事务的行为，可以很好的通过其对页进行“重做”操作)</li>\n</ul>\n<h3 id=\"1-开启慢查询日志\"><a href=\"#1-开启慢查询日志\" class=\"headerlink\" title=\"1. 开启慢查询日志\"></a>1. 开启慢查询日志</h3><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。<br>通过<code>show variables like &#39;slow_query%&#39;;</code>查询是否开了慢查询(默认禁用OFF)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------+------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Variable_name       <span class=\"operator\">|</span> <span class=\"keyword\">Value</span>                                                <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------+------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> slow_query_log      <span class=\"operator\">|</span> OFF                                                  <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> slow_query_log_file <span class=\"operator\">|</span> D:\\mysql<span class=\"number\">-5.7</span><span class=\"number\">.27</span><span class=\"operator\">-</span>winx64\\data\\DESKTOP<span class=\"operator\">-</span>E9F062A<span class=\"operator\">-</span>slow.log <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------------+------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>slow_query_log</code> 慢查询开启状态  OFF 未开启 ON 为开启<br><code>slow_query_log_file</code> 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</p>\n</blockquote>\n<p>开启慢查询，需要设置<code>slow_query_log</code>参数。当然，如果不是调优需要的话，一般不建议开启该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志写入文件。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"operator\">/</span><span class=\"operator\">/</span>设置开启或者关闭，<span class=\"number\">0</span>为关闭，<span class=\"number\">1</span>为开启</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time <span class=\"operator\">=</span> <span class=\"number\">3</span>;  <span class=\"operator\">/</span><span class=\"operator\">/</span>设置慢的阙值时间，默认<span class=\"number\">10</span>秒</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果通过终端命令设定的话，需要重新连接或新开一个会话才能看到修改值</p>\n</blockquote>\n<p>使用set global slow_query_log 命令开启慢查询日志，只对当前数据库生效，如果Mysql重启后则会失效。如果要永久生效，必须修改my.cnf配置文件(其他系统变量也是如此)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">slow_query_log <span class=\"operator\">=</span> <span class=\"number\">1</span> #开启</span><br><span class=\"line\">slow_query_log_file <span class=\"operator\">=</span> <span class=\"operator\">/</span>mysql<span class=\"number\">-5.7</span><span class=\"number\">.27</span><span class=\"operator\">-</span>winx64<span class=\"operator\">/</span>data<span class=\"operator\">/</span>mysql<span class=\"operator\">-</span>slow.log #默认host_name_show.log</span><br><span class=\"line\">long_query_time <span class=\"operator\">=</span> <span class=\"number\">3</span> #默认<span class=\"number\">10</span>秒（查询超过多少秒才记录）</span><br><span class=\"line\">log<span class=\"operator\">-</span>queries<span class=\"operator\">-</span><span class=\"keyword\">not</span><span class=\"operator\">-</span><span class=\"keyword\">using</span><span class=\"operator\">-</span>indexes <span class=\"operator\">=</span> <span class=\"keyword\">on</span> #如果值设置为<span class=\"keyword\">ON</span>，则会记录所有没有利用索引的查询，一般在性能调优的时候会暂时开启。</span><br><span class=\"line\">log_output <span class=\"operator\">=</span> <span class=\"string\">&#x27;FILE,TABLE&#x27;</span> #输出的格式(FILE:文本, <span class=\"keyword\">TABLE</span>:表中, FILE,<span class=\"keyword\">TABLE</span>:同时输出到文本和表中)</span><br></pre></td></tr></table></figure>\n\n<p>插入一条测试慢查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> sleep(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>通过MySQL命令查看有多少慢查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%Slow_queries%&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------+-------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Variable_name <span class=\"operator\">|</span> <span class=\"keyword\">Value</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------+-------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Slow_queries  <span class=\"operator\">|</span> <span class=\"number\">1</span>     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">---------------+-------+</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-慢查询日志分析工具\"><a href=\"#2-慢查询日志分析工具\" class=\"headerlink\" title=\"2. 慢查询日志分析工具\"></a>2. 慢查询日志分析工具</h3><table>\n<thead>\n<tr>\n<th>工具</th>\n<th>一般统计</th>\n<th>高级统计</th>\n<th>语言</th>\n<th>优势</th>\n<th>针对log</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mysqldumpslow</td>\n<td><code>√</code></td>\n<td><code>×</code></td>\n<td>perl</td>\n<td>mysql官方自带</td>\n<td>slow</td>\n</tr>\n<tr>\n<td>myprofi</td>\n<td><code>√</code></td>\n<td><code>×</code></td>\n<td>php</td>\n<td>简单</td>\n<td>slow</td>\n</tr>\n<tr>\n<td>mysql-log-filter</td>\n<td><code>√</code></td>\n<td>部分<code>√</code></td>\n<td>python</td>\n<td>简单</td>\n<td>slow</td>\n</tr>\n<tr>\n<td>mysql-explain-slow-log</td>\n<td><code>√</code></td>\n<td><code>×</code></td>\n<td>perl</td>\n<td>无</td>\n<td>slow</td>\n</tr>\n<tr>\n<td>mysqlbinlog</td>\n<td><code>√</code></td>\n<td><code>×</code></td>\n<td>二进制</td>\n<td>mysql官方自带</td>\n<td>binary log</td>\n</tr>\n<tr>\n<td>mysqlsla</td>\n<td><code>√</code></td>\n<td><code>√</code></td>\n<td>perl</td>\n<td>总能强大，使用简单，自定义能力强</td>\n<td>所有日志，包括自定义日志</td>\n</tr>\n<tr>\n<td>pt-query-digest</td>\n<td><code>√</code></td>\n<td><code>√</code></td>\n<td>perl</td>\n<td>总能强大，使用简单，自定义能力强</td>\n<td>所有日志，包括自定义日志</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-1-mysqldumpslow\"><a href=\"#2-1-mysqldumpslow\" class=\"headerlink\" title=\"2.1 mysqldumpslow\"></a>2.1 mysqldumpslow</h4><ul>\n<li>MySQL自带的慢查询日志分析工具mysqldumpslow主要功能是, 统计不同慢sql的:<ul>\n<li>出现次数(Count),</li>\n<li>执行最长时间(Time), </li>\n<li>累计总耗费时间(Time),</li>\n<li>等待锁的时间(Lock), </li>\n<li>发送给客户端的行总数(Rows),</li>\n<li>扫描的行总数(Rows), </li>\n<li>用户以及sql语句本身(抽象了一下格式, 比如 limit 1, 20 用 limit N,N 表示).<br>安装后基本使用：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>data<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql<span class=\"operator\">-</span>slow.log  <span class=\"operator\">/</span><span class=\"operator\">/</span>得到返回记录集最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s c <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>data<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql<span class=\"operator\">-</span>slow.log <span class=\"operator\">/</span><span class=\"operator\">/</span>得到访问次数最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span> </span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s t <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">-</span>g &quot;left join&quot; <span class=\"operator\">/</span>data<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql<span class=\"operator\">-</span>slow.log  <span class=\"operator\">/</span><span class=\"operator\">/</span>得到按照时间排序的前<span class=\"number\">10</span>条里面含有做了连接的查询<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>data<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>mysql<span class=\"operator\">-</span>slow.log <span class=\"operator\">|</span> more  <span class=\"operator\">/</span><span class=\"operator\">/</span>另外建议在使用这些命令时结合<span class=\"operator\">|</span>和more使用，否则有可能出现爆屏情况</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-mysqlsla\"><a href=\"#2-2-mysqlsla\" class=\"headerlink\" title=\"2.2 mysqlsla\"></a>2.2 mysqlsla</h4><p>hackmysql.com推出的一款日志分析工具(该网站还维护了 mysqlreport, mysqlidxchk 等比较实用的mysql工具)</p>\n<ul>\n<li>整体来说, 功能非常强大. 数据报表,非常有利于分析慢查询的原因, 包括执行频率, 数据量, 查询消耗等.</li>\n</ul>\n<p>安装后基本使用方法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqlsla <span class=\"operator\">-</span>lt slow <span class=\"operator\">-</span>sort t_sum <span class=\"operator\">-</span>top <span class=\"number\">1000</span>  <span class=\"operator\">/</span>tmp<span class=\"operator\">/</span>slow_query.log</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>结果选项说明：<ul>\n<li>总查询次数 (queries total),</li>\n<li>去重后的sql数量 (unique),</li>\n<li>输出报表的内容排序(sorted by),</li>\n<li>最重大的慢sql统计信息(包括 平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数)</li>\n<li>Count, sql的执行次数及占总的slow log数量的百分比.</li>\n<li>Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.</li>\n<li>95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.</li>\n<li>Lock Time, 等待锁的时间.</li>\n<li>95% of Lock , 95%的慢sql等待锁时间.</li>\n<li>Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.</li>\n<li>Rows examined, 扫描的行数量.</li>\n<li>Database, 属于哪个数据库</li>\n<li>Users, 哪个用户,IP, 占到所有用户执行的sql百分比</li>\n<li>Query abstract, 抽象后的sql语句</li>\n<li>Query sample, sql语句</li>\n</ul>\n</li>\n<li>mysqlsla常用参数说明：<ol>\n<li><code>-log-type (-lt) type logs</code>:通过这个参数来制定log的类型，主要有slow, general, binary, msl, udl,分析slow log时通过制定为slow</li>\n<li><code>-sort</code>:t_sum:按总时间排序(默认)，c_sum:按总次数排序c_sum_p: sql语句执行次数占总执行次数的百分比。</li>\n<li><code>-top</code>:显示sql的数量，默认是10,表示按规则取排序的前多少条</li>\n<li><code>–statement-filter (-sf) [+-][TYPE]</code>:过滤sql语句的类型，比如select、update、drop，[TYPE] 有SELECT, CREATE, DROP, UPDATE, INSERT，例如”+SELECT,INSERT”，不出现的默认是-，即不包括。</li>\n<li><code>-db</code>：要处理哪个库的日志：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 举个例子，只取funsion数据库的<span class=\"keyword\">select</span>语句，并按照总时间排序，取前<span class=\"number\">1000</span>条数据</span><br><span class=\"line\"># 保存到当前目录下的 slow_query.pretty.log文件中</span><br><span class=\"line\">mysqlsla <span class=\"operator\">-</span>lt slow  <span class=\"operator\">-</span>sort t_sum  <span class=\"operator\">-</span>sf &quot;+select&quot;  <span class=\"operator\">-</span>db funsion  <span class=\"operator\">-</span>top <span class=\"number\">1000</span>  <span class=\"operator\">/</span>tmp<span class=\"operator\">/</span>slow_query.log <span class=\"operator\">&gt;</span> .<span class=\"operator\">/</span>slow_query.pretty.log</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>深度使用可参考： <a href=\"https://yq.aliyun.com/articles/59260\">MySQL日志分析神器之mysqlsla</a></p>\n</blockquote>\n<h4 id=\"2-3-pt-query-digest\"><a href=\"#2-3-pt-query-digest\" class=\"headerlink\" title=\"2.3 pt-query-digest\"></a>2.3 pt-query-digest</h4><p>pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 分析最近<span class=\"number\">12</span>小时内的查询：</span><br><span class=\"line\">pt<span class=\"operator\">-</span>query<span class=\"operator\">-</span>digest  <span class=\"comment\">--since=12h  slow.log &gt; slow_report2.log</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>pt-query-digest语法及重要选项<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pt<span class=\"operator\">-</span>query<span class=\"operator\">-</span>digest [OPTIONS] [FILES] [DSN]</span><br><span class=\"line\">    <span class=\"comment\">--create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class=\"line\">    <span class=\"comment\">--create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class=\"line\">    <span class=\"comment\">--filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span></span><br><span class=\"line\">    <span class=\"comment\">--limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span></span><br><span class=\"line\">    <span class=\"comment\">--host  mysql服务器地址</span></span><br><span class=\"line\">    <span class=\"comment\">--user  mysql用户名</span></span><br><span class=\"line\">    <span class=\"comment\">--password  mysql用户密码</span></span><br><span class=\"line\">    <span class=\"comment\">--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span></span><br><span class=\"line\">    <span class=\"comment\">--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。</span></span><br><span class=\"line\">    <span class=\"comment\">--output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</span></span><br><span class=\"line\">    <span class=\"comment\">--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span></span><br><span class=\"line\">    <span class=\"comment\">--until 截止时间，配合—since可以分析一段时间内的慢查询。</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>分析pt-query-digest输出结果</p>\n<ol>\n<li>总体统计结果<ul>\n<li>Overall：总共有多少条查询</li>\n<li>Time range：查询执行的时间范围</li>\n<li>unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</li>\n<li>total：总计   min：最小   max：最大  avg：平均</li>\n<li>95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</li>\n<li>median：中位数，把所有值从小到大排列，位置位于中间那个数</li>\n</ul>\n</li>\n<li>查询分组统计结果<ul>\n<li>Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定</li>\n<li>Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</li>\n<li>Response：总的响应时间</li>\n<li>time：该查询在本次分析中总的时间占比</li>\n<li>calls：执行次数，即本次分析总共有多少条这种类型的查询语句</li>\n<li>R/Call：平均每次执行的响应时间</li>\n<li>V/M：响应时间Variance-to-mean的比率</li>\n<li>Item：查询对象</li>\n</ul>\n</li>\n<li>每一种查询的详细统计结果<ul>\n<li>由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。</li>\n<li>ID：查询的ID号，和上图的Query ID对应</li>\n<li>Databases：数据库名</li>\n<li>Users：各个用户执行的次数（占比）</li>\n<li>Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。</li>\n<li>Tables：查询中涉及到的表</li>\n<li>Explain：SQL语句</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-explain查看执行计划\"><a href=\"#3-explain查看执行计划\" class=\"headerlink\" title=\"3. explain查看执行计划\"></a>3. explain查看执行计划</h3><p>在上面的慢查询中，我们已经将查询时间超过阀值的sql语句过滤了出来，<code>explain+查询语句</code>具体分析是哪里出了问题。<br>MySQL 提供了一个 <code>Explain</code> 命令, 它可以对 select 语句进行分析, 并输出 select 执行的详细信息, 以供开发人员针对性优化.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> explain <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> user_info <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">2</span>\\G</span><br><span class=\"line\"><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span> <span class=\"number\">1.</span> <span class=\"type\">row</span> <span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">           id: <span class=\"number\">1</span></span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">        <span class=\"keyword\">table</span>: user_info</span><br><span class=\"line\">   partitions: <span class=\"keyword\">NULL</span></span><br><span class=\"line\">         type: const</span><br><span class=\"line\">possible_keys: <span class=\"keyword\">PRIMARY</span></span><br><span class=\"line\">          key: <span class=\"keyword\">PRIMARY</span></span><br><span class=\"line\">      key_len: <span class=\"number\">8</span></span><br><span class=\"line\">          <span class=\"keyword\">ref</span>: const</span><br><span class=\"line\">         <span class=\"keyword\">rows</span>: <span class=\"number\">1</span></span><br><span class=\"line\">     filtered: <span class=\"number\">100.00</span></span><br><span class=\"line\">        Extra: <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"type\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span>, <span class=\"number\">1</span> warning (<span class=\"number\">0.06</span> sec)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>各列的含义如下:</p>\n<ul>\n<li><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>\n<li><code>select_type</code>: SELECT 查询的类型.<ul>\n<li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li>\n<li>PRIMARY, 表示此查询是最外层的查询</li>\n<li>UNION, 表示此查询是 UNION 的第二或随后的查询</li>\n<li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li>\n<li>UNION RESULT, UNION 的结果</li>\n<li>SUBQUERY, 子查询中的第一个 SELECT</li>\n<li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li>\n</ul>\n</li>\n<li><code>table</code>: 查询的是哪个表</li>\n<li><code>partitions</code>: 匹配的分区</li>\n<li><code>type</code>: join 类型<ul>\n<li>type字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过<code>type</code>字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</li>\n<li>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</li>\n<li>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li>\n<li>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. </li>\n<li>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.</li>\n<li>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li>\n<li>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li>\n<li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难.</li>\n</ul>\n</li>\n<li><code>possible_keys</code>: 此次查询中可能选用的索引<ul>\n<li>表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</li>\n</ul>\n</li>\n<li><code>key</code>: 此字段是 MySQL 在当前查询时所真正使用到的索引.</li>\n<li><code>key_len</code>: 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.</li>\n<li><code>ref</code>: 哪个字段或常数与 key 一起被使用</li>\n<li><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.<ul>\n<li>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数, 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</li>\n</ul>\n</li>\n<li><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</li>\n<li><code>extra</code>: EXplain 中的很多额外的信息会在 Extra 字段显示<ul>\n<li>Using filesort: 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li>\n<li>Using index: “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>\n<li>Using temporary: 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:</p>\n</li>\n</ol>\n<ul>\n<li><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><ul>\n<li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</li>\n<li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</li>\n<li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-MySQL性能分析语句show-profile\"><a href=\"#4-MySQL性能分析语句show-profile\" class=\"headerlink\" title=\"4. MySQL性能分析语句show profile\"></a>4. MySQL性能分析语句show profile</h3><p>Query Profile是MySQL自带的一种Query诊断分析工具，可以完整的显示一条sql执行的各方面的详细信息，默认关闭;</p>\n<ol>\n<li><p>看看当前的MySQL版本是否支持: <code>show variables like &#39;profiling&#39;;</code>或<code>show variables like &#39;profiling%&#39;;</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;profiling%&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------------+-------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Variable_name          <span class=\"operator\">|</span> <span class=\"keyword\">Value</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------------+-------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> profiling              <span class=\"operator\">|</span> OFF   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> profiling_history_size <span class=\"operator\">|</span> <span class=\"number\">15</span>    <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">------------------------+-------+</span></span><br></pre></td></tr></table></figure></li>\n<li><p>使用前需要开启: <code>set profiling = 1; (1:开 / 0:关)</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> profiling <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>运行sql后</strong>，查询结果<code>show profiles;</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">SHOW</span> PROFILES\\G</span><br><span class=\"line\"><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span> <span class=\"number\">1.</span> <span class=\"type\">row</span> <span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">Query_ID: <span class=\"number\">1</span></span><br><span class=\"line\">Duration: <span class=\"number\">0.02949950</span></span><br><span class=\"line\">   Query: explain <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span> <span class=\"number\">2.</span> <span class=\"type\">row</span> <span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">Query_ID: <span class=\"number\">2</span></span><br><span class=\"line\">Duration: <span class=\"number\">0.03405350</span></span><br><span class=\"line\">   Query: <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> housedemo</span><br><span class=\"line\"><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span> <span class=\"number\">3.</span> <span class=\"type\">row</span> <span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">Query_ID: <span class=\"number\">3</span></span><br><span class=\"line\">Duration: <span class=\"number\">0.07813800</span></span><br><span class=\"line\">   Query: <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> house</span><br><span class=\"line\"><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span> <span class=\"number\">4.</span> <span class=\"type\">row</span> <span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span><span class=\"operator\">*</span></span><br><span class=\"line\">Query_ID: <span class=\"number\">4</span></span><br><span class=\"line\">Duration: <span class=\"number\">0.00018150</span></span><br><span class=\"line\">   Query: <span class=\"keyword\">show</span> prifiles</span><br></pre></td></tr></table></figure></li>\n<li><p>诊断SQL, show profile <code>Type</code> io for query <code>Query_ID</code></p>\n<ul>\n<li>LIMIT部分的用法与SELECT中LIMIT子句一致，不赘述。</li>\n<li>Type是可选的，取值范围可以如下：<ul>\n<li><code>ALL</code> 显示所有性能信息</li>\n<li><code>BLOCK IO</code> 显示块IO操作的次数</li>\n<li><code>CONTEXT SWITCHES</code> 显示上下文切换次数，不管是主动还是被动</li>\n<li><code>CPU</code> 显示用户CPU时间、系统CPU时间</li>\n<li><code>IPC</code> 显示发送和接收的消息数量</li>\n<li><code>MEMORY</code> [暂未实现]</li>\n<li><code>PAGE FAULTS</code> 显示页错误数量</li>\n<li><code>SOURCE</code> 显示源码中的函数名称与位置</li>\n<li><code>SWAPS</code> 显示SWAP的次数</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> profile cpu,block io <span class=\"keyword\">for</span> query <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Status               <span class=\"operator\">|</span> Duration <span class=\"operator\">|</span> CPU_user <span class=\"operator\">|</span> CPU_system <span class=\"operator\">|</span> Block_ops_in <span class=\"operator\">|</span> Block_ops_out <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> starting             <span class=\"operator\">|</span> <span class=\"number\">0.000077</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> checking permissions <span class=\"operator\">|</span> <span class=\"number\">0.000013</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Opening tables       <span class=\"operator\">|</span> <span class=\"number\">0.031992</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> init                 <span class=\"operator\">|</span> <span class=\"number\">0.000059</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">System</span> lock          <span class=\"operator\">|</span> <span class=\"number\">0.000016</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> optimizing           <span class=\"operator\">|</span> <span class=\"number\">0.000007</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> statistics           <span class=\"operator\">|</span> <span class=\"number\">0.000017</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> preparing            <span class=\"operator\">|</span> <span class=\"number\">0.008535</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> executing            <span class=\"operator\">|</span> <span class=\"number\">0.000016</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Sending data         <span class=\"operator\">|</span> <span class=\"number\">0.037234</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">end</span>                  <span class=\"operator\">|</span> <span class=\"number\">0.000011</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> query <span class=\"keyword\">end</span>            <span class=\"operator\">|</span> <span class=\"number\">0.000012</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> closing tables       <span class=\"operator\">|</span> <span class=\"number\">0.000014</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> freeing items        <span class=\"operator\">|</span> <span class=\"number\">0.000108</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> cleaning up          <span class=\"operator\">|</span> <span class=\"number\">0.000030</span> <span class=\"operator\">|</span> <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>   <span class=\"number\">0.000000</span> <span class=\"operator\">|</span>         <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>          <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----------------------+----------+----------+------------+--------------+---------------+</span></span><br></pre></td></tr></table></figure>\n\n<p>从图中可以看到开始，打开表，加载，关闭表，释放资源、记录日志，清理的你工作，在这完全可以看到一条SQL的完整生命周期。</p>\n<ol start=\"5\">\n<li>日常开发需要注意<ul>\n<li>如果show profile … for query id；出现了如下四个，则必须优化这条sql。<ol>\n<li><code>converting HEAP to MyISAM</code> 查询结果太大， 内存都不够用了网磁盘上搬了</li>\n<li><code>Creating tmp table</code> 创建临时表</li>\n<li>拷贝数据到临时表：假设要查询两百万数据，刚好匹配的条件有一百万，恰巧要把这一百万的数据拷贝到临时表，然后再把数据推送给用户，最后再把临时表删掉，这个时候就是导致SQL变慢的罪魁祸首</li>\n<li>用完再删除</li>\n<li><code>Copying to tmp table on disk</code> 把内存中临时表复制到磁盘，危险！！！</li>\n<li><code>locked</code></li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-全局查询日志\"><a href=\"#5-全局查询日志\" class=\"headerlink\" title=\"5. 全局查询日志\"></a>5. 全局查询日志</h3><p>切记：<strong>永远不要再生产环境开启这个功能</strong>。<br>全局查询日志有时也能帮助我们来调SQL。但是，切记，这家伙只能在测试环境使用，绝不可以在生产环境使用。</p>\n<ol>\n<li><p>命令启用</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #开启后会把所有的<span class=\"keyword\">SQL</span>偷偷的记录</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_output<span class=\"operator\">=</span><span class=\"string\">&#x27;TABLE&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>配置启用,  在MySQL的my.cnf中，设置如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#开启</span><br><span class=\"line\">general_log<span class=\"operator\">=</span><span class=\"number\">1</span></span><br><span class=\"line\">#记录日志文件的路径</span><br><span class=\"line\">general_log_file<span class=\"operator\">=</span><span class=\"operator\">/</span>path<span class=\"operator\">/</span>logfile</span><br><span class=\"line\">#输出格式</span><br><span class=\"line\">log_output<span class=\"operator\">=</span>file</span><br></pre></td></tr></table></figure></li>\n<li><p>此后，你所编写的SQL语句，将会记录到MySQL库里的general_log表，可以用下面的命令查看。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> mysql.general_log;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>场景：如果需要做系统的定案分析(今天下午2点-3点出的故障），如果要观察和复现的话，可以在测试环境下模拟一遍，然后把所有的问题复现一下。那么用general_log这个表来收集什么时间段发生了什么样的SQL，帮助我们定位收集。</p>\n</blockquote>\n</li>\n</ol>"},{"title":"【数据库优化】MySQL性能优化基础","date":"2019-09-01T13:36:46.000Z","_content":"\n\n### 1. MySQL基础操作\n#### 1.1 MySQL备份与恢复\n1. 备份：在mysql的安装目录的bin目录下有**mysqldump命令**，可以完成对数据库的备份。 \n    + 语法：`mysqldump -u 用户名 -p 数据库名> 磁盘SQL文件路径` <!-- more -->\n    + 由于mysqldump命令不是sql命令，需要在**dos窗口下使用**。\n    + 仅仅只会备份数据库中的表和数据，恢复时需要先手动创建数据库。\n2. 恢复：先手动创建数据库：`create database 数据库名`\n    + 然后dos窗口：`mysql -u 用户名-p 导入库名< 磁盘SQL文件绝对路径`\n\n\n#### 1.2 MySQL事务基础\n1. 特性(ACID)：**原子性**（Atomicity，或称不可分割性）、**一致性**（Consistency）、**隔离性**（Isolation，又称独立性）、**持久性**（Durability）。\n2. 事务隔离级别：**读未提交**（Read uncommitted）、**读提交**（read committed）、**可重复读**（repeatable read）和**串行化**（Serializable）。\n3. MYSQL事务处理主要有两种方法： \n    1. 用 BEGIN, ROLLBACK, COMMIT来实现:\n        + BEGIN 开始一个事务\n        + COMMIT 事务确认 \n        + ROLLBACK 事务回滚\n    2. 直接用 SET 来改变 MySQL 的自动提交模式: \n        + SET AUTOCOMMIT=0 禁止自动提交\n        + SET AUTOCOMMIT=1 开启自动提交\n4. 事务并发操作出现几种问题: 丢失修改数据、读“脏”数据、数据不一致\n\n\n#### 1.3 查看设置MySQL编码\n1. 查看：`mysql> show variables like 'character%'`\n2. 设置: # `vi /etc/my.cnf`：\n``` java\n[mysqld] \ncharacter‐set‐server=utf8\ncollation‐server=utf8_general_ci\nsql_mode='NO_ENGINE_SUBSTITUTION'\n[mysql] \ndefault‐character‐set = utf8 \n[mysql.server] \ndefault‐character‐set = utf8 \n[mysqld_safe] \ndefault‐character‐set = utf8 \n[client] \ndefault‐character‐set = utf8\n```\n3. mysql的主配置文件: `/etc/my.cnf`\n4. 数据库文件存放位置: `/var/lib/mysql`\n5. 数据库的日志输出存放位置: `/var/log/mysql`\n6. 端口: `Netstat –nltp` 看是否能找到3306的端口\n\n\n#### 1.4 范式\n概念：范式就是符合某一规范级别的关系模式的集合。共有7种范式：`1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF⊃6NF`\n1. 第一范式(1NF, First Normal Form)：字段值具有**原子性**,不能再分(所有关系型数据库系统都满足第一范式);\n    + 例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;\n2. 第二范式(2NF, Second Normal Form)：一个表**必须有主键**,即每行数据都能被唯一的区分(2NF必须先满足第一范式);\n3. 第三范式(3NF, Third Normal Form)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表**不能有冗余字段**(3NF必须先满足第二范式);\n    + 备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;\n    + 例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;\n\n\n\n### 2. SQL语句优化\n#### 2.1 通过慢查日志发现有问题的SQL\n1. 查询次数多且每次查询占用时间长的sql\n    + 通常为**pt-query-digest**分析的前几个查询；该工具可以很清楚的看出每个SQL执行的次数及百分比等信息，执行的次数多，占比比较大的SQL\n2. IO大的sql\n    + 注意pt-query-digest分析中的Rows examine项。扫描的行数越多，IO越大。\n3. 未命中的索引的SQL\n    + 注意pt-query-digest分析中的Rows examine 和Rows Send的对比。说明该SQL的索引命中率不高，对于这种SQL，我们要重点进行关注。\n4. 通过explain查询分析SQL的执行计划, SQL的执行计划侧面反映出了SQL的执行效率，\n\n#### 2.2 常见SQL优化手段\n1. 函数Max()的优化\n    + 在求max的字段**建索引**\n2. 函数Count()的优化：\n    + Count(*):是包含null值；Count(id)：不包含null值\n3. 子查询的优化\n    + 子查询是我们在开发过程中经常使用的一种方式，在通常情况下，需要把**子查询优化为join查询**但在优化是需要注意关联键是否有一对多的关系，要注意重复数据(distinct去重)。\n    + 在用Join进行多表联合查询时，我们通常使用On来建立两个表的关系。其实还有一个更方便的关键字，那就是Using（如果两个表的关联字段名是一样）。\n4. group by的优化: \n    + 最好使用同一表中的列，在子查询中分组\n5. Limit查询的优化：Limit常用于分页处理，时常会伴随order by从句使用，因此大多时候会使用Filesorts这样会造成大量的IO问题。\n    + 优化步骤1：使用有索引的列或主键进行order by操作，因为大家知道，innodb是按照主键的逻辑顺序进行排序的。可以避免很多的IO操作。\n    + 优化步骤2：记录上次返回的主键， 在下次查询时使用主键过滤。（说明：避免了数据量大时扫描过多的记录）\n    + 注意事项：主键要顺序排序并连续的，如果主键中间空缺了某一列，或者某几列，会出现列出数据不足一页的数据；如果不连续的情况，建立一个附加的列index_id列，保证这一列数据要自增的，并添加索引即可。\n\n### 3. 索引的优化\n#### 3.1 索引基础概念\n索引是为了加速对表中数据行的检索而创建的一种分散存储的**数据结构**。\n- 索引的建立是表中**比较有指向性的字段**，相当于目录，比如说行政区域代码，同一个地域的行政区域代码都是相同的，那么给这一列加上索引，避免让它重复扫描，从而达到优化的目的！\n- 创建索引：在执行create table语句时可以创建索引，也可以单独用create index或alter index来为表增加索引。**不能用create index语句创建primary key索引**。\n- 在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为primary key或unique索引。对于单列惟一性索引，这保证单列不包含重复的值。对于**多列惟一性索引，保证多个值的组合不重复**。\n- primary key索引和unique索引非常类似。事实上，**primary key索引仅是一个具有名称PRIMARY的unique索引**。\n- 查看索引：`show index from tblname;`或`show keys from tblname;`\n\n\n#### 3.2 索引的创建与删除\n1. 创建**普通索引**：\n    + 方式1：`create index 索引名 on 表名(列名)`\n    + 方式2：`alter table 表名 add index 索引名(列名)`\n    + 方式3：创建表的时候直接指定: `,index [索引名] (列名)`\n2. 删除索引： `drop index [索引名] on 表名`\n3. 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。\n4. 创建**唯一索引**：\n    + 方式1：`create unique index 索引名 on 表名(列名)`\n    + 方式2：`alter table 表名 add unique 索引名(列名)`\n    + 方式3：创建表的时候直接指定: `,unique [索引名] (列名)`\n\n\n#### 3.3 使用索引的场景\n1. 表的主键自动建立唯一索引\n2. 表的字段唯一约束\n3. 直接条件查询的字段（在SQL中用于条件约束的字段）\n4. 查询中与其它表关联的字段\n5. 查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）\n6. 查询中统计或分组统计的字段\n7. 表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）\n8. 经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）\n9. 数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）\n10. 经常和主字段一块查询但主字段索引值比较多的表字段\n11. 对千万级MySQL数据库建立索引的事项及提高性能的手段\n\n\n#### 3.4 索引的维护及优化（重复及冗余索引）\n增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，**过多的索引会不但会影响使用效率，同时会影响查询效率**，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引\n- 重复索引：重复索引是指相同的列以相同的顺序建立的同类型的索引，如在primary key再建立唯一索引就是重复索引\n- 冗余索引：冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，如对于innodb来说，每一个索引后面，实际上都会包含主键，这时候我们建立的联合索引，又人为的把主键包含进去，那么这个时候就是一个冗余索引。\n- 工具：使用**`pt-duplicate-key-checker`工具检查重复及冗余索引**: `pt-duplicate-key-checker -uroot -padmin -h 127.0.0.1`\n- 索引维护的方法: 由于业务变更，某些索引是后续不需要使用的，就要进行**删除**。\n- 在mysql中，目前只能通过慢查询日志配合pt-index-usage工具来进行索引使用情况的分析；`pt-index-usage -uroot -padmin /var/lib/mysql/mysql-host-slow.log`\n\n\n#### 3.5 设计MySql索引的注意事项\n设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：\n1. **创建索引**\n    + 对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。\n    + 但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。\n2. **复合索引**\n    + 比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;\n    + 如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为**最佳左前缀特性**。\n    + 因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。\n3. 索引不会包含有NULL值的列\n    + 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有**NULL值**，那么这一列对于此复合索引就是**无效**的。所以我们在数据库设计时不要让字段的默认值为NULL。\n4. 使用短索引\n    + 对字符串列进行索引，如果可能应该**指定一个前缀长度**。\n    + 例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。\n5. 排序的索引问题\n    + mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列**创建复合索引**。\n6. like语句操作\n    + 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” **不会使用索引**，而like “aaa%”可以使用索引。\n7. 不要在列上进行运算\n    + select * from users where YEAR(adddate)\n8. 不使用NOT IN操作\n    + NOT IN操作都不会使用索引将进行全表扫描。NOT IN可以**NOT EXISTS代替**\n\n\n\n### 4. MYSQL数据库设计规范与原则\n#### 4.1 设计规范\n1. 命名规范\n    + 采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线'_'组成\n    + 命名简洁明确,多个单词用下划线'_'分隔,长度不超过30个字符\n    + 除非是备份数据库可以加0-9的自然数,如：`'user_db_20191210'`\n    + 表前缀可以有效的把相同关系的表显示在一起,如：`'user_'`\n    + 每个表中必须有自增主键\n    + 表与表之间的相关联字段名称要求尽可能的相同\n2. 字段类型规范\n    + 用尽量少的存储空间来存数一个字段的数据, 例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);\n    + IP地址最好使用int类型;\n    + 固定长度的类型最好使用char,例如：邮编;\n    + 能使用tinyint就不要使用smallint,int;\n    + 最好给每个字段一个默认值, 最好不能为null;\n3. 索引规范\n    + 命名简洁明确,例如：`user_login`表`user_name`字段的索引应为`user_name_index`唯一索引;\n    + 为每个表创建一个主键索引;\n    + 为每个表创建合理的索引;\n    + 建立复合索引请**慎重**;\n\n\n#### 4.2 设计原则\n1. 核心原则\n    + 不在数据库做运算;\n    + cpu计算务必移至业务层;\n    + 控制列数量(字段少而精,字段数建议在20以内);\n    + 平衡范式与冗余(效率优先；往往牺牲范式)\n    + 拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch); \n2. 字段类原则\n    + 用好数值类型(用合适的字段类型节约空间);\n    + 字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);\n    + 避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);\n    + 少用text类型(尽量使用varchar代替text字段); \n3. 索引类原则\n    + 合理使用索引(改善查询,减慢更新,索引一定不是越多越好);\n    + 字符字段必须建前缀索引;\n    + 不在索引做列运算;\n    + innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);\n    + 不用外键(由程序保证约束);\n4. sql类原则\n    + sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);\n    + 简单的事务;\n    + 避免使用trig/func(触发器、函数不用客户端程序取而代之);\n    + 不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性);\n    + OR改写为IN(or的效率是n级别);\n    + OR改写为UNION(mysql的索引合并很弱智);\n    + 避免负向%;\n    + 慎用count(*);\n    + limit高效分页(limit越大，效率越低);\n    + 使用union all替代union(union有去重开销);\n    + 少用连接join;\n    + 使用group by;\n    + 请使用同类型比较;\n    + 打散批量更新;\n\n\n\n### 5. 数据库结构的优化\n#### 5.1 选择合适的数据类型\n数据类型的选择，重点在于“合适”二字\n1. 使用可以存下你的数据的最小的数据类型。（时间类型数据：可以使用varchar类型，可以使用int类型，也可以使用时间戳类型）\n2. 使用简单的数据类型，int要比varchar类型在mysql处理上简单。（int类型存储时间是最好的选择）\n3. 尽可能的使用not null定义字段。（innodb的特性所决定，非not null的值，需要额外的在字段存储，同时也会增加IO和存储的开销）\n4. 尽量少用text类型，非用不可时最好考虑分表。\n\n\n#### 5.2 数据库表的范式化优化\n1. 表范式化\n    + 范式化是指数据库设计的规范，目前说道范式化一般是指第三设计范式。也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。\n2. 反范式化\n    + 反范式化是指为了查询效率的考虑把原本符合**第三范式**的表“适当”的**增加冗余**，以达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。\n\n\n#### 5.3 数据库表的垂直拆分\n所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。\n+ 垂直拆分原则\n    1. 把不常用的字段表单独存放到一个表中。\n    2. 把大字段独立存放到一个表中。\n    3. 把经常一起使用的字段放到一起。\n\n\n#### 5.4 数据库表的水平拆分\n表的水平拆分是为了解决单表数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的\n1. 水平拆分原因\n    + 如果单表的数据量达到上亿条，那么这时候我们尽管加了完美的索引，查询效率低，写入的效率也相应的降低。\n2. 如何将数据平均分为N份\n    1. 对customer_id进行hash运算，如果要拆分为5个表则使用mod（customer_id，5）取出0-4个值。\n    2. 针对不动的hashid把数据存储到不同的表中。\n3. 水平拆分面临的挑战\n    1. 夸分区表进行数据查询\n        + 前端业务统计：业务上给不同的用户返回不同的业务信息，对分区表没有大的挑战。\n    2. 统计及后台报表操作\n        + 但是对后台进行报表统计时，数据量比较大，后台统计时效性比较低，后台就用汇总表，将前后台的表拆分开。\n\n\n\n### 6. 数据库系统配置优化\n数据库是基于操作系统的，目前大多数MySQL都是安装在**linux系统**之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能\n\n#### 6.1 操作系统的优化\n网络方面的配置，要修改`/etc/sysctl.conf`\n1. 增加tcp支持的队列数\n    + `net.ipv4.tcp_max_syn_backlog = 65535`\n2. 减少断开连接时，资源回收(tcp有连接状态)\n    + `net.ipv4.tcp_max_tw_buckets = 8000`\n    + `net.ipv4.tcp_tw_reuse = 1`\n    + `net.ipv4.tcp_tw_recycle = 1`\n    + `net.ipv4.tcp_fin_timeout = 10`\n    + 说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。\n\n\n#### 6.2 打开文件数的限制\n打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改`/etc/security/limits.conf`文件\n- limits.conf中增加以下内容以修改打开文件数量的限制（永久生效）\n    + `*Soft nofile 65535`\n    + `*Hard nofile 65535`\n- 如果一次有效，就要使用`ulimit –n 65535`即可。（默认情况是1024）\n- 除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件\n\n\n#### 6.3 MySQL配置文件优化\nMysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于`/etc/my.cnf`或`/etc/mysql/my.cnf`\n- MySQL**查找配置文件的顺序**可以通过以下命令获得：\n    + `/usr/sbin/mysqld --verbose --help | grep -A 1 'default options'`\n    + 注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。\n\n\n##### 6.3.1 `my.cnf`常用 连接请求 参数\n1. `max_connections`：最大连接数\n    + 如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，MySQL会为每个连接提供连接缓冲区，连接数越多就会开销越多的内存，所以要**适当调整该值**，不能盲目提高设值。\n    + 数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。\n    + `max_used_connections / max_connections * 100% `（**理想值≈ 85%**）: 响应的连接数/最大连接数\n2. `back_log`：能暂存的连接数量\n    + 如果MySQL的连接数据达到`max_connections`时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即`back_log`，如果等待连接的数量超过`back_log`，将不被授予连接资源。\n    + **默认数值是50，可调优为128**，对于Linux系统设置范围为小于512的整数。\n3. `interactive_timeout`：服务器关闭**交互式连接**前等待活动的秒数\n    + 默认数值是28800，可调优为7200。\n4. `wait_timeout`：服务器关闭**非交互连接**之前等待活动的秒数\n    + 指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。\n\n##### 6.3.1 `my.cnf`常用 缓冲区 参数\n1. `key_buffer_size`: 指定索引缓冲区的大小\n    + 它决定索引处理的速度，尤其是索引读的速度。\n    + 它只对**MyISAM表起作用**。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值\n2. `query_cache_size` ：查询缓存的内存\n    + 使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。\n    + 通过检查状态值Qcache_*，可以知道`query_cache_size`设置是否合理（上述状态值可以使用`SHOW STATUS LIKE ‘Qcache%’`获得）。如果`Qcache_lowmem_prunes`的值非常大，则表明经常出现缓冲不够的情况，如果`Qcache_hits`的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果`Qcache_hits`的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入`SQL_NO_CACHE`可以明确表示不使用查询缓冲。\n    + 与查询缓冲有关的参数还有`query_cache_type`、`query_cache_limit`、`query_cache_min_res_unit`。\n        - `query_cache_type`指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。\n        - `query_cache_limit`指定单个查询能够使用的缓冲区大小，缺省为1M。\n        - `query_cache_min_res_unit`指定分配缓冲区空间的最小单位，缺省为4K。检查状态值`Qcache_free_blocks`，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小`query_cache_min_res_unit`。\n3. `record_buffer_size`：顺序扫描缓冲区大小\n    + 每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。\n    + 默认数值是131072(128K)，可改为16773120 (16M)\n4. `read_rnd_buffer_size`：随机读缓冲区大小\n    + 当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M\n5. `sort_buffer_size`：排序扫描缓冲区大小\n    + 每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。\n    + 默认数值是2097144(2M)，可改为16777208 (16M)。\n6. `join_buffer_size`：联合查询缓冲区大小\n    + 联合查询操作所能使用的缓冲区大小。\n    + `record_buffer_size`，`read_rnd_buffer_size`，`sort_buffer_size`，`join_buffer_size`为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100\n7. `table_cache`：表高速缓存的大小\n    + 表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值`Open_tables`和`Opened_tables`，可以决定是否需要增加`table_cache`的值。如果你发现open_tables等于`table_cache`，并且opened_tables在不断增长，那么你就需要增加`table_cache`的值了（上述状态值可以使用`SHOW STATUS LIKE ‘Open%tables’`获得）。注意，不能盲目地把`table_cache`设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。\n    + 1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。\n8. `max_heap_table_size`：用户可以创建的内存表(memory table)的大小\n    + 这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=#\n    + 这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。\n9. `tmp_table_size`：临时表的大小\n    + 通过设置`tmp_table_size`选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。\n    + 每次创建临时表，`Created_tmp_tables`增加，如果临时表大小超过`tmp_table_size`，则是在磁盘上创建临时表，`Created_tmp_disk_tables`也增加,`Created_tmp_files`表示MySQL服务创建的临时文件文件数\n    + 比较理想的配置是：`Created_tmp_disk_tables / Created_tmp_tables * 100% <= 25%`比如上面的服务器`Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%`，应该相当好了\n    + 默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞\n10. `thread_cache_size`：可以复用的保存在中的线程的数量\n    + 可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。\n    + 通过比较 Connections和`Threads_created`状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。\n11. `thread_concurrency`：同一时间运行的线程系统提示所需数量的线程\n    + 推荐设置为服务器 CPU核数的2倍，\n    + 例如双核的CPU, 那么`thread_concurrency`的应该为4；2个双核的cpu, `thread_concurrency`的值应为8。默认为8\n    + 这个参数**已经在5.7.2版本的MySQL中被移除**\n\n\n\n##### 6.3.1 `my.cnf`常用 配置InnoDB的 参数\n1. `innodb_buffer_pool_size`：缓冲池大小\n    + 对于InnoDB表来说，`innodb_buffer_pool_size`的作用就相当于`key_buffer_size`对于MyISAM表的作用一样。\n    + InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。\n    + 根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。\n2. `innodb_flush_log_at_trx_commit`：主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个\n    + 设置为0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；\n    + 设置为1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；\n    + 设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。\n    + 实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。\n    + 根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。\n3. `innodb_log_buffer_size`：log缓存大小\n    + 一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。\n4. `innodb_additional_mem_pool_size`：内存池大小\n    + 该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。\n    + 根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。\n    + `innodb_thread_concurrency=8`，推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8\n5. `skip-name-resolve`：禁止域名解析\n    + 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。\n    + 但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求\n\n\n\n### 7. MySQL的执行顺序\nMySQL的语句一共分为**11步**，最**先**执行的总是**FROM**操作，最**后**执行的是**LIMIT**操作。\n- 其中**每一个操作都会产生一张虚拟的表**，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有**最后一个虚拟的表才会被作为结果返回**。\n- 如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。\n    - ⑧`select`\n    - ⑨`distinct <字段名>`\n    - ①`from <表名>`\n    - ③`<连接类型>join <表名>`\n    - ②`on<连接条件>`\n    - ④`where<查询条件>`\n    - ④`group by<分组字段>`\n    - ⑥`with{cube|rollup}`\n    - ⑦`having<查询条件>`\n    - ⑩`order by<排序字段>`\n    - ⑪`limit<分页数量>`\n\n查询处理的每一个阶段分析：\n1. **FORM**: 对FROM的左边的表和右边的表计算**笛卡尔积**。产生虚表VT1\n2. **ON**: 对虚表VT1进行ON筛选，只有那些符合`<连接条件>`的行才会被记录在虚表VT2中。\n3. **JOIN**：如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。\n4. **WHERE**：对虚拟表VT3进行WHERE条件过滤。只有符合`<where查询条件>`的记录才会被插入到虚拟表VT4中。\n5. **GROUP BY**: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.\n6. **CUBE | ROLLUP**: 对表VT5进行cube或者rollup操作，产生表VT6.\n7. **HAVING**： 对虚拟表VT6应用having过滤，只有符合`<having查询条件>`的记录才会被 插入到虚拟表VT7中。\n\n\n\n### 8. MySQL执行引擎\n#### 8.1 MyISAM存储引擎\n- **不支持事务、也不支持外键**，优势是**访问速度快**，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表\n- 支持3种不同的存储格式，分别是：静态表；动态表；压缩表\n- 静态表：\n    + 表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。\n- 动态表：\n    + 记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能\n- 压缩表：\n    + 因为每个记录是被单独压缩的，所以只有非常小的访问开支\n\n\n#### 8.2 InnoDB存储引擎\n- 提供了具有提交、回滚和崩溃恢复能力的**事务安全**。但是对比MyISAM引擎，**写的处理效率会差一些**，并且会占用更多的磁盘空间以保留数据和索引。 \n- InnoDB存储引擎的特点：**支持自动增长列，支持外键约束**\n\n\n#### 8.3 MEMORY存储引擎\n- Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且**默认使用HASH索引**，但是**一旦服务关闭，表中的数据就会丢失掉**。 \n- MEMORY存储引擎的表可以选择使用**BTREE索引**或者**HASH索引**，两种不同类型的索引有其不同的使用范围\n- Hash索引优点： \n    + Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 \n- Hash索引缺点： \n    + 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；\n- Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。\n\n#### 8.4 MERGE存储引擎\n- Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。","source":"_posts/【数据库优化】MySQL性能优化基础.md","raw":"---\ntitle: 【数据库优化】MySQL性能优化基础\ndate: 2019-09-01 21:36:46\ntags: [数据库, 后端开发]\ncategories: 数据库\n---\n\n\n### 1. MySQL基础操作\n#### 1.1 MySQL备份与恢复\n1. 备份：在mysql的安装目录的bin目录下有**mysqldump命令**，可以完成对数据库的备份。 \n    + 语法：`mysqldump -u 用户名 -p 数据库名> 磁盘SQL文件路径` <!-- more -->\n    + 由于mysqldump命令不是sql命令，需要在**dos窗口下使用**。\n    + 仅仅只会备份数据库中的表和数据，恢复时需要先手动创建数据库。\n2. 恢复：先手动创建数据库：`create database 数据库名`\n    + 然后dos窗口：`mysql -u 用户名-p 导入库名< 磁盘SQL文件绝对路径`\n\n\n#### 1.2 MySQL事务基础\n1. 特性(ACID)：**原子性**（Atomicity，或称不可分割性）、**一致性**（Consistency）、**隔离性**（Isolation，又称独立性）、**持久性**（Durability）。\n2. 事务隔离级别：**读未提交**（Read uncommitted）、**读提交**（read committed）、**可重复读**（repeatable read）和**串行化**（Serializable）。\n3. MYSQL事务处理主要有两种方法： \n    1. 用 BEGIN, ROLLBACK, COMMIT来实现:\n        + BEGIN 开始一个事务\n        + COMMIT 事务确认 \n        + ROLLBACK 事务回滚\n    2. 直接用 SET 来改变 MySQL 的自动提交模式: \n        + SET AUTOCOMMIT=0 禁止自动提交\n        + SET AUTOCOMMIT=1 开启自动提交\n4. 事务并发操作出现几种问题: 丢失修改数据、读“脏”数据、数据不一致\n\n\n#### 1.3 查看设置MySQL编码\n1. 查看：`mysql> show variables like 'character%'`\n2. 设置: # `vi /etc/my.cnf`：\n``` java\n[mysqld] \ncharacter‐set‐server=utf8\ncollation‐server=utf8_general_ci\nsql_mode='NO_ENGINE_SUBSTITUTION'\n[mysql] \ndefault‐character‐set = utf8 \n[mysql.server] \ndefault‐character‐set = utf8 \n[mysqld_safe] \ndefault‐character‐set = utf8 \n[client] \ndefault‐character‐set = utf8\n```\n3. mysql的主配置文件: `/etc/my.cnf`\n4. 数据库文件存放位置: `/var/lib/mysql`\n5. 数据库的日志输出存放位置: `/var/log/mysql`\n6. 端口: `Netstat –nltp` 看是否能找到3306的端口\n\n\n#### 1.4 范式\n概念：范式就是符合某一规范级别的关系模式的集合。共有7种范式：`1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF⊃6NF`\n1. 第一范式(1NF, First Normal Form)：字段值具有**原子性**,不能再分(所有关系型数据库系统都满足第一范式);\n    + 例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;\n2. 第二范式(2NF, Second Normal Form)：一个表**必须有主键**,即每行数据都能被唯一的区分(2NF必须先满足第一范式);\n3. 第三范式(3NF, Third Normal Form)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表**不能有冗余字段**(3NF必须先满足第二范式);\n    + 备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;\n    + 例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;\n\n\n\n### 2. SQL语句优化\n#### 2.1 通过慢查日志发现有问题的SQL\n1. 查询次数多且每次查询占用时间长的sql\n    + 通常为**pt-query-digest**分析的前几个查询；该工具可以很清楚的看出每个SQL执行的次数及百分比等信息，执行的次数多，占比比较大的SQL\n2. IO大的sql\n    + 注意pt-query-digest分析中的Rows examine项。扫描的行数越多，IO越大。\n3. 未命中的索引的SQL\n    + 注意pt-query-digest分析中的Rows examine 和Rows Send的对比。说明该SQL的索引命中率不高，对于这种SQL，我们要重点进行关注。\n4. 通过explain查询分析SQL的执行计划, SQL的执行计划侧面反映出了SQL的执行效率，\n\n#### 2.2 常见SQL优化手段\n1. 函数Max()的优化\n    + 在求max的字段**建索引**\n2. 函数Count()的优化：\n    + Count(*):是包含null值；Count(id)：不包含null值\n3. 子查询的优化\n    + 子查询是我们在开发过程中经常使用的一种方式，在通常情况下，需要把**子查询优化为join查询**但在优化是需要注意关联键是否有一对多的关系，要注意重复数据(distinct去重)。\n    + 在用Join进行多表联合查询时，我们通常使用On来建立两个表的关系。其实还有一个更方便的关键字，那就是Using（如果两个表的关联字段名是一样）。\n4. group by的优化: \n    + 最好使用同一表中的列，在子查询中分组\n5. Limit查询的优化：Limit常用于分页处理，时常会伴随order by从句使用，因此大多时候会使用Filesorts这样会造成大量的IO问题。\n    + 优化步骤1：使用有索引的列或主键进行order by操作，因为大家知道，innodb是按照主键的逻辑顺序进行排序的。可以避免很多的IO操作。\n    + 优化步骤2：记录上次返回的主键， 在下次查询时使用主键过滤。（说明：避免了数据量大时扫描过多的记录）\n    + 注意事项：主键要顺序排序并连续的，如果主键中间空缺了某一列，或者某几列，会出现列出数据不足一页的数据；如果不连续的情况，建立一个附加的列index_id列，保证这一列数据要自增的，并添加索引即可。\n\n### 3. 索引的优化\n#### 3.1 索引基础概念\n索引是为了加速对表中数据行的检索而创建的一种分散存储的**数据结构**。\n- 索引的建立是表中**比较有指向性的字段**，相当于目录，比如说行政区域代码，同一个地域的行政区域代码都是相同的，那么给这一列加上索引，避免让它重复扫描，从而达到优化的目的！\n- 创建索引：在执行create table语句时可以创建索引，也可以单独用create index或alter index来为表增加索引。**不能用create index语句创建primary key索引**。\n- 在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为primary key或unique索引。对于单列惟一性索引，这保证单列不包含重复的值。对于**多列惟一性索引，保证多个值的组合不重复**。\n- primary key索引和unique索引非常类似。事实上，**primary key索引仅是一个具有名称PRIMARY的unique索引**。\n- 查看索引：`show index from tblname;`或`show keys from tblname;`\n\n\n#### 3.2 索引的创建与删除\n1. 创建**普通索引**：\n    + 方式1：`create index 索引名 on 表名(列名)`\n    + 方式2：`alter table 表名 add index 索引名(列名)`\n    + 方式3：创建表的时候直接指定: `,index [索引名] (列名)`\n2. 删除索引： `drop index [索引名] on 表名`\n3. 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。\n4. 创建**唯一索引**：\n    + 方式1：`create unique index 索引名 on 表名(列名)`\n    + 方式2：`alter table 表名 add unique 索引名(列名)`\n    + 方式3：创建表的时候直接指定: `,unique [索引名] (列名)`\n\n\n#### 3.3 使用索引的场景\n1. 表的主键自动建立唯一索引\n2. 表的字段唯一约束\n3. 直接条件查询的字段（在SQL中用于条件约束的字段）\n4. 查询中与其它表关联的字段\n5. 查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）\n6. 查询中统计或分组统计的字段\n7. 表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）\n8. 经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）\n9. 数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）\n10. 经常和主字段一块查询但主字段索引值比较多的表字段\n11. 对千万级MySQL数据库建立索引的事项及提高性能的手段\n\n\n#### 3.4 索引的维护及优化（重复及冗余索引）\n增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，**过多的索引会不但会影响使用效率，同时会影响查询效率**，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引\n- 重复索引：重复索引是指相同的列以相同的顺序建立的同类型的索引，如在primary key再建立唯一索引就是重复索引\n- 冗余索引：冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，如对于innodb来说，每一个索引后面，实际上都会包含主键，这时候我们建立的联合索引，又人为的把主键包含进去，那么这个时候就是一个冗余索引。\n- 工具：使用**`pt-duplicate-key-checker`工具检查重复及冗余索引**: `pt-duplicate-key-checker -uroot -padmin -h 127.0.0.1`\n- 索引维护的方法: 由于业务变更，某些索引是后续不需要使用的，就要进行**删除**。\n- 在mysql中，目前只能通过慢查询日志配合pt-index-usage工具来进行索引使用情况的分析；`pt-index-usage -uroot -padmin /var/lib/mysql/mysql-host-slow.log`\n\n\n#### 3.5 设计MySql索引的注意事项\n设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：\n1. **创建索引**\n    + 对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。\n    + 但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。\n2. **复合索引**\n    + 比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;\n    + 如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为**最佳左前缀特性**。\n    + 因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。\n3. 索引不会包含有NULL值的列\n    + 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有**NULL值**，那么这一列对于此复合索引就是**无效**的。所以我们在数据库设计时不要让字段的默认值为NULL。\n4. 使用短索引\n    + 对字符串列进行索引，如果可能应该**指定一个前缀长度**。\n    + 例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。\n5. 排序的索引问题\n    + mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列**创建复合索引**。\n6. like语句操作\n    + 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” **不会使用索引**，而like “aaa%”可以使用索引。\n7. 不要在列上进行运算\n    + select * from users where YEAR(adddate)\n8. 不使用NOT IN操作\n    + NOT IN操作都不会使用索引将进行全表扫描。NOT IN可以**NOT EXISTS代替**\n\n\n\n### 4. MYSQL数据库设计规范与原则\n#### 4.1 设计规范\n1. 命名规范\n    + 采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线'_'组成\n    + 命名简洁明确,多个单词用下划线'_'分隔,长度不超过30个字符\n    + 除非是备份数据库可以加0-9的自然数,如：`'user_db_20191210'`\n    + 表前缀可以有效的把相同关系的表显示在一起,如：`'user_'`\n    + 每个表中必须有自增主键\n    + 表与表之间的相关联字段名称要求尽可能的相同\n2. 字段类型规范\n    + 用尽量少的存储空间来存数一个字段的数据, 例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);\n    + IP地址最好使用int类型;\n    + 固定长度的类型最好使用char,例如：邮编;\n    + 能使用tinyint就不要使用smallint,int;\n    + 最好给每个字段一个默认值, 最好不能为null;\n3. 索引规范\n    + 命名简洁明确,例如：`user_login`表`user_name`字段的索引应为`user_name_index`唯一索引;\n    + 为每个表创建一个主键索引;\n    + 为每个表创建合理的索引;\n    + 建立复合索引请**慎重**;\n\n\n#### 4.2 设计原则\n1. 核心原则\n    + 不在数据库做运算;\n    + cpu计算务必移至业务层;\n    + 控制列数量(字段少而精,字段数建议在20以内);\n    + 平衡范式与冗余(效率优先；往往牺牲范式)\n    + 拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch); \n2. 字段类原则\n    + 用好数值类型(用合适的字段类型节约空间);\n    + 字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);\n    + 避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);\n    + 少用text类型(尽量使用varchar代替text字段); \n3. 索引类原则\n    + 合理使用索引(改善查询,减慢更新,索引一定不是越多越好);\n    + 字符字段必须建前缀索引;\n    + 不在索引做列运算;\n    + innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);\n    + 不用外键(由程序保证约束);\n4. sql类原则\n    + sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);\n    + 简单的事务;\n    + 避免使用trig/func(触发器、函数不用客户端程序取而代之);\n    + 不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性);\n    + OR改写为IN(or的效率是n级别);\n    + OR改写为UNION(mysql的索引合并很弱智);\n    + 避免负向%;\n    + 慎用count(*);\n    + limit高效分页(limit越大，效率越低);\n    + 使用union all替代union(union有去重开销);\n    + 少用连接join;\n    + 使用group by;\n    + 请使用同类型比较;\n    + 打散批量更新;\n\n\n\n### 5. 数据库结构的优化\n#### 5.1 选择合适的数据类型\n数据类型的选择，重点在于“合适”二字\n1. 使用可以存下你的数据的最小的数据类型。（时间类型数据：可以使用varchar类型，可以使用int类型，也可以使用时间戳类型）\n2. 使用简单的数据类型，int要比varchar类型在mysql处理上简单。（int类型存储时间是最好的选择）\n3. 尽可能的使用not null定义字段。（innodb的特性所决定，非not null的值，需要额外的在字段存储，同时也会增加IO和存储的开销）\n4. 尽量少用text类型，非用不可时最好考虑分表。\n\n\n#### 5.2 数据库表的范式化优化\n1. 表范式化\n    + 范式化是指数据库设计的规范，目前说道范式化一般是指第三设计范式。也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。\n2. 反范式化\n    + 反范式化是指为了查询效率的考虑把原本符合**第三范式**的表“适当”的**增加冗余**，以达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。\n\n\n#### 5.3 数据库表的垂直拆分\n所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。\n+ 垂直拆分原则\n    1. 把不常用的字段表单独存放到一个表中。\n    2. 把大字段独立存放到一个表中。\n    3. 把经常一起使用的字段放到一起。\n\n\n#### 5.4 数据库表的水平拆分\n表的水平拆分是为了解决单表数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的\n1. 水平拆分原因\n    + 如果单表的数据量达到上亿条，那么这时候我们尽管加了完美的索引，查询效率低，写入的效率也相应的降低。\n2. 如何将数据平均分为N份\n    1. 对customer_id进行hash运算，如果要拆分为5个表则使用mod（customer_id，5）取出0-4个值。\n    2. 针对不动的hashid把数据存储到不同的表中。\n3. 水平拆分面临的挑战\n    1. 夸分区表进行数据查询\n        + 前端业务统计：业务上给不同的用户返回不同的业务信息，对分区表没有大的挑战。\n    2. 统计及后台报表操作\n        + 但是对后台进行报表统计时，数据量比较大，后台统计时效性比较低，后台就用汇总表，将前后台的表拆分开。\n\n\n\n### 6. 数据库系统配置优化\n数据库是基于操作系统的，目前大多数MySQL都是安装在**linux系统**之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能\n\n#### 6.1 操作系统的优化\n网络方面的配置，要修改`/etc/sysctl.conf`\n1. 增加tcp支持的队列数\n    + `net.ipv4.tcp_max_syn_backlog = 65535`\n2. 减少断开连接时，资源回收(tcp有连接状态)\n    + `net.ipv4.tcp_max_tw_buckets = 8000`\n    + `net.ipv4.tcp_tw_reuse = 1`\n    + `net.ipv4.tcp_tw_recycle = 1`\n    + `net.ipv4.tcp_fin_timeout = 10`\n    + 说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。\n\n\n#### 6.2 打开文件数的限制\n打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改`/etc/security/limits.conf`文件\n- limits.conf中增加以下内容以修改打开文件数量的限制（永久生效）\n    + `*Soft nofile 65535`\n    + `*Hard nofile 65535`\n- 如果一次有效，就要使用`ulimit –n 65535`即可。（默认情况是1024）\n- 除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件\n\n\n#### 6.3 MySQL配置文件优化\nMysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于`/etc/my.cnf`或`/etc/mysql/my.cnf`\n- MySQL**查找配置文件的顺序**可以通过以下命令获得：\n    + `/usr/sbin/mysqld --verbose --help | grep -A 1 'default options'`\n    + 注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。\n\n\n##### 6.3.1 `my.cnf`常用 连接请求 参数\n1. `max_connections`：最大连接数\n    + 如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，MySQL会为每个连接提供连接缓冲区，连接数越多就会开销越多的内存，所以要**适当调整该值**，不能盲目提高设值。\n    + 数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。\n    + `max_used_connections / max_connections * 100% `（**理想值≈ 85%**）: 响应的连接数/最大连接数\n2. `back_log`：能暂存的连接数量\n    + 如果MySQL的连接数据达到`max_connections`时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即`back_log`，如果等待连接的数量超过`back_log`，将不被授予连接资源。\n    + **默认数值是50，可调优为128**，对于Linux系统设置范围为小于512的整数。\n3. `interactive_timeout`：服务器关闭**交互式连接**前等待活动的秒数\n    + 默认数值是28800，可调优为7200。\n4. `wait_timeout`：服务器关闭**非交互连接**之前等待活动的秒数\n    + 指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。\n\n##### 6.3.1 `my.cnf`常用 缓冲区 参数\n1. `key_buffer_size`: 指定索引缓冲区的大小\n    + 它决定索引处理的速度，尤其是索引读的速度。\n    + 它只对**MyISAM表起作用**。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值\n2. `query_cache_size` ：查询缓存的内存\n    + 使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。\n    + 通过检查状态值Qcache_*，可以知道`query_cache_size`设置是否合理（上述状态值可以使用`SHOW STATUS LIKE ‘Qcache%’`获得）。如果`Qcache_lowmem_prunes`的值非常大，则表明经常出现缓冲不够的情况，如果`Qcache_hits`的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果`Qcache_hits`的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入`SQL_NO_CACHE`可以明确表示不使用查询缓冲。\n    + 与查询缓冲有关的参数还有`query_cache_type`、`query_cache_limit`、`query_cache_min_res_unit`。\n        - `query_cache_type`指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。\n        - `query_cache_limit`指定单个查询能够使用的缓冲区大小，缺省为1M。\n        - `query_cache_min_res_unit`指定分配缓冲区空间的最小单位，缺省为4K。检查状态值`Qcache_free_blocks`，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小`query_cache_min_res_unit`。\n3. `record_buffer_size`：顺序扫描缓冲区大小\n    + 每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。\n    + 默认数值是131072(128K)，可改为16773120 (16M)\n4. `read_rnd_buffer_size`：随机读缓冲区大小\n    + 当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M\n5. `sort_buffer_size`：排序扫描缓冲区大小\n    + 每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。\n    + 默认数值是2097144(2M)，可改为16777208 (16M)。\n6. `join_buffer_size`：联合查询缓冲区大小\n    + 联合查询操作所能使用的缓冲区大小。\n    + `record_buffer_size`，`read_rnd_buffer_size`，`sort_buffer_size`，`join_buffer_size`为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100\n7. `table_cache`：表高速缓存的大小\n    + 表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值`Open_tables`和`Opened_tables`，可以决定是否需要增加`table_cache`的值。如果你发现open_tables等于`table_cache`，并且opened_tables在不断增长，那么你就需要增加`table_cache`的值了（上述状态值可以使用`SHOW STATUS LIKE ‘Open%tables’`获得）。注意，不能盲目地把`table_cache`设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。\n    + 1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。\n8. `max_heap_table_size`：用户可以创建的内存表(memory table)的大小\n    + 这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=#\n    + 这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。\n9. `tmp_table_size`：临时表的大小\n    + 通过设置`tmp_table_size`选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。\n    + 每次创建临时表，`Created_tmp_tables`增加，如果临时表大小超过`tmp_table_size`，则是在磁盘上创建临时表，`Created_tmp_disk_tables`也增加,`Created_tmp_files`表示MySQL服务创建的临时文件文件数\n    + 比较理想的配置是：`Created_tmp_disk_tables / Created_tmp_tables * 100% <= 25%`比如上面的服务器`Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%`，应该相当好了\n    + 默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞\n10. `thread_cache_size`：可以复用的保存在中的线程的数量\n    + 可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。\n    + 通过比较 Connections和`Threads_created`状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。\n11. `thread_concurrency`：同一时间运行的线程系统提示所需数量的线程\n    + 推荐设置为服务器 CPU核数的2倍，\n    + 例如双核的CPU, 那么`thread_concurrency`的应该为4；2个双核的cpu, `thread_concurrency`的值应为8。默认为8\n    + 这个参数**已经在5.7.2版本的MySQL中被移除**\n\n\n\n##### 6.3.1 `my.cnf`常用 配置InnoDB的 参数\n1. `innodb_buffer_pool_size`：缓冲池大小\n    + 对于InnoDB表来说，`innodb_buffer_pool_size`的作用就相当于`key_buffer_size`对于MyISAM表的作用一样。\n    + InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。\n    + 根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。\n2. `innodb_flush_log_at_trx_commit`：主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个\n    + 设置为0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；\n    + 设置为1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；\n    + 设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。\n    + 实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。\n    + 根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。\n3. `innodb_log_buffer_size`：log缓存大小\n    + 一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。\n4. `innodb_additional_mem_pool_size`：内存池大小\n    + 该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。\n    + 根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。\n    + `innodb_thread_concurrency=8`，推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8\n5. `skip-name-resolve`：禁止域名解析\n    + 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。\n    + 但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求\n\n\n\n### 7. MySQL的执行顺序\nMySQL的语句一共分为**11步**，最**先**执行的总是**FROM**操作，最**后**执行的是**LIMIT**操作。\n- 其中**每一个操作都会产生一张虚拟的表**，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有**最后一个虚拟的表才会被作为结果返回**。\n- 如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。\n    - ⑧`select`\n    - ⑨`distinct <字段名>`\n    - ①`from <表名>`\n    - ③`<连接类型>join <表名>`\n    - ②`on<连接条件>`\n    - ④`where<查询条件>`\n    - ④`group by<分组字段>`\n    - ⑥`with{cube|rollup}`\n    - ⑦`having<查询条件>`\n    - ⑩`order by<排序字段>`\n    - ⑪`limit<分页数量>`\n\n查询处理的每一个阶段分析：\n1. **FORM**: 对FROM的左边的表和右边的表计算**笛卡尔积**。产生虚表VT1\n2. **ON**: 对虚表VT1进行ON筛选，只有那些符合`<连接条件>`的行才会被记录在虚表VT2中。\n3. **JOIN**：如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。\n4. **WHERE**：对虚拟表VT3进行WHERE条件过滤。只有符合`<where查询条件>`的记录才会被插入到虚拟表VT4中。\n5. **GROUP BY**: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.\n6. **CUBE | ROLLUP**: 对表VT5进行cube或者rollup操作，产生表VT6.\n7. **HAVING**： 对虚拟表VT6应用having过滤，只有符合`<having查询条件>`的记录才会被 插入到虚拟表VT7中。\n\n\n\n### 8. MySQL执行引擎\n#### 8.1 MyISAM存储引擎\n- **不支持事务、也不支持外键**，优势是**访问速度快**，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表\n- 支持3种不同的存储格式，分别是：静态表；动态表；压缩表\n- 静态表：\n    + 表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。\n- 动态表：\n    + 记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能\n- 压缩表：\n    + 因为每个记录是被单独压缩的，所以只有非常小的访问开支\n\n\n#### 8.2 InnoDB存储引擎\n- 提供了具有提交、回滚和崩溃恢复能力的**事务安全**。但是对比MyISAM引擎，**写的处理效率会差一些**，并且会占用更多的磁盘空间以保留数据和索引。 \n- InnoDB存储引擎的特点：**支持自动增长列，支持外键约束**\n\n\n#### 8.3 MEMORY存储引擎\n- Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且**默认使用HASH索引**，但是**一旦服务关闭，表中的数据就会丢失掉**。 \n- MEMORY存储引擎的表可以选择使用**BTREE索引**或者**HASH索引**，两种不同类型的索引有其不同的使用范围\n- Hash索引优点： \n    + Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 \n- Hash索引缺点： \n    + 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；\n- Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。\n\n#### 8.4 MERGE存储引擎\n- Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。","slug":"【数据库优化】MySQL性能优化基础","published":1,"updated":"2021-12-12T02:50:23.626Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6x0002fvcue0as566wg","content":"<h3 id=\"1-MySQL基础操作\"><a href=\"#1-MySQL基础操作\" class=\"headerlink\" title=\"1. MySQL基础操作\"></a>1. MySQL基础操作</h3><h4 id=\"1-1-MySQL备份与恢复\"><a href=\"#1-1-MySQL备份与恢复\" class=\"headerlink\" title=\"1.1 MySQL备份与恢复\"></a>1.1 MySQL备份与恢复</h4><ol>\n<li>备份：在mysql的安装目录的bin目录下有<strong>mysqldump命令</strong>，可以完成对数据库的备份。 <ul>\n<li>语法：<code>mysqldump -u 用户名 -p 数据库名&gt; 磁盘SQL文件路径</code> <span id=\"more\"></span></li>\n<li>由于mysqldump命令不是sql命令，需要在<strong>dos窗口下使用</strong>。</li>\n<li>仅仅只会备份数据库中的表和数据，恢复时需要先手动创建数据库。</li>\n</ul>\n</li>\n<li>恢复：先手动创建数据库：<code>create database 数据库名</code><ul>\n<li>然后dos窗口：<code>mysql -u 用户名-p 导入库名&lt; 磁盘SQL文件绝对路径</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-2-MySQL事务基础\"><a href=\"#1-2-MySQL事务基础\" class=\"headerlink\" title=\"1.2 MySQL事务基础\"></a>1.2 MySQL事务基础</h4><ol>\n<li>特性(ACID)：<strong>原子性</strong>（Atomicity，或称不可分割性）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation，又称独立性）、<strong>持久性</strong>（Durability）。</li>\n<li>事务隔离级别：<strong>读未提交</strong>（Read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（Serializable）。</li>\n<li>MYSQL事务处理主要有两种方法： <ol>\n<li>用 BEGIN, ROLLBACK, COMMIT来实现:<ul>\n<li>BEGIN 开始一个事务</li>\n<li>COMMIT 事务确认 </li>\n<li>ROLLBACK 事务回滚</li>\n</ul>\n</li>\n<li>直接用 SET 来改变 MySQL 的自动提交模式: <ul>\n<li>SET AUTOCOMMIT=0 禁止自动提交</li>\n<li>SET AUTOCOMMIT=1 开启自动提交</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>事务并发操作出现几种问题: 丢失修改数据、读“脏”数据、数据不一致</li>\n</ol>\n<h4 id=\"1-3-查看设置MySQL编码\"><a href=\"#1-3-查看设置MySQL编码\" class=\"headerlink\" title=\"1.3 查看设置MySQL编码\"></a>1.3 查看设置MySQL编码</h4><ol>\n<li>查看：<code>mysql&gt; show variables like &#39;character%&#39;</code></li>\n<li>设置: # <code>vi /etc/my.cnf</code>：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld] </span><br><span class=\"line\">character‐set‐server=utf8</span><br><span class=\"line\">collation‐server=utf8_general_ci</span><br><span class=\"line\">sql_mode=<span class=\"string\">&#x27;NO_ENGINE_SUBSTITUTION&#x27;</span></span><br><span class=\"line\">[mysql] </span><br><span class=\"line\"><span class=\"keyword\">default</span>‐character‐set = utf8 </span><br><span class=\"line\">[mysql.server] </span><br><span class=\"line\"><span class=\"keyword\">default</span>‐character‐set = utf8 </span><br><span class=\"line\">[mysqld_safe] </span><br><span class=\"line\"><span class=\"keyword\">default</span>‐character‐set = utf8 </span><br><span class=\"line\">[client] </span><br><span class=\"line\"><span class=\"keyword\">default</span>‐character‐set = utf8</span><br></pre></td></tr></table></figure></li>\n<li>mysql的主配置文件: <code>/etc/my.cnf</code></li>\n<li>数据库文件存放位置: <code>/var/lib/mysql</code></li>\n<li>数据库的日志输出存放位置: <code>/var/log/mysql</code></li>\n<li>端口: <code>Netstat –nltp</code> 看是否能找到3306的端口</li>\n</ol>\n<h4 id=\"1-4-范式\"><a href=\"#1-4-范式\" class=\"headerlink\" title=\"1.4 范式\"></a>1.4 范式</h4><p>概念：范式就是符合某一规范级别的关系模式的集合。共有7种范式：<code>1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF⊃6NF</code></p>\n<ol>\n<li>第一范式(1NF, First Normal Form)：字段值具有<strong>原子性</strong>,不能再分(所有关系型数据库系统都满足第一范式);<ul>\n<li>例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;</li>\n</ul>\n</li>\n<li>第二范式(2NF, Second Normal Form)：一个表<strong>必须有主键</strong>,即每行数据都能被唯一的区分(2NF必须先满足第一范式);</li>\n<li>第三范式(3NF, Third Normal Form)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表<strong>不能有冗余字段</strong>(3NF必须先满足第二范式);<ul>\n<li>备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;</li>\n<li>例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-SQL语句优化\"><a href=\"#2-SQL语句优化\" class=\"headerlink\" title=\"2. SQL语句优化\"></a>2. SQL语句优化</h3><h4 id=\"2-1-通过慢查日志发现有问题的SQL\"><a href=\"#2-1-通过慢查日志发现有问题的SQL\" class=\"headerlink\" title=\"2.1 通过慢查日志发现有问题的SQL\"></a>2.1 通过慢查日志发现有问题的SQL</h4><ol>\n<li>查询次数多且每次查询占用时间长的sql<ul>\n<li>通常为<strong>pt-query-digest</strong>分析的前几个查询；该工具可以很清楚的看出每个SQL执行的次数及百分比等信息，执行的次数多，占比比较大的SQL</li>\n</ul>\n</li>\n<li>IO大的sql<ul>\n<li>注意pt-query-digest分析中的Rows examine项。扫描的行数越多，IO越大。</li>\n</ul>\n</li>\n<li>未命中的索引的SQL<ul>\n<li>注意pt-query-digest分析中的Rows examine 和Rows Send的对比。说明该SQL的索引命中率不高，对于这种SQL，我们要重点进行关注。</li>\n</ul>\n</li>\n<li>通过explain查询分析SQL的执行计划, SQL的执行计划侧面反映出了SQL的执行效率，</li>\n</ol>\n<h4 id=\"2-2-常见SQL优化手段\"><a href=\"#2-2-常见SQL优化手段\" class=\"headerlink\" title=\"2.2 常见SQL优化手段\"></a>2.2 常见SQL优化手段</h4><ol>\n<li>函数Max()的优化<ul>\n<li>在求max的字段<strong>建索引</strong></li>\n</ul>\n</li>\n<li>函数Count()的优化：<ul>\n<li>Count(*):是包含null值；Count(id)：不包含null值</li>\n</ul>\n</li>\n<li>子查询的优化<ul>\n<li>子查询是我们在开发过程中经常使用的一种方式，在通常情况下，需要把<strong>子查询优化为join查询</strong>但在优化是需要注意关联键是否有一对多的关系，要注意重复数据(distinct去重)。</li>\n<li>在用Join进行多表联合查询时，我们通常使用On来建立两个表的关系。其实还有一个更方便的关键字，那就是Using（如果两个表的关联字段名是一样）。</li>\n</ul>\n</li>\n<li>group by的优化: <ul>\n<li>最好使用同一表中的列，在子查询中分组</li>\n</ul>\n</li>\n<li>Limit查询的优化：Limit常用于分页处理，时常会伴随order by从句使用，因此大多时候会使用Filesorts这样会造成大量的IO问题。<ul>\n<li>优化步骤1：使用有索引的列或主键进行order by操作，因为大家知道，innodb是按照主键的逻辑顺序进行排序的。可以避免很多的IO操作。</li>\n<li>优化步骤2：记录上次返回的主键， 在下次查询时使用主键过滤。（说明：避免了数据量大时扫描过多的记录）</li>\n<li>注意事项：主键要顺序排序并连续的，如果主键中间空缺了某一列，或者某几列，会出现列出数据不足一页的数据；如果不连续的情况，建立一个附加的列index_id列，保证这一列数据要自增的，并添加索引即可。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-索引的优化\"><a href=\"#3-索引的优化\" class=\"headerlink\" title=\"3. 索引的优化\"></a>3. 索引的优化</h3><h4 id=\"3-1-索引基础概念\"><a href=\"#3-1-索引基础概念\" class=\"headerlink\" title=\"3.1 索引基础概念\"></a>3.1 索引基础概念</h4><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p>\n<ul>\n<li>索引的建立是表中<strong>比较有指向性的字段</strong>，相当于目录，比如说行政区域代码，同一个地域的行政区域代码都是相同的，那么给这一列加上索引，避免让它重复扫描，从而达到优化的目的！</li>\n<li>创建索引：在执行create table语句时可以创建索引，也可以单独用create index或alter index来为表增加索引。<strong>不能用create index语句创建primary key索引</strong>。</li>\n<li>在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为primary key或unique索引。对于单列惟一性索引，这保证单列不包含重复的值。对于<strong>多列惟一性索引，保证多个值的组合不重复</strong>。</li>\n<li>primary key索引和unique索引非常类似。事实上，<strong>primary key索引仅是一个具有名称PRIMARY的unique索引</strong>。</li>\n<li>查看索引：<code>show index from tblname;</code>或<code>show keys from tblname;</code></li>\n</ul>\n<h4 id=\"3-2-索引的创建与删除\"><a href=\"#3-2-索引的创建与删除\" class=\"headerlink\" title=\"3.2 索引的创建与删除\"></a>3.2 索引的创建与删除</h4><ol>\n<li>创建<strong>普通索引</strong>：<ul>\n<li>方式1：<code>create index 索引名 on 表名(列名)</code></li>\n<li>方式2：<code>alter table 表名 add index 索引名(列名)</code></li>\n<li>方式3：创建表的时候直接指定: <code>,index [索引名] (列名)</code></li>\n</ul>\n</li>\n<li>删除索引： <code>drop index [索引名] on 表名</code></li>\n<li>唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li>\n<li>创建<strong>唯一索引</strong>：<ul>\n<li>方式1：<code>create unique index 索引名 on 表名(列名)</code></li>\n<li>方式2：<code>alter table 表名 add unique 索引名(列名)</code></li>\n<li>方式3：创建表的时候直接指定: <code>,unique [索引名] (列名)</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-3-使用索引的场景\"><a href=\"#3-3-使用索引的场景\" class=\"headerlink\" title=\"3.3 使用索引的场景\"></a>3.3 使用索引的场景</h4><ol>\n<li>表的主键自动建立唯一索引</li>\n<li>表的字段唯一约束</li>\n<li>直接条件查询的字段（在SQL中用于条件约束的字段）</li>\n<li>查询中与其它表关联的字段</li>\n<li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li>\n<li>查询中统计或分组统计的字段</li>\n<li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li>\n<li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li>\n<li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li>\n<li>经常和主字段一块查询但主字段索引值比较多的表字段</li>\n<li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li>\n</ol>\n<h4 id=\"3-4-索引的维护及优化（重复及冗余索引）\"><a href=\"#3-4-索引的维护及优化（重复及冗余索引）\" class=\"headerlink\" title=\"3.4 索引的维护及优化（重复及冗余索引）\"></a>3.4 索引的维护及优化（重复及冗余索引）</h4><p>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引</p>\n<ul>\n<li>重复索引：重复索引是指相同的列以相同的顺序建立的同类型的索引，如在primary key再建立唯一索引就是重复索引</li>\n<li>冗余索引：冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，如对于innodb来说，每一个索引后面，实际上都会包含主键，这时候我们建立的联合索引，又人为的把主键包含进去，那么这个时候就是一个冗余索引。</li>\n<li>工具：使用**<code>pt-duplicate-key-checker</code>工具检查重复及冗余索引**: <code>pt-duplicate-key-checker -uroot -padmin -h 127.0.0.1</code></li>\n<li>索引维护的方法: 由于业务变更，某些索引是后续不需要使用的，就要进行<strong>删除</strong>。</li>\n<li>在mysql中，目前只能通过慢查询日志配合pt-index-usage工具来进行索引使用情况的分析；<code>pt-index-usage -uroot -padmin /var/lib/mysql/mysql-host-slow.log</code></li>\n</ul>\n<h4 id=\"3-5-设计MySql索引的注意事项\"><a href=\"#3-5-设计MySql索引的注意事项\" class=\"headerlink\" title=\"3.5 设计MySql索引的注意事项\"></a>3.5 设计MySql索引的注意事项</h4><p>设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：</p>\n<ol>\n<li><strong>创建索引</strong><ul>\n<li>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。</li>\n<li>但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</li>\n</ul>\n</li>\n<li><strong>复合索引</strong><ul>\n<li>比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;</li>\n<li>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为<strong>最佳左前缀特性</strong>。</li>\n<li>因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</li>\n</ul>\n</li>\n<li>索引不会包含有NULL值的列<ul>\n<li>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有<strong>NULL值</strong>，那么这一列对于此复合索引就是<strong>无效</strong>的。所以我们在数据库设计时不要让字段的默认值为NULL。</li>\n</ul>\n</li>\n<li>使用短索引<ul>\n<li>对字符串列进行索引，如果可能应该<strong>指定一个前缀长度</strong>。</li>\n<li>例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li>\n</ul>\n</li>\n<li>排序的索引问题<ul>\n<li>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列<strong>创建复合索引</strong>。</li>\n</ul>\n</li>\n<li>like语句操作<ul>\n<li>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” <strong>不会使用索引</strong>，而like “aaa%”可以使用索引。</li>\n</ul>\n</li>\n<li>不要在列上进行运算<ul>\n<li>select * from users where YEAR(adddate)</li>\n</ul>\n</li>\n<li>不使用NOT IN操作<ul>\n<li>NOT IN操作都不会使用索引将进行全表扫描。NOT IN可以<strong>NOT EXISTS代替</strong></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-MYSQL数据库设计规范与原则\"><a href=\"#4-MYSQL数据库设计规范与原则\" class=\"headerlink\" title=\"4. MYSQL数据库设计规范与原则\"></a>4. MYSQL数据库设计规范与原则</h3><h4 id=\"4-1-设计规范\"><a href=\"#4-1-设计规范\" class=\"headerlink\" title=\"4.1 设计规范\"></a>4.1 设计规范</h4><ol>\n<li>命名规范<ul>\n<li>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成</li>\n<li>命名简洁明确,多个单词用下划线’_’分隔,长度不超过30个字符</li>\n<li>除非是备份数据库可以加0-9的自然数,如：<code>&#39;user_db_20191210&#39;</code></li>\n<li>表前缀可以有效的把相同关系的表显示在一起,如：<code>&#39;user_&#39;</code></li>\n<li>每个表中必须有自增主键</li>\n<li>表与表之间的相关联字段名称要求尽可能的相同</li>\n</ul>\n</li>\n<li>字段类型规范<ul>\n<li>用尽量少的存储空间来存数一个字段的数据, 例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);</li>\n<li>IP地址最好使用int类型;</li>\n<li>固定长度的类型最好使用char,例如：邮编;</li>\n<li>能使用tinyint就不要使用smallint,int;</li>\n<li>最好给每个字段一个默认值, 最好不能为null;</li>\n</ul>\n</li>\n<li>索引规范<ul>\n<li>命名简洁明确,例如：<code>user_login</code>表<code>user_name</code>字段的索引应为<code>user_name_index</code>唯一索引;</li>\n<li>为每个表创建一个主键索引;</li>\n<li>为每个表创建合理的索引;</li>\n<li>建立复合索引请<strong>慎重</strong>;</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-2-设计原则\"><a href=\"#4-2-设计原则\" class=\"headerlink\" title=\"4.2 设计原则\"></a>4.2 设计原则</h4><ol>\n<li>核心原则<ul>\n<li>不在数据库做运算;</li>\n<li>cpu计算务必移至业务层;</li>\n<li>控制列数量(字段少而精,字段数建议在20以内);</li>\n<li>平衡范式与冗余(效率优先；往往牺牲范式)</li>\n<li>拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch); </li>\n</ul>\n</li>\n<li>字段类原则<ul>\n<li>用好数值类型(用合适的字段类型节约空间);</li>\n<li>字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);</li>\n<li>避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);</li>\n<li>少用text类型(尽量使用varchar代替text字段); </li>\n</ul>\n</li>\n<li>索引类原则<ul>\n<li>合理使用索引(改善查询,减慢更新,索引一定不是越多越好);</li>\n<li>字符字段必须建前缀索引;</li>\n<li>不在索引做列运算;</li>\n<li>innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);</li>\n<li>不用外键(由程序保证约束);</li>\n</ul>\n</li>\n<li>sql类原则<ul>\n<li>sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);</li>\n<li>简单的事务;</li>\n<li>避免使用trig/func(触发器、函数不用客户端程序取而代之);</li>\n<li>不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性);</li>\n<li>OR改写为IN(or的效率是n级别);</li>\n<li>OR改写为UNION(mysql的索引合并很弱智);</li>\n<li>避免负向%;</li>\n<li>慎用count(*);</li>\n<li>limit高效分页(limit越大，效率越低);</li>\n<li>使用union all替代union(union有去重开销);</li>\n<li>少用连接join;</li>\n<li>使用group by;</li>\n<li>请使用同类型比较;</li>\n<li>打散批量更新;</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-数据库结构的优化\"><a href=\"#5-数据库结构的优化\" class=\"headerlink\" title=\"5. 数据库结构的优化\"></a>5. 数据库结构的优化</h3><h4 id=\"5-1-选择合适的数据类型\"><a href=\"#5-1-选择合适的数据类型\" class=\"headerlink\" title=\"5.1 选择合适的数据类型\"></a>5.1 选择合适的数据类型</h4><p>数据类型的选择，重点在于“合适”二字</p>\n<ol>\n<li>使用可以存下你的数据的最小的数据类型。（时间类型数据：可以使用varchar类型，可以使用int类型，也可以使用时间戳类型）</li>\n<li>使用简单的数据类型，int要比varchar类型在mysql处理上简单。（int类型存储时间是最好的选择）</li>\n<li>尽可能的使用not null定义字段。（innodb的特性所决定，非not null的值，需要额外的在字段存储，同时也会增加IO和存储的开销）</li>\n<li>尽量少用text类型，非用不可时最好考虑分表。</li>\n</ol>\n<h4 id=\"5-2-数据库表的范式化优化\"><a href=\"#5-2-数据库表的范式化优化\" class=\"headerlink\" title=\"5.2 数据库表的范式化优化\"></a>5.2 数据库表的范式化优化</h4><ol>\n<li>表范式化<ul>\n<li>范式化是指数据库设计的规范，目前说道范式化一般是指第三设计范式。也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</li>\n</ul>\n</li>\n<li>反范式化<ul>\n<li>反范式化是指为了查询效率的考虑把原本符合<strong>第三范式</strong>的表“适当”的<strong>增加冗余</strong>，以达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-3-数据库表的垂直拆分\"><a href=\"#5-3-数据库表的垂直拆分\" class=\"headerlink\" title=\"5.3 数据库表的垂直拆分\"></a>5.3 数据库表的垂直拆分</h4><p>所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。</p>\n<ul>\n<li>垂直拆分原则<ol>\n<li>把不常用的字段表单独存放到一个表中。</li>\n<li>把大字段独立存放到一个表中。</li>\n<li>把经常一起使用的字段放到一起。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-4-数据库表的水平拆分\"><a href=\"#5-4-数据库表的水平拆分\" class=\"headerlink\" title=\"5.4 数据库表的水平拆分\"></a>5.4 数据库表的水平拆分</h4><p>表的水平拆分是为了解决单表数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的</p>\n<ol>\n<li>水平拆分原因<ul>\n<li>如果单表的数据量达到上亿条，那么这时候我们尽管加了完美的索引，查询效率低，写入的效率也相应的降低。</li>\n</ul>\n</li>\n<li>如何将数据平均分为N份<ol>\n<li>对customer_id进行hash运算，如果要拆分为5个表则使用mod（customer_id，5）取出0-4个值。</li>\n<li>针对不动的hashid把数据存储到不同的表中。</li>\n</ol>\n</li>\n<li>水平拆分面临的挑战<ol>\n<li>夸分区表进行数据查询<ul>\n<li>前端业务统计：业务上给不同的用户返回不同的业务信息，对分区表没有大的挑战。</li>\n</ul>\n</li>\n<li>统计及后台报表操作<ul>\n<li>但是对后台进行报表统计时，数据量比较大，后台统计时效性比较低，后台就用汇总表，将前后台的表拆分开。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"6-数据库系统配置优化\"><a href=\"#6-数据库系统配置优化\" class=\"headerlink\" title=\"6. 数据库系统配置优化\"></a>6. 数据库系统配置优化</h3><p>数据库是基于操作系统的，目前大多数MySQL都是安装在<strong>linux系统</strong>之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能</p>\n<h4 id=\"6-1-操作系统的优化\"><a href=\"#6-1-操作系统的优化\" class=\"headerlink\" title=\"6.1 操作系统的优化\"></a>6.1 操作系统的优化</h4><p>网络方面的配置，要修改<code>/etc/sysctl.conf</code></p>\n<ol>\n<li>增加tcp支持的队列数<ul>\n<li><code>net.ipv4.tcp_max_syn_backlog = 65535</code></li>\n</ul>\n</li>\n<li>减少断开连接时，资源回收(tcp有连接状态)<ul>\n<li><code>net.ipv4.tcp_max_tw_buckets = 8000</code></li>\n<li><code>net.ipv4.tcp_tw_reuse = 1</code></li>\n<li><code>net.ipv4.tcp_tw_recycle = 1</code></li>\n<li><code>net.ipv4.tcp_fin_timeout = 10</code></li>\n<li>说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-2-打开文件数的限制\"><a href=\"#6-2-打开文件数的限制\" class=\"headerlink\" title=\"6.2 打开文件数的限制\"></a>6.2 打开文件数的限制</h4><p>打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改<code>/etc/security/limits.conf</code>文件</p>\n<ul>\n<li>limits.conf中增加以下内容以修改打开文件数量的限制（永久生效）<ul>\n<li><code>*Soft nofile 65535</code></li>\n<li><code>*Hard nofile 65535</code></li>\n</ul>\n</li>\n<li>如果一次有效，就要使用<code>ulimit –n 65535</code>即可。（默认情况是1024）</li>\n<li>除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件</li>\n</ul>\n<h4 id=\"6-3-MySQL配置文件优化\"><a href=\"#6-3-MySQL配置文件优化\" class=\"headerlink\" title=\"6.3 MySQL配置文件优化\"></a>6.3 MySQL配置文件优化</h4><p>Mysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于<code>/etc/my.cnf</code>或<code>/etc/mysql/my.cnf</code></p>\n<ul>\n<li>MySQL<strong>查找配置文件的顺序</strong>可以通过以下命令获得：<ul>\n<li><code>/usr/sbin/mysqld --verbose --help | grep -A 1 &#39;default options&#39;</code></li>\n<li>注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-3-1-my-cnf常用-连接请求-参数\"><a href=\"#6-3-1-my-cnf常用-连接请求-参数\" class=\"headerlink\" title=\"6.3.1 my.cnf常用 连接请求 参数\"></a>6.3.1 <code>my.cnf</code>常用 连接请求 参数</h5><ol>\n<li><code>max_connections</code>：最大连接数<ul>\n<li>如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，MySQL会为每个连接提供连接缓冲区，连接数越多就会开销越多的内存，所以要<strong>适当调整该值</strong>，不能盲目提高设值。</li>\n<li>数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。</li>\n<li><code>max_used_connections / max_connections * 100% </code>（**理想值≈ 85%**）: 响应的连接数/最大连接数</li>\n</ul>\n</li>\n<li><code>back_log</code>：能暂存的连接数量<ul>\n<li>如果MySQL的连接数据达到<code>max_connections</code>时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即<code>back_log</code>，如果等待连接的数量超过<code>back_log</code>，将不被授予连接资源。</li>\n<li><strong>默认数值是50，可调优为128</strong>，对于Linux系统设置范围为小于512的整数。</li>\n</ul>\n</li>\n<li><code>interactive_timeout</code>：服务器关闭<strong>交互式连接</strong>前等待活动的秒数<ul>\n<li>默认数值是28800，可调优为7200。</li>\n</ul>\n</li>\n<li><code>wait_timeout</code>：服务器关闭<strong>非交互连接</strong>之前等待活动的秒数<ul>\n<li>指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"6-3-1-my-cnf常用-缓冲区-参数\"><a href=\"#6-3-1-my-cnf常用-缓冲区-参数\" class=\"headerlink\" title=\"6.3.1 my.cnf常用 缓冲区 参数\"></a>6.3.1 <code>my.cnf</code>常用 缓冲区 参数</h5><ol>\n<li><code>key_buffer_size</code>: 指定索引缓冲区的大小<ul>\n<li>它决定索引处理的速度，尤其是索引读的速度。</li>\n<li>它只对<strong>MyISAM表起作用</strong>。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值</li>\n</ul>\n</li>\n<li><code>query_cache_size</code> ：查询缓存的内存<ul>\n<li>使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。</li>\n<li>通过检查状态值Qcache_*，可以知道<code>query_cache_size</code>设置是否合理（上述状态值可以使用<code>SHOW STATUS LIKE ‘Qcache%’</code>获得）。如果<code>Qcache_lowmem_prunes</code>的值非常大，则表明经常出现缓冲不够的情况，如果<code>Qcache_hits</code>的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果<code>Qcache_hits</code>的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入<code>SQL_NO_CACHE</code>可以明确表示不使用查询缓冲。</li>\n<li>与查询缓冲有关的参数还有<code>query_cache_type</code>、<code>query_cache_limit</code>、<code>query_cache_min_res_unit</code>。<ul>\n<li><code>query_cache_type</code>指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。</li>\n<li><code>query_cache_limit</code>指定单个查询能够使用的缓冲区大小，缺省为1M。</li>\n<li><code>query_cache_min_res_unit</code>指定分配缓冲区空间的最小单位，缺省为4K。检查状态值<code>Qcache_free_blocks</code>，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小<code>query_cache_min_res_unit</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>record_buffer_size</code>：顺序扫描缓冲区大小<ul>\n<li>每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。</li>\n<li>默认数值是131072(128K)，可改为16773120 (16M)</li>\n</ul>\n</li>\n<li><code>read_rnd_buffer_size</code>：随机读缓冲区大小<ul>\n<li>当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M</li>\n</ul>\n</li>\n<li><code>sort_buffer_size</code>：排序扫描缓冲区大小<ul>\n<li>每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。</li>\n<li>默认数值是2097144(2M)，可改为16777208 (16M)。</li>\n</ul>\n</li>\n<li><code>join_buffer_size</code>：联合查询缓冲区大小<ul>\n<li>联合查询操作所能使用的缓冲区大小。</li>\n<li><code>record_buffer_size</code>，<code>read_rnd_buffer_size</code>，<code>sort_buffer_size</code>，<code>join_buffer_size</code>为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100</li>\n</ul>\n</li>\n<li><code>table_cache</code>：表高速缓存的大小<ul>\n<li>表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值<code>Open_tables</code>和<code>Opened_tables</code>，可以决定是否需要增加<code>table_cache</code>的值。如果你发现open_tables等于<code>table_cache</code>，并且opened_tables在不断增长，那么你就需要增加<code>table_cache</code>的值了（上述状态值可以使用<code>SHOW STATUS LIKE ‘Open%tables’</code>获得）。注意，不能盲目地把<code>table_cache</code>设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。</li>\n<li>1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。</li>\n</ul>\n</li>\n<li><code>max_heap_table_size</code>：用户可以创建的内存表(memory table)的大小<ul>\n<li>这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=#</li>\n<li>这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。</li>\n</ul>\n</li>\n<li><code>tmp_table_size</code>：临时表的大小<ul>\n<li>通过设置<code>tmp_table_size</code>选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。</li>\n<li>每次创建临时表，<code>Created_tmp_tables</code>增加，如果临时表大小超过<code>tmp_table_size</code>，则是在磁盘上创建临时表，<code>Created_tmp_disk_tables</code>也增加,<code>Created_tmp_files</code>表示MySQL服务创建的临时文件文件数</li>\n<li>比较理想的配置是：<code>Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%</code>比如上面的服务器<code>Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%</code>，应该相当好了</li>\n<li>默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞</li>\n</ul>\n</li>\n<li><code>thread_cache_size</code>：可以复用的保存在中的线程的数量<ul>\n<li>可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。</li>\n<li>通过比较 Connections和<code>Threads_created</code>状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。</li>\n</ul>\n</li>\n<li><code>thread_concurrency</code>：同一时间运行的线程系统提示所需数量的线程<ul>\n<li>推荐设置为服务器 CPU核数的2倍，</li>\n<li>例如双核的CPU, 那么<code>thread_concurrency</code>的应该为4；2个双核的cpu, <code>thread_concurrency</code>的值应为8。默认为8</li>\n<li>这个参数<strong>已经在5.7.2版本的MySQL中被移除</strong></li>\n</ul>\n</li>\n</ol>\n<h5 id=\"6-3-1-my-cnf常用-配置InnoDB的-参数\"><a href=\"#6-3-1-my-cnf常用-配置InnoDB的-参数\" class=\"headerlink\" title=\"6.3.1 my.cnf常用 配置InnoDB的 参数\"></a>6.3.1 <code>my.cnf</code>常用 配置InnoDB的 参数</h5><ol>\n<li><code>innodb_buffer_pool_size</code>：缓冲池大小<ul>\n<li>对于InnoDB表来说，<code>innodb_buffer_pool_size</code>的作用就相当于<code>key_buffer_size</code>对于MyISAM表的作用一样。</li>\n<li>InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。</li>\n<li>根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。</li>\n</ul>\n</li>\n<li><code>innodb_flush_log_at_trx_commit</code>：主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个<ul>\n<li>设置为0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；</li>\n<li>设置为1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；</li>\n<li>设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。</li>\n<li>实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。</li>\n<li>根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</li>\n</ul>\n</li>\n<li><code>innodb_log_buffer_size</code>：log缓存大小<ul>\n<li>一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。</li>\n</ul>\n</li>\n<li><code>innodb_additional_mem_pool_size</code>：内存池大小<ul>\n<li>该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。</li>\n<li>根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。</li>\n<li><code>innodb_thread_concurrency=8</code>，推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8</li>\n</ul>\n</li>\n<li><code>skip-name-resolve</code>：禁止域名解析<ul>\n<li>禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。</li>\n<li>但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"7-MySQL的执行顺序\"><a href=\"#7-MySQL的执行顺序\" class=\"headerlink\" title=\"7. MySQL的执行顺序\"></a>7. MySQL的执行顺序</h3><p>MySQL的语句一共分为<strong>11步</strong>，最<strong>先</strong>执行的总是<strong>FROM</strong>操作，最<strong>后</strong>执行的是<strong>LIMIT</strong>操作。</p>\n<ul>\n<li>其中<strong>每一个操作都会产生一张虚拟的表</strong>，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有<strong>最后一个虚拟的表才会被作为结果返回</strong>。</li>\n<li>如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。<ul>\n<li>⑧<code>select</code></li>\n<li>⑨<code>distinct &lt;字段名&gt;</code></li>\n<li>①<code>from &lt;表名&gt;</code></li>\n<li>③<code>&lt;连接类型&gt;join &lt;表名&gt;</code></li>\n<li>②<code>on&lt;连接条件&gt;</code></li>\n<li>④<code>where&lt;查询条件&gt;</code></li>\n<li>④<code>group by&lt;分组字段&gt;</code></li>\n<li>⑥<code>with&#123;cube|rollup&#125;</code></li>\n<li>⑦<code>having&lt;查询条件&gt;</code></li>\n<li>⑩<code>order by&lt;排序字段&gt;</code></li>\n<li>⑪<code>limit&lt;分页数量&gt;</code></li>\n</ul>\n</li>\n</ul>\n<p>查询处理的每一个阶段分析：</p>\n<ol>\n<li><strong>FORM</strong>: 对FROM的左边的表和右边的表计算<strong>笛卡尔积</strong>。产生虚表VT1</li>\n<li><strong>ON</strong>: 对虚表VT1进行ON筛选，只有那些符合<code>&lt;连接条件&gt;</code>的行才会被记录在虚表VT2中。</li>\n<li><strong>JOIN</strong>：如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>\n<li><strong>WHERE</strong>：对虚拟表VT3进行WHERE条件过滤。只有符合<code>&lt;where查询条件&gt;</code>的记录才会被插入到虚拟表VT4中。</li>\n<li><strong>GROUP BY</strong>: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>\n<li><strong>CUBE | ROLLUP</strong>: 对表VT5进行cube或者rollup操作，产生表VT6.</li>\n<li><strong>HAVING</strong>： 对虚拟表VT6应用having过滤，只有符合<code>&lt;having查询条件&gt;</code>的记录才会被 插入到虚拟表VT7中。</li>\n</ol>\n<h3 id=\"8-MySQL执行引擎\"><a href=\"#8-MySQL执行引擎\" class=\"headerlink\" title=\"8. MySQL执行引擎\"></a>8. MySQL执行引擎</h3><h4 id=\"8-1-MyISAM存储引擎\"><a href=\"#8-1-MyISAM存储引擎\" class=\"headerlink\" title=\"8.1 MyISAM存储引擎\"></a>8.1 MyISAM存储引擎</h4><ul>\n<li><strong>不支持事务、也不支持外键</strong>，优势是<strong>访问速度快</strong>，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表</li>\n<li>支持3种不同的存储格式，分别是：静态表；动态表；压缩表</li>\n<li>静态表：<ul>\n<li>表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。</li>\n</ul>\n</li>\n<li>动态表：<ul>\n<li>记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能</li>\n</ul>\n</li>\n<li>压缩表：<ul>\n<li>因为每个记录是被单独压缩的，所以只有非常小的访问开支</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"8-2-InnoDB存储引擎\"><a href=\"#8-2-InnoDB存储引擎\" class=\"headerlink\" title=\"8.2 InnoDB存储引擎\"></a>8.2 InnoDB存储引擎</h4><ul>\n<li>提供了具有提交、回滚和崩溃恢复能力的<strong>事务安全</strong>。但是对比MyISAM引擎，<strong>写的处理效率会差一些</strong>，并且会占用更多的磁盘空间以保留数据和索引。 </li>\n<li>InnoDB存储引擎的特点：<strong>支持自动增长列，支持外键约束</strong></li>\n</ul>\n<h4 id=\"8-3-MEMORY存储引擎\"><a href=\"#8-3-MEMORY存储引擎\" class=\"headerlink\" title=\"8.3 MEMORY存储引擎\"></a>8.3 MEMORY存储引擎</h4><ul>\n<li>Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且<strong>默认使用HASH索引</strong>，但是<strong>一旦服务关闭，表中的数据就会丢失掉</strong>。 </li>\n<li>MEMORY存储引擎的表可以选择使用<strong>BTREE索引</strong>或者<strong>HASH索引</strong>，两种不同类型的索引有其不同的使用范围</li>\n<li>Hash索引优点： <ul>\n<li>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 </li>\n</ul>\n</li>\n<li>Hash索引缺点： <ul>\n<li>那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；</li>\n</ul>\n</li>\n<li>Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。</li>\n</ul>\n<h4 id=\"8-4-MERGE存储引擎\"><a href=\"#8-4-MERGE存储引擎\" class=\"headerlink\" title=\"8.4 MERGE存储引擎\"></a>8.4 MERGE存储引擎</h4><ul>\n<li>Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h3 id=\"1-MySQL基础操作\"><a href=\"#1-MySQL基础操作\" class=\"headerlink\" title=\"1. MySQL基础操作\"></a>1. MySQL基础操作</h3><h4 id=\"1-1-MySQL备份与恢复\"><a href=\"#1-1-MySQL备份与恢复\" class=\"headerlink\" title=\"1.1 MySQL备份与恢复\"></a>1.1 MySQL备份与恢复</h4><ol>\n<li>备份：在mysql的安装目录的bin目录下有<strong>mysqldump命令</strong>，可以完成对数据库的备份。 <ul>\n<li>语法：<code>mysqldump -u 用户名 -p 数据库名&gt; 磁盘SQL文件路径</code>","more":"</li>\n<li>由于mysqldump命令不是sql命令，需要在<strong>dos窗口下使用</strong>。</li>\n<li>仅仅只会备份数据库中的表和数据，恢复时需要先手动创建数据库。</li>\n</ul>\n</li>\n<li>恢复：先手动创建数据库：<code>create database 数据库名</code><ul>\n<li>然后dos窗口：<code>mysql -u 用户名-p 导入库名&lt; 磁盘SQL文件绝对路径</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-2-MySQL事务基础\"><a href=\"#1-2-MySQL事务基础\" class=\"headerlink\" title=\"1.2 MySQL事务基础\"></a>1.2 MySQL事务基础</h4><ol>\n<li>特性(ACID)：<strong>原子性</strong>（Atomicity，或称不可分割性）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation，又称独立性）、<strong>持久性</strong>（Durability）。</li>\n<li>事务隔离级别：<strong>读未提交</strong>（Read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（Serializable）。</li>\n<li>MYSQL事务处理主要有两种方法： <ol>\n<li>用 BEGIN, ROLLBACK, COMMIT来实现:<ul>\n<li>BEGIN 开始一个事务</li>\n<li>COMMIT 事务确认 </li>\n<li>ROLLBACK 事务回滚</li>\n</ul>\n</li>\n<li>直接用 SET 来改变 MySQL 的自动提交模式: <ul>\n<li>SET AUTOCOMMIT=0 禁止自动提交</li>\n<li>SET AUTOCOMMIT=1 开启自动提交</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>事务并发操作出现几种问题: 丢失修改数据、读“脏”数据、数据不一致</li>\n</ol>\n<h4 id=\"1-3-查看设置MySQL编码\"><a href=\"#1-3-查看设置MySQL编码\" class=\"headerlink\" title=\"1.3 查看设置MySQL编码\"></a>1.3 查看设置MySQL编码</h4><ol>\n<li>查看：<code>mysql&gt; show variables like &#39;character%&#39;</code></li>\n<li>设置: # <code>vi /etc/my.cnf</code>：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld] </span><br><span class=\"line\">character‐set‐server=utf8</span><br><span class=\"line\">collation‐server=utf8_general_ci</span><br><span class=\"line\">sql_mode=<span class=\"string\">&#x27;NO_ENGINE_SUBSTITUTION&#x27;</span></span><br><span class=\"line\">[mysql] </span><br><span class=\"line\"><span class=\"keyword\">default</span>‐character‐set = utf8 </span><br><span class=\"line\">[mysql.server] </span><br><span class=\"line\"><span class=\"keyword\">default</span>‐character‐set = utf8 </span><br><span class=\"line\">[mysqld_safe] </span><br><span class=\"line\"><span class=\"keyword\">default</span>‐character‐set = utf8 </span><br><span class=\"line\">[client] </span><br><span class=\"line\"><span class=\"keyword\">default</span>‐character‐set = utf8</span><br></pre></td></tr></table></figure></li>\n<li>mysql的主配置文件: <code>/etc/my.cnf</code></li>\n<li>数据库文件存放位置: <code>/var/lib/mysql</code></li>\n<li>数据库的日志输出存放位置: <code>/var/log/mysql</code></li>\n<li>端口: <code>Netstat –nltp</code> 看是否能找到3306的端口</li>\n</ol>\n<h4 id=\"1-4-范式\"><a href=\"#1-4-范式\" class=\"headerlink\" title=\"1.4 范式\"></a>1.4 范式</h4><p>概念：范式就是符合某一规范级别的关系模式的集合。共有7种范式：<code>1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF⊃6NF</code></p>\n<ol>\n<li>第一范式(1NF, First Normal Form)：字段值具有<strong>原子性</strong>,不能再分(所有关系型数据库系统都满足第一范式);<ul>\n<li>例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;</li>\n</ul>\n</li>\n<li>第二范式(2NF, Second Normal Form)：一个表<strong>必须有主键</strong>,即每行数据都能被唯一的区分(2NF必须先满足第一范式);</li>\n<li>第三范式(3NF, Third Normal Form)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表<strong>不能有冗余字段</strong>(3NF必须先满足第二范式);<ul>\n<li>备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;</li>\n<li>例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-SQL语句优化\"><a href=\"#2-SQL语句优化\" class=\"headerlink\" title=\"2. SQL语句优化\"></a>2. SQL语句优化</h3><h4 id=\"2-1-通过慢查日志发现有问题的SQL\"><a href=\"#2-1-通过慢查日志发现有问题的SQL\" class=\"headerlink\" title=\"2.1 通过慢查日志发现有问题的SQL\"></a>2.1 通过慢查日志发现有问题的SQL</h4><ol>\n<li>查询次数多且每次查询占用时间长的sql<ul>\n<li>通常为<strong>pt-query-digest</strong>分析的前几个查询；该工具可以很清楚的看出每个SQL执行的次数及百分比等信息，执行的次数多，占比比较大的SQL</li>\n</ul>\n</li>\n<li>IO大的sql<ul>\n<li>注意pt-query-digest分析中的Rows examine项。扫描的行数越多，IO越大。</li>\n</ul>\n</li>\n<li>未命中的索引的SQL<ul>\n<li>注意pt-query-digest分析中的Rows examine 和Rows Send的对比。说明该SQL的索引命中率不高，对于这种SQL，我们要重点进行关注。</li>\n</ul>\n</li>\n<li>通过explain查询分析SQL的执行计划, SQL的执行计划侧面反映出了SQL的执行效率，</li>\n</ol>\n<h4 id=\"2-2-常见SQL优化手段\"><a href=\"#2-2-常见SQL优化手段\" class=\"headerlink\" title=\"2.2 常见SQL优化手段\"></a>2.2 常见SQL优化手段</h4><ol>\n<li>函数Max()的优化<ul>\n<li>在求max的字段<strong>建索引</strong></li>\n</ul>\n</li>\n<li>函数Count()的优化：<ul>\n<li>Count(*):是包含null值；Count(id)：不包含null值</li>\n</ul>\n</li>\n<li>子查询的优化<ul>\n<li>子查询是我们在开发过程中经常使用的一种方式，在通常情况下，需要把<strong>子查询优化为join查询</strong>但在优化是需要注意关联键是否有一对多的关系，要注意重复数据(distinct去重)。</li>\n<li>在用Join进行多表联合查询时，我们通常使用On来建立两个表的关系。其实还有一个更方便的关键字，那就是Using（如果两个表的关联字段名是一样）。</li>\n</ul>\n</li>\n<li>group by的优化: <ul>\n<li>最好使用同一表中的列，在子查询中分组</li>\n</ul>\n</li>\n<li>Limit查询的优化：Limit常用于分页处理，时常会伴随order by从句使用，因此大多时候会使用Filesorts这样会造成大量的IO问题。<ul>\n<li>优化步骤1：使用有索引的列或主键进行order by操作，因为大家知道，innodb是按照主键的逻辑顺序进行排序的。可以避免很多的IO操作。</li>\n<li>优化步骤2：记录上次返回的主键， 在下次查询时使用主键过滤。（说明：避免了数据量大时扫描过多的记录）</li>\n<li>注意事项：主键要顺序排序并连续的，如果主键中间空缺了某一列，或者某几列，会出现列出数据不足一页的数据；如果不连续的情况，建立一个附加的列index_id列，保证这一列数据要自增的，并添加索引即可。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-索引的优化\"><a href=\"#3-索引的优化\" class=\"headerlink\" title=\"3. 索引的优化\"></a>3. 索引的优化</h3><h4 id=\"3-1-索引基础概念\"><a href=\"#3-1-索引基础概念\" class=\"headerlink\" title=\"3.1 索引基础概念\"></a>3.1 索引基础概念</h4><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p>\n<ul>\n<li>索引的建立是表中<strong>比较有指向性的字段</strong>，相当于目录，比如说行政区域代码，同一个地域的行政区域代码都是相同的，那么给这一列加上索引，避免让它重复扫描，从而达到优化的目的！</li>\n<li>创建索引：在执行create table语句时可以创建索引，也可以单独用create index或alter index来为表增加索引。<strong>不能用create index语句创建primary key索引</strong>。</li>\n<li>在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为primary key或unique索引。对于单列惟一性索引，这保证单列不包含重复的值。对于<strong>多列惟一性索引，保证多个值的组合不重复</strong>。</li>\n<li>primary key索引和unique索引非常类似。事实上，<strong>primary key索引仅是一个具有名称PRIMARY的unique索引</strong>。</li>\n<li>查看索引：<code>show index from tblname;</code>或<code>show keys from tblname;</code></li>\n</ul>\n<h4 id=\"3-2-索引的创建与删除\"><a href=\"#3-2-索引的创建与删除\" class=\"headerlink\" title=\"3.2 索引的创建与删除\"></a>3.2 索引的创建与删除</h4><ol>\n<li>创建<strong>普通索引</strong>：<ul>\n<li>方式1：<code>create index 索引名 on 表名(列名)</code></li>\n<li>方式2：<code>alter table 表名 add index 索引名(列名)</code></li>\n<li>方式3：创建表的时候直接指定: <code>,index [索引名] (列名)</code></li>\n</ul>\n</li>\n<li>删除索引： <code>drop index [索引名] on 表名</code></li>\n<li>唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li>\n<li>创建<strong>唯一索引</strong>：<ul>\n<li>方式1：<code>create unique index 索引名 on 表名(列名)</code></li>\n<li>方式2：<code>alter table 表名 add unique 索引名(列名)</code></li>\n<li>方式3：创建表的时候直接指定: <code>,unique [索引名] (列名)</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-3-使用索引的场景\"><a href=\"#3-3-使用索引的场景\" class=\"headerlink\" title=\"3.3 使用索引的场景\"></a>3.3 使用索引的场景</h4><ol>\n<li>表的主键自动建立唯一索引</li>\n<li>表的字段唯一约束</li>\n<li>直接条件查询的字段（在SQL中用于条件约束的字段）</li>\n<li>查询中与其它表关联的字段</li>\n<li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li>\n<li>查询中统计或分组统计的字段</li>\n<li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li>\n<li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li>\n<li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li>\n<li>经常和主字段一块查询但主字段索引值比较多的表字段</li>\n<li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li>\n</ol>\n<h4 id=\"3-4-索引的维护及优化（重复及冗余索引）\"><a href=\"#3-4-索引的维护及优化（重复及冗余索引）\" class=\"headerlink\" title=\"3.4 索引的维护及优化（重复及冗余索引）\"></a>3.4 索引的维护及优化（重复及冗余索引）</h4><p>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引</p>\n<ul>\n<li>重复索引：重复索引是指相同的列以相同的顺序建立的同类型的索引，如在primary key再建立唯一索引就是重复索引</li>\n<li>冗余索引：冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，如对于innodb来说，每一个索引后面，实际上都会包含主键，这时候我们建立的联合索引，又人为的把主键包含进去，那么这个时候就是一个冗余索引。</li>\n<li>工具：使用**<code>pt-duplicate-key-checker</code>工具检查重复及冗余索引**: <code>pt-duplicate-key-checker -uroot -padmin -h 127.0.0.1</code></li>\n<li>索引维护的方法: 由于业务变更，某些索引是后续不需要使用的，就要进行<strong>删除</strong>。</li>\n<li>在mysql中，目前只能通过慢查询日志配合pt-index-usage工具来进行索引使用情况的分析；<code>pt-index-usage -uroot -padmin /var/lib/mysql/mysql-host-slow.log</code></li>\n</ul>\n<h4 id=\"3-5-设计MySql索引的注意事项\"><a href=\"#3-5-设计MySql索引的注意事项\" class=\"headerlink\" title=\"3.5 设计MySql索引的注意事项\"></a>3.5 设计MySql索引的注意事项</h4><p>设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：</p>\n<ol>\n<li><strong>创建索引</strong><ul>\n<li>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。</li>\n<li>但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</li>\n</ul>\n</li>\n<li><strong>复合索引</strong><ul>\n<li>比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;</li>\n<li>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为<strong>最佳左前缀特性</strong>。</li>\n<li>因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</li>\n</ul>\n</li>\n<li>索引不会包含有NULL值的列<ul>\n<li>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有<strong>NULL值</strong>，那么这一列对于此复合索引就是<strong>无效</strong>的。所以我们在数据库设计时不要让字段的默认值为NULL。</li>\n</ul>\n</li>\n<li>使用短索引<ul>\n<li>对字符串列进行索引，如果可能应该<strong>指定一个前缀长度</strong>。</li>\n<li>例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li>\n</ul>\n</li>\n<li>排序的索引问题<ul>\n<li>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列<strong>创建复合索引</strong>。</li>\n</ul>\n</li>\n<li>like语句操作<ul>\n<li>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” <strong>不会使用索引</strong>，而like “aaa%”可以使用索引。</li>\n</ul>\n</li>\n<li>不要在列上进行运算<ul>\n<li>select * from users where YEAR(adddate)</li>\n</ul>\n</li>\n<li>不使用NOT IN操作<ul>\n<li>NOT IN操作都不会使用索引将进行全表扫描。NOT IN可以<strong>NOT EXISTS代替</strong></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-MYSQL数据库设计规范与原则\"><a href=\"#4-MYSQL数据库设计规范与原则\" class=\"headerlink\" title=\"4. MYSQL数据库设计规范与原则\"></a>4. MYSQL数据库设计规范与原则</h3><h4 id=\"4-1-设计规范\"><a href=\"#4-1-设计规范\" class=\"headerlink\" title=\"4.1 设计规范\"></a>4.1 设计规范</h4><ol>\n<li>命名规范<ul>\n<li>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成</li>\n<li>命名简洁明确,多个单词用下划线’_’分隔,长度不超过30个字符</li>\n<li>除非是备份数据库可以加0-9的自然数,如：<code>&#39;user_db_20191210&#39;</code></li>\n<li>表前缀可以有效的把相同关系的表显示在一起,如：<code>&#39;user_&#39;</code></li>\n<li>每个表中必须有自增主键</li>\n<li>表与表之间的相关联字段名称要求尽可能的相同</li>\n</ul>\n</li>\n<li>字段类型规范<ul>\n<li>用尽量少的存储空间来存数一个字段的数据, 例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);</li>\n<li>IP地址最好使用int类型;</li>\n<li>固定长度的类型最好使用char,例如：邮编;</li>\n<li>能使用tinyint就不要使用smallint,int;</li>\n<li>最好给每个字段一个默认值, 最好不能为null;</li>\n</ul>\n</li>\n<li>索引规范<ul>\n<li>命名简洁明确,例如：<code>user_login</code>表<code>user_name</code>字段的索引应为<code>user_name_index</code>唯一索引;</li>\n<li>为每个表创建一个主键索引;</li>\n<li>为每个表创建合理的索引;</li>\n<li>建立复合索引请<strong>慎重</strong>;</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-2-设计原则\"><a href=\"#4-2-设计原则\" class=\"headerlink\" title=\"4.2 设计原则\"></a>4.2 设计原则</h4><ol>\n<li>核心原则<ul>\n<li>不在数据库做运算;</li>\n<li>cpu计算务必移至业务层;</li>\n<li>控制列数量(字段少而精,字段数建议在20以内);</li>\n<li>平衡范式与冗余(效率优先；往往牺牲范式)</li>\n<li>拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch); </li>\n</ul>\n</li>\n<li>字段类原则<ul>\n<li>用好数值类型(用合适的字段类型节约空间);</li>\n<li>字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);</li>\n<li>避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);</li>\n<li>少用text类型(尽量使用varchar代替text字段); </li>\n</ul>\n</li>\n<li>索引类原则<ul>\n<li>合理使用索引(改善查询,减慢更新,索引一定不是越多越好);</li>\n<li>字符字段必须建前缀索引;</li>\n<li>不在索引做列运算;</li>\n<li>innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);</li>\n<li>不用外键(由程序保证约束);</li>\n</ul>\n</li>\n<li>sql类原则<ul>\n<li>sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);</li>\n<li>简单的事务;</li>\n<li>避免使用trig/func(触发器、函数不用客户端程序取而代之);</li>\n<li>不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性);</li>\n<li>OR改写为IN(or的效率是n级别);</li>\n<li>OR改写为UNION(mysql的索引合并很弱智);</li>\n<li>避免负向%;</li>\n<li>慎用count(*);</li>\n<li>limit高效分页(limit越大，效率越低);</li>\n<li>使用union all替代union(union有去重开销);</li>\n<li>少用连接join;</li>\n<li>使用group by;</li>\n<li>请使用同类型比较;</li>\n<li>打散批量更新;</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-数据库结构的优化\"><a href=\"#5-数据库结构的优化\" class=\"headerlink\" title=\"5. 数据库结构的优化\"></a>5. 数据库结构的优化</h3><h4 id=\"5-1-选择合适的数据类型\"><a href=\"#5-1-选择合适的数据类型\" class=\"headerlink\" title=\"5.1 选择合适的数据类型\"></a>5.1 选择合适的数据类型</h4><p>数据类型的选择，重点在于“合适”二字</p>\n<ol>\n<li>使用可以存下你的数据的最小的数据类型。（时间类型数据：可以使用varchar类型，可以使用int类型，也可以使用时间戳类型）</li>\n<li>使用简单的数据类型，int要比varchar类型在mysql处理上简单。（int类型存储时间是最好的选择）</li>\n<li>尽可能的使用not null定义字段。（innodb的特性所决定，非not null的值，需要额外的在字段存储，同时也会增加IO和存储的开销）</li>\n<li>尽量少用text类型，非用不可时最好考虑分表。</li>\n</ol>\n<h4 id=\"5-2-数据库表的范式化优化\"><a href=\"#5-2-数据库表的范式化优化\" class=\"headerlink\" title=\"5.2 数据库表的范式化优化\"></a>5.2 数据库表的范式化优化</h4><ol>\n<li>表范式化<ul>\n<li>范式化是指数据库设计的规范，目前说道范式化一般是指第三设计范式。也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</li>\n</ul>\n</li>\n<li>反范式化<ul>\n<li>反范式化是指为了查询效率的考虑把原本符合<strong>第三范式</strong>的表“适当”的<strong>增加冗余</strong>，以达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-3-数据库表的垂直拆分\"><a href=\"#5-3-数据库表的垂直拆分\" class=\"headerlink\" title=\"5.3 数据库表的垂直拆分\"></a>5.3 数据库表的垂直拆分</h4><p>所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。</p>\n<ul>\n<li>垂直拆分原则<ol>\n<li>把不常用的字段表单独存放到一个表中。</li>\n<li>把大字段独立存放到一个表中。</li>\n<li>把经常一起使用的字段放到一起。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-4-数据库表的水平拆分\"><a href=\"#5-4-数据库表的水平拆分\" class=\"headerlink\" title=\"5.4 数据库表的水平拆分\"></a>5.4 数据库表的水平拆分</h4><p>表的水平拆分是为了解决单表数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的</p>\n<ol>\n<li>水平拆分原因<ul>\n<li>如果单表的数据量达到上亿条，那么这时候我们尽管加了完美的索引，查询效率低，写入的效率也相应的降低。</li>\n</ul>\n</li>\n<li>如何将数据平均分为N份<ol>\n<li>对customer_id进行hash运算，如果要拆分为5个表则使用mod（customer_id，5）取出0-4个值。</li>\n<li>针对不动的hashid把数据存储到不同的表中。</li>\n</ol>\n</li>\n<li>水平拆分面临的挑战<ol>\n<li>夸分区表进行数据查询<ul>\n<li>前端业务统计：业务上给不同的用户返回不同的业务信息，对分区表没有大的挑战。</li>\n</ul>\n</li>\n<li>统计及后台报表操作<ul>\n<li>但是对后台进行报表统计时，数据量比较大，后台统计时效性比较低，后台就用汇总表，将前后台的表拆分开。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"6-数据库系统配置优化\"><a href=\"#6-数据库系统配置优化\" class=\"headerlink\" title=\"6. 数据库系统配置优化\"></a>6. 数据库系统配置优化</h3><p>数据库是基于操作系统的，目前大多数MySQL都是安装在<strong>linux系统</strong>之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能</p>\n<h4 id=\"6-1-操作系统的优化\"><a href=\"#6-1-操作系统的优化\" class=\"headerlink\" title=\"6.1 操作系统的优化\"></a>6.1 操作系统的优化</h4><p>网络方面的配置，要修改<code>/etc/sysctl.conf</code></p>\n<ol>\n<li>增加tcp支持的队列数<ul>\n<li><code>net.ipv4.tcp_max_syn_backlog = 65535</code></li>\n</ul>\n</li>\n<li>减少断开连接时，资源回收(tcp有连接状态)<ul>\n<li><code>net.ipv4.tcp_max_tw_buckets = 8000</code></li>\n<li><code>net.ipv4.tcp_tw_reuse = 1</code></li>\n<li><code>net.ipv4.tcp_tw_recycle = 1</code></li>\n<li><code>net.ipv4.tcp_fin_timeout = 10</code></li>\n<li>说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-2-打开文件数的限制\"><a href=\"#6-2-打开文件数的限制\" class=\"headerlink\" title=\"6.2 打开文件数的限制\"></a>6.2 打开文件数的限制</h4><p>打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改<code>/etc/security/limits.conf</code>文件</p>\n<ul>\n<li>limits.conf中增加以下内容以修改打开文件数量的限制（永久生效）<ul>\n<li><code>*Soft nofile 65535</code></li>\n<li><code>*Hard nofile 65535</code></li>\n</ul>\n</li>\n<li>如果一次有效，就要使用<code>ulimit –n 65535</code>即可。（默认情况是1024）</li>\n<li>除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件</li>\n</ul>\n<h4 id=\"6-3-MySQL配置文件优化\"><a href=\"#6-3-MySQL配置文件优化\" class=\"headerlink\" title=\"6.3 MySQL配置文件优化\"></a>6.3 MySQL配置文件优化</h4><p>Mysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于<code>/etc/my.cnf</code>或<code>/etc/mysql/my.cnf</code></p>\n<ul>\n<li>MySQL<strong>查找配置文件的顺序</strong>可以通过以下命令获得：<ul>\n<li><code>/usr/sbin/mysqld --verbose --help | grep -A 1 &#39;default options&#39;</code></li>\n<li>注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"6-3-1-my-cnf常用-连接请求-参数\"><a href=\"#6-3-1-my-cnf常用-连接请求-参数\" class=\"headerlink\" title=\"6.3.1 my.cnf常用 连接请求 参数\"></a>6.3.1 <code>my.cnf</code>常用 连接请求 参数</h5><ol>\n<li><code>max_connections</code>：最大连接数<ul>\n<li>如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，MySQL会为每个连接提供连接缓冲区，连接数越多就会开销越多的内存，所以要<strong>适当调整该值</strong>，不能盲目提高设值。</li>\n<li>数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。</li>\n<li><code>max_used_connections / max_connections * 100% </code>（**理想值≈ 85%**）: 响应的连接数/最大连接数</li>\n</ul>\n</li>\n<li><code>back_log</code>：能暂存的连接数量<ul>\n<li>如果MySQL的连接数据达到<code>max_connections</code>时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即<code>back_log</code>，如果等待连接的数量超过<code>back_log</code>，将不被授予连接资源。</li>\n<li><strong>默认数值是50，可调优为128</strong>，对于Linux系统设置范围为小于512的整数。</li>\n</ul>\n</li>\n<li><code>interactive_timeout</code>：服务器关闭<strong>交互式连接</strong>前等待活动的秒数<ul>\n<li>默认数值是28800，可调优为7200。</li>\n</ul>\n</li>\n<li><code>wait_timeout</code>：服务器关闭<strong>非交互连接</strong>之前等待活动的秒数<ul>\n<li>指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"6-3-1-my-cnf常用-缓冲区-参数\"><a href=\"#6-3-1-my-cnf常用-缓冲区-参数\" class=\"headerlink\" title=\"6.3.1 my.cnf常用 缓冲区 参数\"></a>6.3.1 <code>my.cnf</code>常用 缓冲区 参数</h5><ol>\n<li><code>key_buffer_size</code>: 指定索引缓冲区的大小<ul>\n<li>它决定索引处理的速度，尤其是索引读的速度。</li>\n<li>它只对<strong>MyISAM表起作用</strong>。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值</li>\n</ul>\n</li>\n<li><code>query_cache_size</code> ：查询缓存的内存<ul>\n<li>使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。</li>\n<li>通过检查状态值Qcache_*，可以知道<code>query_cache_size</code>设置是否合理（上述状态值可以使用<code>SHOW STATUS LIKE ‘Qcache%’</code>获得）。如果<code>Qcache_lowmem_prunes</code>的值非常大，则表明经常出现缓冲不够的情况，如果<code>Qcache_hits</code>的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果<code>Qcache_hits</code>的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入<code>SQL_NO_CACHE</code>可以明确表示不使用查询缓冲。</li>\n<li>与查询缓冲有关的参数还有<code>query_cache_type</code>、<code>query_cache_limit</code>、<code>query_cache_min_res_unit</code>。<ul>\n<li><code>query_cache_type</code>指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。</li>\n<li><code>query_cache_limit</code>指定单个查询能够使用的缓冲区大小，缺省为1M。</li>\n<li><code>query_cache_min_res_unit</code>指定分配缓冲区空间的最小单位，缺省为4K。检查状态值<code>Qcache_free_blocks</code>，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小<code>query_cache_min_res_unit</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>record_buffer_size</code>：顺序扫描缓冲区大小<ul>\n<li>每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。</li>\n<li>默认数值是131072(128K)，可改为16773120 (16M)</li>\n</ul>\n</li>\n<li><code>read_rnd_buffer_size</code>：随机读缓冲区大小<ul>\n<li>当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M</li>\n</ul>\n</li>\n<li><code>sort_buffer_size</code>：排序扫描缓冲区大小<ul>\n<li>每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。</li>\n<li>默认数值是2097144(2M)，可改为16777208 (16M)。</li>\n</ul>\n</li>\n<li><code>join_buffer_size</code>：联合查询缓冲区大小<ul>\n<li>联合查询操作所能使用的缓冲区大小。</li>\n<li><code>record_buffer_size</code>，<code>read_rnd_buffer_size</code>，<code>sort_buffer_size</code>，<code>join_buffer_size</code>为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100</li>\n</ul>\n</li>\n<li><code>table_cache</code>：表高速缓存的大小<ul>\n<li>表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值<code>Open_tables</code>和<code>Opened_tables</code>，可以决定是否需要增加<code>table_cache</code>的值。如果你发现open_tables等于<code>table_cache</code>，并且opened_tables在不断增长，那么你就需要增加<code>table_cache</code>的值了（上述状态值可以使用<code>SHOW STATUS LIKE ‘Open%tables’</code>获得）。注意，不能盲目地把<code>table_cache</code>设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。</li>\n<li>1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。</li>\n</ul>\n</li>\n<li><code>max_heap_table_size</code>：用户可以创建的内存表(memory table)的大小<ul>\n<li>这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=#</li>\n<li>这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。</li>\n</ul>\n</li>\n<li><code>tmp_table_size</code>：临时表的大小<ul>\n<li>通过设置<code>tmp_table_size</code>选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。</li>\n<li>每次创建临时表，<code>Created_tmp_tables</code>增加，如果临时表大小超过<code>tmp_table_size</code>，则是在磁盘上创建临时表，<code>Created_tmp_disk_tables</code>也增加,<code>Created_tmp_files</code>表示MySQL服务创建的临时文件文件数</li>\n<li>比较理想的配置是：<code>Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%</code>比如上面的服务器<code>Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%</code>，应该相当好了</li>\n<li>默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞</li>\n</ul>\n</li>\n<li><code>thread_cache_size</code>：可以复用的保存在中的线程的数量<ul>\n<li>可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。</li>\n<li>通过比较 Connections和<code>Threads_created</code>状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。</li>\n</ul>\n</li>\n<li><code>thread_concurrency</code>：同一时间运行的线程系统提示所需数量的线程<ul>\n<li>推荐设置为服务器 CPU核数的2倍，</li>\n<li>例如双核的CPU, 那么<code>thread_concurrency</code>的应该为4；2个双核的cpu, <code>thread_concurrency</code>的值应为8。默认为8</li>\n<li>这个参数<strong>已经在5.7.2版本的MySQL中被移除</strong></li>\n</ul>\n</li>\n</ol>\n<h5 id=\"6-3-1-my-cnf常用-配置InnoDB的-参数\"><a href=\"#6-3-1-my-cnf常用-配置InnoDB的-参数\" class=\"headerlink\" title=\"6.3.1 my.cnf常用 配置InnoDB的 参数\"></a>6.3.1 <code>my.cnf</code>常用 配置InnoDB的 参数</h5><ol>\n<li><code>innodb_buffer_pool_size</code>：缓冲池大小<ul>\n<li>对于InnoDB表来说，<code>innodb_buffer_pool_size</code>的作用就相当于<code>key_buffer_size</code>对于MyISAM表的作用一样。</li>\n<li>InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。</li>\n<li>根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。</li>\n</ul>\n</li>\n<li><code>innodb_flush_log_at_trx_commit</code>：主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个<ul>\n<li>设置为0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；</li>\n<li>设置为1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；</li>\n<li>设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。</li>\n<li>实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。</li>\n<li>根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</li>\n</ul>\n</li>\n<li><code>innodb_log_buffer_size</code>：log缓存大小<ul>\n<li>一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。</li>\n</ul>\n</li>\n<li><code>innodb_additional_mem_pool_size</code>：内存池大小<ul>\n<li>该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。</li>\n<li>根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。</li>\n<li><code>innodb_thread_concurrency=8</code>，推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8</li>\n</ul>\n</li>\n<li><code>skip-name-resolve</code>：禁止域名解析<ul>\n<li>禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。</li>\n<li>但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"7-MySQL的执行顺序\"><a href=\"#7-MySQL的执行顺序\" class=\"headerlink\" title=\"7. MySQL的执行顺序\"></a>7. MySQL的执行顺序</h3><p>MySQL的语句一共分为<strong>11步</strong>，最<strong>先</strong>执行的总是<strong>FROM</strong>操作，最<strong>后</strong>执行的是<strong>LIMIT</strong>操作。</p>\n<ul>\n<li>其中<strong>每一个操作都会产生一张虚拟的表</strong>，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有<strong>最后一个虚拟的表才会被作为结果返回</strong>。</li>\n<li>如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。<ul>\n<li>⑧<code>select</code></li>\n<li>⑨<code>distinct &lt;字段名&gt;</code></li>\n<li>①<code>from &lt;表名&gt;</code></li>\n<li>③<code>&lt;连接类型&gt;join &lt;表名&gt;</code></li>\n<li>②<code>on&lt;连接条件&gt;</code></li>\n<li>④<code>where&lt;查询条件&gt;</code></li>\n<li>④<code>group by&lt;分组字段&gt;</code></li>\n<li>⑥<code>with&#123;cube|rollup&#125;</code></li>\n<li>⑦<code>having&lt;查询条件&gt;</code></li>\n<li>⑩<code>order by&lt;排序字段&gt;</code></li>\n<li>⑪<code>limit&lt;分页数量&gt;</code></li>\n</ul>\n</li>\n</ul>\n<p>查询处理的每一个阶段分析：</p>\n<ol>\n<li><strong>FORM</strong>: 对FROM的左边的表和右边的表计算<strong>笛卡尔积</strong>。产生虚表VT1</li>\n<li><strong>ON</strong>: 对虚表VT1进行ON筛选，只有那些符合<code>&lt;连接条件&gt;</code>的行才会被记录在虚表VT2中。</li>\n<li><strong>JOIN</strong>：如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>\n<li><strong>WHERE</strong>：对虚拟表VT3进行WHERE条件过滤。只有符合<code>&lt;where查询条件&gt;</code>的记录才会被插入到虚拟表VT4中。</li>\n<li><strong>GROUP BY</strong>: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>\n<li><strong>CUBE | ROLLUP</strong>: 对表VT5进行cube或者rollup操作，产生表VT6.</li>\n<li><strong>HAVING</strong>： 对虚拟表VT6应用having过滤，只有符合<code>&lt;having查询条件&gt;</code>的记录才会被 插入到虚拟表VT7中。</li>\n</ol>\n<h3 id=\"8-MySQL执行引擎\"><a href=\"#8-MySQL执行引擎\" class=\"headerlink\" title=\"8. MySQL执行引擎\"></a>8. MySQL执行引擎</h3><h4 id=\"8-1-MyISAM存储引擎\"><a href=\"#8-1-MyISAM存储引擎\" class=\"headerlink\" title=\"8.1 MyISAM存储引擎\"></a>8.1 MyISAM存储引擎</h4><ul>\n<li><strong>不支持事务、也不支持外键</strong>，优势是<strong>访问速度快</strong>，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表</li>\n<li>支持3种不同的存储格式，分别是：静态表；动态表；压缩表</li>\n<li>静态表：<ul>\n<li>表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。</li>\n</ul>\n</li>\n<li>动态表：<ul>\n<li>记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能</li>\n</ul>\n</li>\n<li>压缩表：<ul>\n<li>因为每个记录是被单独压缩的，所以只有非常小的访问开支</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"8-2-InnoDB存储引擎\"><a href=\"#8-2-InnoDB存储引擎\" class=\"headerlink\" title=\"8.2 InnoDB存储引擎\"></a>8.2 InnoDB存储引擎</h4><ul>\n<li>提供了具有提交、回滚和崩溃恢复能力的<strong>事务安全</strong>。但是对比MyISAM引擎，<strong>写的处理效率会差一些</strong>，并且会占用更多的磁盘空间以保留数据和索引。 </li>\n<li>InnoDB存储引擎的特点：<strong>支持自动增长列，支持外键约束</strong></li>\n</ul>\n<h4 id=\"8-3-MEMORY存储引擎\"><a href=\"#8-3-MEMORY存储引擎\" class=\"headerlink\" title=\"8.3 MEMORY存储引擎\"></a>8.3 MEMORY存储引擎</h4><ul>\n<li>Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且<strong>默认使用HASH索引</strong>，但是<strong>一旦服务关闭，表中的数据就会丢失掉</strong>。 </li>\n<li>MEMORY存储引擎的表可以选择使用<strong>BTREE索引</strong>或者<strong>HASH索引</strong>，两种不同类型的索引有其不同的使用范围</li>\n<li>Hash索引优点： <ul>\n<li>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 </li>\n</ul>\n</li>\n<li>Hash索引缺点： <ul>\n<li>那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；</li>\n</ul>\n</li>\n<li>Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。</li>\n</ul>\n<h4 id=\"8-4-MERGE存储引擎\"><a href=\"#8-4-MERGE存储引擎\" class=\"headerlink\" title=\"8.4 MERGE存储引擎\"></a>8.4 MERGE存储引擎</h4><ul>\n<li>Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。</li>\n</ul>"},{"title":"【数据库】数据库语言SQL","date":"2019-07-01T11:36:31.000Z","_content":"\n### SQL语言概述\n**结构化查询语言**(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。\n+ SQL语言是集DDL、DML和DCL于一体的数据库语言<!-- more -->\n    1. **DDL语句**引导词：Create(建立),Alter(修改),Drop(撤消)\n        - 模式的定义和删除，包括定义Database,Table,View,Index,完整性约束条件等，也包括定义对象(RowType行对象,Type列对象)\n    2. **DML语句**引导词：Insert ,Delete, Update, Select\n        - 各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入\n        - 各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等\n        - 各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等\n    3. **DCL语句**引导词：Grant,Revoke\n        - 安全性控制：授权和撤消授权\n\n\n#### 目录：\n1. [利用SQL建立数据库](#id1)\n2. [利用SQL简单查询](#id2)\n3. [利用SQL多表联合查询](#id3)\n4. [利用SQL进行增-删-改](#id4)\n5. [利用SQL语言修正与撤销数据库](#id5)\n6. [SQL Server介绍](#id6)\n7. [SQL语言-子查询](#id7)\n8. [SQL语言-结果计算与聚集计算](#id8)\n9. [SQL语言-分组查询与分组过滤](#id9)\n10. [SQL语言实现关系代数操作](#id10)\n11. [SQL语言之视图及其应用](#id11)\n12. [数据库完整性](#id12)\n13. [数据库的静态完整性(约束)](#id13)\n14. [数据库的动态完整性(触发器)](#id14)\n15. [数据库索引](#id15)\n16. [数据库序列](#id16)\n17. [数据库安全性](#id17)\n18. [数据库自主安全性机制](#id18)\n\n\n<span id=\"id1\"><span>\n### 1. 利用SQL建立数据库\nDDL：数据定义语言（Data Definition Language)，\nDDL通常由**DBA(数据库管理员)**来使用，也有经DBA授权后由应用程序员来使用\n1. 创建数据库(DB)：**Create Database**\n    + 数据库(Database)是若干具有相互关联关系的Table/Relation的集合\n    + 简单语法形式：`create database database 数据库名;`\n2. 创建DB中的Table(定义关系模式)：**Create Table**\n    + `Create table 表名(列名 数据类型 [Primary key|Unique] [Not null][,列名 数据类型 [Not null], …]);`\n        - `[]`表示其括起的内容可以省略，`|`表示其隔开的两项可取其一\n        - `Primary key`: 主键约束。每个表只能创建一个主键约束\n        - `Unique`: 唯一性约束(即候选键)。可以有多个唯一性约束\n        - `Not null`: 非空约束。\n3. **数据类型**（SQL-92标准）\n    + `char(n)`:固定长度的字符串\n    + `varchar(n)`:可变长字符串\n    + `int`:整数 //有时不同系统也写作integer\n    + `numeric(p，q)`:固定精度数字，小数点左边p位，右边(p-q)位\n    + `real`:浮点精度数字 //有时不同系统也写作`float(n)`，小数点后保留n位\n    + `date`:日期 (如 2003-09-12)\n    + `time`:时间 (如 23:15:003)\n> 注意: 现行商用DBMS的数据类型有时有些差异\n\n\n<span id=\"id2\"><span>\n### 2. 利用SQL简单查询\nDML：数据操纵语言（Data Manipulation Language)，\nDML通常由**用户或应用程序员**使用，访问经授权的数据库\n1. 向Table中添加数据(追加元组)：**Insert into**\n    + **`insert into insert into 表名[(列名[, 列名] …] values (值[,值], …);`**\n        - values值的排列，须与列名排列一致\n        - 若所有列名省略，则values值的排列须与该表存储中的列名排列一致\n\n2. 单表查询**Select**\n    + **`Select Select 列名[[,列名] …] From 表名[Where 检索条件];`**\n        - 语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示。\n        - 相当于：`Π[列名,...,列名](σ检索条件(表名))`\n    + Select语句中的select … , from… , where…, 等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。\n\n3. 检索条件的书写**Where**\n    + 与选择运算`σF(R)`的条件F书写一样，只是其逻辑运算符用 and,or,not 来表示, 同时也要注意运算符的优先次序及括弧的使用。书写要点是注意对自然语言检索条件的正确理解。\n    + `Select Tname From Teacher Where Salary > 2000 and D# = ’03’;`//检索教师表中所有工资大于2000元 并且是03系的教师姓名\n\n4. 排重(`DISTINCT`)\n    + 关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组。\n    + 在Table中要求无重复元组是通过定义Primary key或Unique来保证的;\n    + 而在检索结果中要求无重复元组, 是通过**DISTINCT保留字**的使用来实现的。\n    + `Select DISTINCT S# From SC Where Score > 80; `\n\n5. 排序(`ORDER BY`)\n    + Select语句中结果排序是通过增加**order by**子句实现的\n    + `order by 列名 [asc|desc]`\n    + 意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。\n\n6. 模糊查询(`*LIKE*`)\n    + `_`：一个字符，`%`：任意长度字符。\n    + `Select Sname From Student Where Sname Like '张_ _';`//检索名字为张某某的所有同学姓名\n    + `Select Sname From Student Where Sname Not Like '张%';`//检索名字不姓张的所有同学姓名\n\n\n<span id=\"id3\"><span>\n### 3. 利用SQL多表联合查询\n多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进行选择运算来实现。\n+ 检索语句: **`Select 列名[[,列名] …] From 表名1,表名2,… Where 检索条件;`**\n+ 相当于`Π[列名,...,列名](σ检索条件(表名1 × 表名2 × …))`\n+ 检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种θ-连接\n\n1. θ-连接之**等值连接**\n    + 多表连接时，如两个表的属性名相同，则需采用**`表名.属性名`**方式来限定该属性是属于哪一个表\n    + `Select Sname From Student, SC Where Student.S#=SC.S# and SC.C#='001' Order By Score DESC;`//按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接)\n\n2. 属性重名重名处理(表别名)\n    + 连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用**`别名`**以便区分\n    + `Select 列名 as 列别名[[,列名 as 列别名] …] From 表名1 as 表别名1,表名2 as 表别名2,… Where Where 检索条件;`\n    + 当定义了别名后，在检索条件中可以使用别名来限定属性\n    + as 可以省略\n\n3. θ-连接之**不等值连接**\n    + `Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary>T2.Salary;`//求有薪水差额的任意两位教师\n\n4. 实例：\n    + `Select S1.S# From SC S1, SC S2 Where S1.S# = S2.S# and S1.C#='001' and S2.C#='002' and S1.Score > S2.Score;`//求“001”号课成绩比“002”号课成绩高的所有学生的学号\n\n\n<span id=\"id4\"><span>\n### 4. 利用SQL进行增-删-改\n1. SQL-之**更新操作**\n    + 元组新增Insert：新增一个或一些元组到数据库的Table中\n    + 元组更新Update:对某些元组中的某些属性值进行重新设定\n    + 元组删除Delete：删除某些元组\n\n>- SQL-DML既能单一记录操作，也能对记录集合进行批更新操作\n>- SQL-DML之更新操作需要利用前面介绍的子查询(Subquery)的概念，以便处理“一些”、“某些”等\n\n2. SQL-之**INSERT**\n    + 单一元组新增命令形式：插入一条指定元组值的元组\n        - **`insert into 表名 [(列名[,列名]…)] values (值 [,值]…);`**\n    + 批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元组由子查询给出。\n        - **`insert into 表名 [(列名[，列名]…)] 子查询;`**\n        - 示例：`Insert Into St (S#,Sname) Select S#,Sname From Student Where Sname like '%伟';`//将检索到的满足条件的同学新增到该表中\n\n> 注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作。\n\n3. SQL-之**DELETE**\n    + 元组删除Delete命令: 删除满足指定条件的元组\n    + **`Delete From 表名 [ Where 条件表达式];`**\n    + 如果Where条件省略，则删除所有的元组(清空表)。\n    + 示例：`Delete From Student Where S# in ( Select S# From SC Where Score < 60 Group by S# Having Count(*)>= 4);`//删除有四门不及格课程的所有同学\n\n4. SQL-之**UPDATE**\n    + 元组更新Update命令: 用指定要求的值更新指定表中满足指定条件的元组的指定列的值\n    + **`Update 表名 Set 列名=表达式 | (子查询) [[,列名=表达式 | (子查询) ] …] [ Where 条件表达式];`**\n    + 如果Where条件省略，则更新所有的元组。\n    + 示例：`Update Teacher Set Salary=Salary*1.1 Where D# in (Select D# From Dept Where Dname='计算机');`//将所有计算机系的教师工资上调10%\n\n\n<span id=\"id5\"><span>\n### 5. 利用SQL语言修正与撤销数据库\n1. 修正基本表的定义\n    + **`alter table tablename`**\n    + **`[add {colname datatype, …}]`** //增加新列\n    + **`[drop {完整性约束名}]`** //删除完整性约束\n    + **`[modify {colname datatype, …}]`** //修改列定义\n    + 示例：`Alter Table Student Drop Unique(Sname);`删除学生姓名必须取唯一值的约束\n    + 示例：`Alter Table Student Add Saddr char[40],PID char[18];`在学生表Student上增加二列Saddr, PID\n\n2. SQL-DDL之撤销与修改\n    + `drop table 表名;` //撤消基本表\n    + `drop database 数据库名;` //撤消数据库\n\n3. SQL-DDL之数据库指定与关闭命令\n    + 有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能。\n    + `use 数据库名;` //指定当前数据库\n    + `close 数据库名;` //关闭当前数据库\n\n\n\n<span id=\"id6\"><span>\n### 6. SQL Server介绍\nSQL Server 是 Microsoft提供的一款关系数据库管理系统\n1. SQL Server 的系统数据库\n    + Master：是SQL Server中最重要的系统数据库，存储SQL Server中的元数据。\n    + Model：模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础。\n    + Msdb：代理服务数据库，提供一个存储空间。\n    + Tempdb：临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。\n2. SQL Server的数据库\n    + 文件：有三种文件扩展名：.mdf、.ndf、.ldf\n        - 主数据库文件：扩展名为.mdf，是存储数据库的启动信息和部分或全部数据。一个数据库可以有多个数据库文件，但主数据库文件只有一个。\n        - 辅助数据文件：扩展名为.ndf，用于放置主数据库文件中所定义数据库的其它数据，可有多个。在数据庞大时，可以帮助存储数据。\n        - 日志文件：扩展名.ldf。每个数据库至少有一个事务日志文件。\n    + 页面：是SQL Server存储的最小单位。一页为8K或8192字节。\n    + 空间(extent)：是8个连续的页面，即64K数据，是分配数据表存储空间的一种单位\n\n#### 6.1 SQL Server数据库的创建-删除与维护\n1. 创建数据库\n    + 语法形式：Create Database 库名\n    + 可视化操作(查询分析器)：Database(鼠标右键) -> new Database… -> 填写数据库名及配置\n    + 创建数据库的过程就是为数据库设计名称、设计所占用存储空间和存 放文件位置的过程。特别是在网络数据库中，对数据库的设计显得尤为重要。如估计数据可能占用的磁盘空间有多大，日志文件及其他要占用多大空间。\n    + 创建数据库的用户自动成为数据库的拥有者。\n2. 删除数据库\n    + 语法形式：Drop Database 库名\n    + 可视化操作(查询分析器)：数据库名(鼠标右键) -> Delete\n    + 对不再需要的数据库，应删除以释放空间。删除的结果将是所有数据库文件都一并被删除。\n    + 当数据库处于正在使用或正在恢复状态时，不能删除。\n3. 备份数据库\n    + 可视化操作(查询分析器)：数据库名(鼠标右键) -> Tasks -> Back Up…\n    + 备份就是对数据库或事务日志进行备份。SQL的备份是动态的，备份的过程还可以让用户继续改写。只有系统管理员、数据库的拥有者及数据库的备份者才有权限进行数据备份。可以通过企业管理器进行数据库备份。\n        - 完全数据库备份：完全备份数据文件和日志文件。\n        - 差异备份（增量备份）：对最近一次数据库备份以来发生的数据变化进行备份。这要在完全备份的基础上进行。特点是速度快。\n        - 事务日志备份：对数据库发生的事务进行备份。包括从上次进行事务日志备份、差异备份和数据库完全备份之后，所有已经完成的事务。能尽可能的恢复最新的数据库记录。特点是所需磁盘空间小，时间少。\n        - 数据库文件和文件组备份：用在数据库相当大的情况下。\n4. 恢复数据库\n    + 可视化操作(查询分析器)：数据库名(鼠标右键) -> Tasks -> Restore\n    + 数据库的恢复是指将数据库备份加载到系统中的过程。在根据数据库备份文件恢复过程中，系统将自动执行安全性检查、重建数据库结构及完成填写数据库内容。\n    + 数据库的恢复是静态的。所以在恢复前，应将需要恢复的数据库访问属性设为单用户，不要让其他用户操作。\n    + 可以通过企业管理器来完成数据库恢复。\n5. 数据库授权: \n    + 语法形式：grant 权限 on 表名 to 用户名\n    + 权限有：select,update,insert,delete,exec,dri。\n    + 对被授权的用户，要先成为该数据库的使用者，即要把用户加到数据库里,才能授权.\n\n#### 6.2 SQL Server数据表的创建-与增/删/改/查\n1. 创建表\n    + 同一用户不能建立同一个表名的表，同一表名的表可有多个拥有者。但在使用时，需要在这些表上加上所有者的表名。\n    + 用T-SQL语句创建表，语法形式：`CREATE TABLE [数据库名.所有者名.]表名 ({<列名 数据类型>} [缺省值][约束][是否为空] …)`\n        > 注意：T-SQL是SQL Server软件的SQL语言，与标准版有些差异。但标准版SQL，一般情况下SQL Server软件也都支持\n    + 可视化操作(查询分析器)：数据库名 -> Tables -> New Table…\n2. 增加、修改表字段\n    + 语法形式：`ALTER TABLE ADD | ALTER 字段名 <类型>`\n3. 创建、删除与修改约束\n    + 约束是SQL提供自动保持数据库完整性的一种方法，共5种。\n    + 用T-SQL语句建立约束，语法形式：`CONSTRAINT 约束名 约束类型 (列名)`\n        - 约束名：在库中应该唯一，如不指定，系统会给出\n        - 约束类型 (5种)：\n            * primary key constraint (主键值)\n            * unique constraint (唯一性)\n            * check constraint (检查性)\n            * default constraint (默认)\n            * foreign key constraint (外部键)\n        - 列名：要约束的字段名\n    + 示例:`Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1), T# char(3) ) constraint pk primary key(C# ));`\n\n\n\n<span id=\"id7\"><span>\n### 7. SQL语言-子查询\n- 子查询：出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。\n- 三种类型的子查询：(NOT) IN-子查询；θ-Some/θ-All子查询；(NOT) EXISTS子查询\n\n#### 7.1 (NOT) IN子查询\n1. 基本语法：`表达式 [not] in (子查询)`\n    + 语法中，表达式的最简单形式就是列名或常数。\n    + 语义：判断某一表达式的值是否在子查询的结果中。\n    + 示例：\n        - `Select * From Student Where Sname in ('张三', '王三');`//列出张三、王三同学的所有信息\n        - `Select S#, Sname From Student Where S# in (Select S# From SC Where C#='001');`//列出选修了001号课程的学生的学号和姓名\n3. 非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询前面的子查询示例都是非相关子查询\n4. 相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询\n5. 外层向内层传递的参量需要使用外层的表名或表别名来限定\n    + 示例：`Select Sname From Student Stud Where S# in ( Select S# From SC Where S# = Stud.S# and C#='001');`//求学过001号课程的同学的姓名\n\n> 注意：相关子查询只能由外层向内层传递参数，而不能反之；这也称为变量的作用域原则。\n\n\n#### 7.2 θ-Some/θ-All子查询\n1. 基本语法：`表达式 θ some (子查询)` / `表达式 θ all (子查询)`\n    + 语法中，θ是比较运算符：`<, >, >=, <=, =, <>`。\n    + 语义：将表达式的值与子查询的结果进行比较：\n        - 如果表达式的值至少与子查询结果的某一个值相比较满足 关系，则`表达式 θ some (子查询)`的结果便为真\n        - 如果表达式的值与子查询结果的所有值相比较都满足 关系，则`表达式 θ all (子查询)`的结果便为真\n    + 示例：\n        - `Select Tname From Teacher Where Salary <= all ( Select Salary From Teacher);`//找出工资最低的教师姓名\n        - `Select S# From SC Where C# = “001” and Score < some ( Select Score From SC Where C#='001');`//找出001号课成绩不是最高的所有学生的学号\n\n> 在SQL标准中，也有θ-Any谓词，但由于其语义的模糊性：any,“任一”是指所有呢？还是指某一个？不清楚，所以被θ-Some替代以求更明晰。\n\n2. 等价性变换需要注意\n    + `表达式 = some (子查询)`和`表达式 in (子查询)`含义**相同**\n    + `表达式 <> some (子查询)`和`表达式 not in (子查询)`含义**不同**\n    + `表达式 <> all (子查询)`和`表达式 not in (子查询)`含义**相同**\n\n\n#### 7.3 (NOT) EXISTS子查询\n1. 基本语法：`[not] Exists [not] Exists (子查询)`\n    + 语义：子查询结果中有无元组存在\n\n``` sql\n--示例：检索选修了赵三老师主讲课程的所有同学的姓名\nSelect DISTINCT Sname From Student\n    Where exists ( Select * From SC, Course, Teacher\n        Where SC.C#=Course.C# and SC. S#=Student.S#\n        and Course.T# = Teacher.T# and Tname='赵三');\n\n--示例：检索学过001号教师主讲的所有课程的所有同学的姓名\nSelect Sname From Student\n    Where not exists //不存在\n        ( Select * From Course //有一门001教师主讲课程\n        Where Course.T# = ‘001’ and not exists //该同学没学过\n            ( Select * From SC\n            Where S# = Student.S# and C# = Course.C#));\n--上述语句的意思：不存在有一门001号教师主讲的课程该同学没学过\n```\n\n\n\n<span id=\"id8\"><span>\n### 8. SQL语言-结果计算与聚集计算\n#### 8.1 结果计算\nSelect-From-Where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表明在投影的同时直接进行一些运算\n+ `Select Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where Where 检索条件 ];`\n    - expr可以是常量、列名、或由常量、列名、特殊函数及算术运算符构成的算术运算式。特殊函数的使用需结合各自DBMS的说明书\n    - agfunc()是一些聚集函数\n\n``` sql\n--示例：求有差额(差额>0)的任意两位教师的薪水差额\nSelect T1.Tname as TR1, T2.Tname as TR2, T1.Salary – T2.Salary\n    From Teacher T1, Teacher T2\n    Where T1.Salary > T2.Salary;\n```\n\n#### 8.2 聚集函数\nSQL提供了五个作用在简单列值集合上的内置聚集函数agfunc,分别是：COUNT、SUM、AVG、MAX、MIN\n\n|聚合函数 |支持的数据类型|描述|\n|--------|------------|---|\n|count() |任何类型/*   |计算结果集中的总行数|\n|sum()   |Numeric     |计算指定列中所有非空值的总和|\n|avg()   |numeric     |计算指定列中所有非空值的平均值|\n|max()   |char/numeric|返回指定列中最大值|\n|min()   |char/numeric|返回指定列中最小值|\n\n``` sql\n--示例：求教师的工资总额\nSelect Sum(Salary) From Teacher;\n--示例：求计算机系教师的工资总额\nSelect Sum(Salary) From Teacher T, Dept\n    Where Dept.Dname = ‘计算机’ and Dept.D# = T.D#;\n--示例：求数据库课程的平均成绩\nSelect AVG(Score) From Course C, SC\n    Where C.Cname = ‘数据库’ and C.C# = SC.C#;\n```\n\n\n<span id=\"id9\"><span>\n### 9. SQL语言-分组查询与分组过滤\n#### 9.1 分组查询\n分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。\n1. 分组的基本语法：\n``` sql\nSelect Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]\n    From 表名1 [, 表名2 … ]\n    [ Where Where 检索条件 ]\n    [ Group by Group by 分组条件 ] ;\n```\n\n2. 分组条件可以是：`列名1, 列名2, …`\n3. 示例： 求每一个学生的平均成绩\n    + `Select S#, AVG(Score) From SC Group by S#;`\n\n#### 9.2 分组过滤\n聚集函数是不允许用于Where子句中的：Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤\n* 分组过滤：若要对集合(即分组)进行条件过滤，即满足条件的集合/分组留下，不满足条件的集合/分组剔除。\n* Having子句，又称分组过滤子句。需要有Groupby子句支持，换句话说，没有Groupby子句，便不能有Having子句。\n\n1. 基本语法：\n``` sql\nSelect Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]\n    From 表名1 [, 表名2 … ]\n    [ Where Where 检索条件 ]\n    [ Group by Group by 分组条件 [ Having Having 分组过滤条件] ] ;\n```\n\n2. 示例：求不及格课程超过两门的同学的学号\n    + `Select S# From SC Where Score<60 Group by S# Having Count(*)>2;` \n\n#### 9.3 where子句与having子句的区别\n1. 聚合函数是比较where、having 的关键。在from后面的执行顺序：\n    + `where -> 聚合函数(sum,min,max,avg,count) ->having`\n2. 列出group by来比较二者:\n    + where子句：是在分组之前使用，表示从所有数据中筛选出部分数据，以完成分组的要求，在where子句中不允许使用统计函数，没有group by子句也可以使用。\n    + having子句：是在分组之后使用的，表示对分组统计后的数据执行再次过滤，可以使用统计函数，有group by子句之后才可以出现having子句。\n\n> 注意事项 ： \n> 1. where 后不能跟聚合函数，因为where执行顺序大于聚合函数。 \n> 2. where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。 \n> 3. having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。\n\n\n\n<span id=\"id10\"><span>\n### 10. SQL语言实现关系代数操作\nSQL语言：并运算UNION, 交运算INTERSECT, 差运算EXCEPT。\n+ 基本语法形式：\n    - `子查询 {Union [ALL] | Intersect [ALL] | Except [ALL] 子查询}`\n+ 通常情况下自动删除重复元组：不带ALL。若要保留重复的元组，则要带ALL。\n    * 假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在：\n        - 子查询1 Union ALL 子查询2 ，出现m + n次\n        - 子查询1 Intersect ALL 子查询2 ，出现min(m,n)次\n        - 子查询1 Except ALL 子查询2 ，出现max(0, m – n)次\n\n> UNION运算符是Entry-SQL92的一部分, INTERSECT、EXCEPT运算符是Full-SQL92的一部分,它们都是Core-SQL99的一部分，但**有些DBMS并不支持**这些运算，使用时要注意。\n\n\n#### 10.1 SQL并运算(UNION)\n1. 示例：已知两个表\n    * Customers(Cid, Cname, City, Discnt)\n    * Agents(Aid, Aname, City, Percent)\n2. 求客户所在的或者代理商所在的城市\n``` sql\nSelect City From Customers\nUNION\nSelect City From Agents;\n```\n\n\n#### 10.2 SQL交运算(INTERSECT)\n1. 示例：求既学过002号课，又学过003号课的同学学号\n``` sql\nSelect S# From SC Where C# = ‘002’\nINTERSECT\nSelect S# From SC Where C# = ‘003’;\n```\n2. 上述语句也可采用如下不用INTERSECT的方式来进行\n    + `Select S# From SC Where C# = ‘002’ and S# IN (Select S# From SC Where C# = ‘003’);`\n\n3. 交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也可以用其他方式表达同样的查询需求。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。\n\n\n#### 10.3 SQL差运算(EXCEPT)\n1. 示例： 假定所有学生都有选课，求没学过002号课程的学生学号\n``` sql\nSelect DISTINCT S# From SC\nEXCEPT\nSelect S# From SC Where C# = ‘002’;\n```\n\n2. 上述语句也可采用如下不用INTERSECT的方式来进行\n``` sql\nSelect DISTINCT S# From SC SC1\n    Where not exists ( Select * From SC\n        Where C# = ‘002’ and S# = SC1.S#);\n```\n\n3. 差运算符Except也没有增强SQL的表达能力，没有Except， SQL也可以用其他方式表达同样的查询需求。只是有了Except更容易表达一些，但增加了SQL语言的不唯一性。\n\n\n#### 10.4 空值的处理\n空值是其值不知道、不确定、不存在的值；数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等\n1. 在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来标记，使用特殊的空值检测函数来获得某列的值是否为空值。\n2. 空值检测：\n    + `is [not ] null` //测试指定列的值是否为空值\n3. 示例：找出年龄值为空的学生姓名\n    + `Select Sname From Student Where Sage is null;`\n4. 现行DBMS的空值处理小结\n    + 除is[not]null之外，空值不满足任何查找条件\n    + 如果null参与算术运算，则该算术表达式的值为null\n    + 如果null参与比较运算，则结果可视为false。在SQL-92中可看成unknown\n    + 如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null\n\n\n#### 10.5 内连接、外连接\n1. 标准SQL语言中连接运算通常为：\n    + `Select Select 列名[[,列名]… ] From 表名1,表名2,… Where 检索条件;`\n    + 即相当于采用`Π[列名,…,列名](σ 检索条件(表名1 × 表名2 × …))`。\n2. SQL的高级语法中引入了内连接与外连接运算，具体形式：\n``` sql\nSelect Select 列名 [ [, 列名] … ]\n    From 表名1 [NATURAL]\n    [ INNER | { LEFT | RIGHT | FULL} [OUTER]] JOIN 表名2\n    { ON 连接条件 | Using (Colname {, Colname …}) }\n    [ Where Where 检索条件 ] … ;\n```\n3. 由 **连接类型** 和 **连接条件** 构成连接运算。\n    + **`Natural`**：出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次\n    + **`Inner Join`**: 即关系代数中的θ-连接运算\n    + **`Left Outer Join, Right Outer Join, Full Outer Join`**: 即关系代数中的外连接运算\n    + **`on <连接条件>`**：出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次\n    + **`using (Col1, Col2, …, Coln)`**：Col是两个连接关系的公共属性的子集，元组在(Col1,Col2,…,Coln)上取值相等，且(Col1,Col2,…,Coln)只出现一次\n4. 示例:\n\n``` sql\n-- (Inner Join)求所有教师的任课情况并按教师号排序(没有任课的教师也需列在表中)\nSelect Teacher.T#, Tname, Cname\n    From Teacher Inner Join Course\n        ON Teacher.T# = Course.T#\n    Order by Teacher.T# ASC;\n\n--(Outer Join)求所有教师的任课情况(没有任课的教师也需列在表中)\nSelect Teacher. T#, Tname, Cname\n    From Teacher Left Outer Join Course\n        ON Teacher.T# = Course.T#\n    Order by Teacher.T# ASC ;\n```\n\n\n\n<span id=\"id11\"><span>\n### 11. SQL语言之视图及其应用\n1. 数据库的三级模式两层映像\n    * 三级模式：数据库系统是由外模式、模式(概念模式)和内模式三级构成\n    * 应用--> **外模式**(多个) --> **概念模式**(一个) --> **内模式**(一个) --> 数据库\n    * 两层映像：`E-C`映像(外模式->概念模式)、`C-I`映像(概念模式->内模式)。\n2. 对应概念模式的数据在SQL中被称为**基本表(Table)**,而对应外模式的数据称为**视图(View)**。**视图不仅包含外模式，而且包含其E-C映像**。\n3. **基本表**是实际存储于存储文件中的表，基本表中的**数据是需要存储的**\n4. **视图**在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，其**数据并不存储**，而是在运行过程中动态产生与维护的\n5. 对视图数据的更改最终要反映在对基本表的更改上。\n\n#### 11.1 视图的定义\n视图需要“先定义，再使用”；定义视图，有时可方便用户进行检索操作。\n1. 定义视图: `create view view_name [(列名[列名] …)] as 子查询 [with check option]`\n    + 如果视图的属性名缺省，则默认为子查询结果中的属性名；也可以显式指明其所拥有的列名。\n    + with checkoption指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式\n2. 示例：定义一个视图 CompStud 为计算机系的学生，通过该视图可以将Student表中其他系的学生屏蔽掉\n``` sql\nCreate View CompStud AS\n    (Select * From Student\n        Where D# in (Select D# From Dept\n            Where Dname = ‘计算机’));\n```\n\n#### 11.2 视图的使用\n使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用\n+ 示例：检索计算机系的所有学生，我们可使用CompStud\n    - `Select * From CompStud;`\n+ 示例：检索计算机系的年龄小于20的所有学生，我们可使用CompStud\n    - `Select * From CompStud Where Sage<20;`\n\n#### 11.3 视图的更新\nSQL视图更新：是比较复杂的问题，因视图不保存数据，对视图的更新最终要反映到对基本表的更新上，而有时，视图定义的映射不是可逆的。\n1. SQL视图更新的可执行性\n    + 如果视图的select目标列包含聚集函数，则不能更新\n    + 如果视图的select子句使用了unique或distinct，则不能更新\n    + 如果视图中包括了groupby子句，则不能更新\n    + 如果视图中包括经算术表达式计算出来的列，则不能更新\n    + 如果视图是由单个表的列构成，但并没有包括主键，则不能更新\n2. 对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主键，则可以更新\n3. 可更新SQL视图示例：\n\n``` sql\n-- 定义视图\ncreate view CStud(S#, Sname, Sclass)\nas ( select S#, Sname, Sclass from Student where D# ='03');\n-- 更新视图\nInsert into CStud Values ('98030104', '张三丰', '980301');\n-- 更新视图 将转换为 更新基本表\ninsert into Student values ('98030104', '张三丰', Null, Null, '03', '980301')\n```\n\n#### 11.4 视图的撤销\n已经定义的视图也可以撤消\n* 撤消视图：`Drop View view_name`\n\n不仅视图可以撤消，基本表、数据库等都可以撤消\n* 撤消基本表：`Drop Table 表名`\n\n\n<span id=\"id12\"><span>\n### 12. 数据库完整性\n数据库完整性(DB Integrity)是指：DBMS应保证的DB的一种特性--在任何情况下的正确性、有效性和一致性\n* 广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等\n* 狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题。\n\n#### 12.1 基本概念\n关系模型中有完整性要求：实体完整性、参照完整性、用户自定义完整性\n1. 数据库完整性管理的作用\n    * 防止和避免数据库中不合理数据的出现\n    * DBMS应尽可能地自动防止DB中语义不合理现象\n    * 如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担\n2. DBMS怎样自动保证完整性：\n    * DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义)\n    * 当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性\n3. **完整性约束条件**(或称完整性约束规则)的一般形式：Integrity Constraint::=(O,P,A,R)\n    + O：数据集合：约束的对象(列、多列(元组)、元组集合)\n    + P：谓词条件：需要定义什么样的约束\n    + A：触发条件：默认更新时检查\n    + R：响应动作：默认拒绝\n\n#### 12.2 数据库完整性的分类\n1. 按约束对象分类:\n    - 域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的\n    - 关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断\n\n2. 按约束来源分类:\n    - 结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等；\n    - 内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等。\n\n3. 按约束状态分类:\n    - 静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。\n    - 动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。\n\n\n\n<span id=\"id13\"><span>\n### 13. 数据库的静态完整性(约束)\n1. SQL语言支持的约束类别：\n    + 静态约束\n        - 列完整性—域完整性约束\n        - 表完整性--关系完整性约束\n    + 动态约束\n        - 触发器\n\n2. CreateTable有三种功能：定义关系模式、定义完整性约束 和定义物理存储特性\n    + 定义完整性约束条件：列完整性、表完整性\n\n3. 列约束：一种**域约束类型**，对单一列的值进行约束\n``` sql\n{ NOT NULL |                  //列值非空\n[ CONSTRAINT constraintname ] //为约束命名，便于以后撤消\n{ UNIQUE                      //列值是唯一\n| PRIMARY KEY                 //列为主键\n| CHECK (search_cond)         //列值满足条件,条件只能使用列当前值\n| REFERENCES tablename [(colname) ]\n[ON DELETE { CASCADE | SET NULL } ] } } \n```\n\n4. 表约束：一种**关系约束类型**，对多列或元组的值进行约束\n``` sql\n[ CONSTRAINT constraintname ]       //为约束命名，便于以后撤消\n{ UNIQUE (colname {,colname…})      //几列值组合在一起是唯一\n| PRIMARY KEY (colname {,colname…}) //几列联合为主键\n| CHECK (search_condition)          //元组多列值共同满足条件\n                                    //条件中只能使用同一元组的不同列当前值\n| FOREIGN KEY (colname {,colname…})\nREFERENCES tablename [(colname {,colname…})]//引用另一表tablename的若干列的值作为外键\n```\n> check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。\n\n5. Create Table中定义的表约束或列约束可以在以后根据需要进行撤消或追加。撤消或追加约束的语句是 Alter Table(不同系统可能有差异)\n    + 示例：撤消SC表的ctscore约束(由此可见，未命名的约束是不能撤消)\n        - `Alter Table SC DROP CONSTRAINT ctscore;`\n    + 有些DBMS支持独立的追加约束,注意书写格式可能有些差异\n        - 示例：`Alter Table SC Add Constraint nctscore check (Score>=0.0 and Score<=150.0));`\n\n6. 现约束的方法-断言ASSERTION\n    + 一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件\n    + 表约束和列约束就是一些特殊的断言\n    + SQL还提供了复杂条件表达的断言。其语法形式为：\n        - `CREATE ASSERTION <assertion-name> CHECK <predicate>`\n    + 当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是否违反该断言。\n\n``` sql\n-- 示例: “每个分行的贷款总量必须小于该分行所有账户的余额总和”\ncreate assertion sum_constraint check\n    (not exists (select * from branch\n    where (select sum(amount ) from loan\n        where loan.branch_name = branch.branch_name )\n    >= (select sum (balance ) from account\n        where account.branch_name = branch.branch_name )))\n-- 数据表：\naccount(branch_name, account_number,…, balance) //分行，账户及其余额\nloan(branch_name , loan_number, amount,) //分行的每一笔贷款\nbranch(branch_name, … ) //分行\n```\n> 断言测试增加了数据库维护的负担，要小心使用复杂的断言。\n\n\n<span id=\"id14\"><span>\n### 14. 数据库的动态完整性(触发器)\n实现数据库动态完整的方法—触发器Trigger\n1. 触发器Trigger\n    + Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger\n    + Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。\n\n2. 基本语法\n``` sql\nCREATE TRIGGER trigger_name BEFORE | AFTER\n    { INSERT | DELETE | UPDATE [OF colname {, colname...}] }\n    ON tablename [REFERENCING corr_name_def {, corr_name_def...} ]\n    [FOR EACH ROW | FOR EACH STATEMENT]\n                //对更新操作的每一条结果(前者)，或整个更新操作完成(后者)\n    [WHEN (search_condition)]           //检查条件，如满足执行下述程序\n    { statement         //单行程序直接书写，多行程序要用下行方式\n    | BEGIN ATOMIC statement; { statement;...} END }\n```\n\n3. 触发器Trigger意义：\n    + 当某一事件发生时(Before|After),对该事件产生的结果(或是每一元组，或是整个操作的所有元组), 检查条件`search_condition`,如果满足条件，则执行后面的程序段。条件或程序段中引用的变量可用`corr_name_def`来限定。\n\n4. 事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}\n    + 当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后After触发\n    + 操作发生，执行触发器操作需处理两组值：更新前的值和更新后的值，这两个值由`corr_name_def`的使用来区分\n\n5. `corr_name_def`的定义\n``` sql\n{ OLD [ROW] [AS] old_row_corr_name //更新前的旧元组命别名为\n| NEW [ROW] [AS] new_row_corr_name //更新后的新元组命别名为\n| OLD TABLE [AS] old_table_corr_name //更新前的旧Table命别名为\n| NEW TABLE [AS] new_table_corr_name //更新后的新Table命别名为\n}\n```\n> `corr_name_def`将在检测条件或后面的动作程序段中被引用处理\n\n6. 示例1: 设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降\n``` sql\ncreate trigger teacher_chgsal before update of salary\n    on teacher\n    referencing new x, old y\n    for each row when (x.salary < y.salary)\nbegin\n    raise_application_error(-20003, 'invalid salary on update');\n    //此条语句为Oracle的错误处理函数\nend;\n```\n\n7. 示例2: 假设student(S#, Sname, SumCourse), SumCourse为该同学已学习课程的门数，初始值为0，以后每选修一门都要对其增1 。设计一个触发器自动完成上述功能。\n``` sql\ncreate trigger sumc after insert on sc\n    referencing new row newi\n    for each row\nbegin\n    update student set SumCourse = SumCourse + 1\n    where S# = :newi.S# ;\nend;\n```\n\n8. 示例3：假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。设计一个触发器完成上述功能\n``` sql\ncreate trigger delS# after delete on Student\n    referencing old oldi\n    for each row\nbegin\n    delete sc where S# = :oldi.S# ;\nend; \n```\n\n\n<span id=\"id15\"><span>\n### 15. 数据库索引\n索引是对数据库表中一列或多列的值进行排序的一种**数据结构**（最常见的是B-Tree）\n1. 索引的作用\n    1. 快速取数据；\n    2. 保证数据记录的唯一性；\n    3. 实现表与表之间的参照完整性；\n    4. 在使用ORDER by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。\n2. 创建索引：`CREATE INDEX  索引名称  on 表名(字段名);`\n3. 删除索引：`DROP INDEX 索引名称`\n4. 索引注意事项：\n    1. 查询时减少使用`*`返回全部列，不要返回不需要的列\n    2. where表达式子句包含索引的表达式置前\n    3. 避免在Order by中使用表达式\n    4. 索引技术是数据库自动使用，一个表格只存在一个索引就够了\n5. 缺点\n    1. 索引的缺点是创建和维护索引需要耗费时间和空间\n    2. 索引可以提高查询速度，会减慢写入速度\n    3. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n\n#### 15.1 索引主要种类\n根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。\n1. 唯一索引\n    + 唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。\n2. 主键索引\n    + 数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。\n3. 聚集索引\n    + 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。\n4. 索引列\n    + 可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。\n\n\n\n<span id=\"id16\"><span>\n### 16. 数据库序列\n序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。创建序列需要`CREATE SEQUENCE`系统权限。\n#### 16.1 Oracle中的序列（Sequence）\n1. 创建序列\n``` sql\ncreate sequence 序列名 \n    [increment by n]   --每次增加n个，默认为1\n    [start with n]     --起始值n，默认为1\n    [{maxvalue n | nomaxvalue}]  --最大值设置，递增默认10的27次方，递减默认-1\n    [{minvalue n | nominvalue}]  --最小值设置，递增默认1，递减默认-10的26次方\n    [{cycle | nocycle}]   --是否循环\n    [{cache n | nocache}] --是否对序列进行内存缓冲，默认为20\n```\n\n2. 查询序列\n    + `NEXTVAL`:返回序列中下一个有效的值，任何用户都可以引用。\n    + `CURRVAL`:中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。\n\n``` sql\n--查询下一个将要使用的序列\nselect 序列名.nextval from dual\n--查询当前序列\nselect 序列名.currval from dual \n```\n>- Oracle将sequence的定义存储在数据字典之中。\n>- Sequence是独立于事务的，就是说序列的增加不需要等待事务的完成，也就是说序列是异步于事务而增长的。这说明，你访问不到别的用户使用该sequence产生的值，也就是说你只能访问到你当前产生的值，即使其他用户已经增加了sequence的值；还说明如果事务回滚，sequence不会回滚，它所发生的改变是一维的。\n\n3. 删除序列：`Drop sequence 序列名`\n4. 更改序列：`Alter sequence 序列名 [其余参数同创建序列]`\n5. 使用序列示例：\n\n``` sql\n-- 1.直接使用\ninsert into person (id, name, password) values (序列名.nextval, '张三', '123')\n\n-- 2.也可以通过建立触发器，当有数据插入表person时，使用oracle序列为其去的递增的主键值\n-- 2.1创建触发器\ncreate or replace trigger 触发器名 before insert on person\nfor each row\nbegin\n    select 序列名.nextval into :new.id from dual;\nend;\n-- 2.2插入数据\ninsert into person ( username, age, password) values ('张三', 20, 'zhang123')\n```\n\n6. 注意点：\n    + 一个序列可以被多张别使用，不过一般建议为每个表建立单独的序列。\n    + 当使用到序列的事务发生回滚。会造成序列号不连续。在用生成的序列值作为编号做插入数据库操作时，可能遇到事务提交失败，从而导致序号不连续。\n    + 大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 n个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数最好不要设置过大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入n个。这种情况也能会在数据库关闭时也会导致序号不连续。\n\n\n#### 16.2 Mysql中的序列（AUTO_INCREMENT）\nMySQL中最简单使用序列的方法就是使用`AUTO_INCREMENT`来定义列。\n1. orale没有类似mysql的AUTO_INCREMENT这样的自增长字段，实现插入一条记录，自动增加1.oracle是通过sequence（序列）来完成的。\n2. 首先mysql的自增长“序列”和序列是两回事，mysql本身不提供序列机制。\n3. mysql的AUTO_INCREMENT可以设置起始值，但是不能设置步长，其步长默认就是1.\n4. mysql一个表只能有一个自增长字段。自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。并且只能是数字型。\n\n\n\n\n<span id=\"id17\"><span>\n### 17. 数据库安全性\n数据库安全性是指DBMS应该保证的数据库的一种特性(机制或手段)：免受非法、非授权用户的使用、泄漏、更改或破坏\n1. 数据库安全性管理涉及许多方面\n    1. 社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法\n    2. 公共政策/制度方面：例如，政府或组织的信息公开或非公开制度\n    3. 安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略)\n    4. 数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)\n    5. 数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制\n2. DBMS的安全机制\n    1. **自主安全性机制**：存取控制(AccessControl)\n        + 通过权限在用户之间的传递，使用户自主管理数据库安全性\n    2. **强制安全性机制**：\n        + 通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据\n    3. 推断控制机制：\n        + 防止通过历史信息，推断出不该被其知道的信息；\n        + 防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要\n    4. 数据加密存储机制：\n        + 通过加密、解密保护数据，密钥、加密/解密方法与传输\n3. DBA的责任和义务\n    + 熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略\n    + 规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应，\n    + **划分好数据的安全级别以及用户的安全级别**\n    + 实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等\n\n\n\n<span id=\"id18\"><span>\n### 18. 数据库自主安全性机制\n+ 通常情况下，自主安全性是通过授权机制来实现的。\n+ 用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。\n    + 授权者：决定用户权利的人\n    + 授权：授予用户访问的权利\n\n1. DBMS自动实现自主安全性：\n    + DBMS允许用户定义一些安全性控制规则(用SQL-DCL来定义)\n    + 当有DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许访问\n2. DBMS将权利和用户(账户)结合在一起，形成一个访问规则表，依据该规则表可以实现对数据库的安全性控制\n    + `AccessRule ::=(S, O, t, P)`\n        - S: 请求主体(用户)\n        - O: 访问对象\n        - t: 访问权利\n        - P: 谓词\n    + {AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利;\n    + 用户多时，可以按用户组建立访问规则\n    + 访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库\n    + 权利：包括创建、增、删、改、查等\n    + 谓词：拥有权利需满足的条件\n3. **示例**：员工管理数据库的安全性控制示例`Employee(P#,Pname,Page,Psex,Psalary,D#,HEAD)`\n    + 示例要求：\n        - 员工管理人员：能访问该数据库的所有内容，便于维护员工信息\n        - 收发人员：访问该数据库以确认某员工是哪一个部门的，便于收发工作，只能访问基本信息，其他信息不允许其访问\n        - 每个员工：允许其访问关于自己的记录，以便查询自己的工资情况，但不能修改\n        - 部门领导：能够查询其所领导部门人员的所有情况\n        - 高层领导：能访问该数据库的所有内容，但只能读\n    + 两种控制示例\n        - 按名控制安全性：存储矩阵\n        - 按内容控制安全性：视图\n    + 视图是安全性控制的重要手段\n    + 通过视图可以限制用户对关系中某些数据项的存取,例如：\n        - 视图1：CreateEmpV1as select*fromEmployee\n        - 视图2：CreateEmpV2as selectPname,D#fromEmployee\n    + 通过视图可将数据访问对象与谓词结合起来，限制用户对关系中某些元组的存取，例如：\n        - 视图1： CreateEmpV3asselect*fromEmployeewhereP#=:UserId\n        - 视图2： CreateEmpV4asselect*fromEmployeewhereHead=:UserId\n    + 用户定义视图后，视图便成为一新的数据对象，参与到存储矩阵与能力表中进行描述\n\n#### 18.1 SQL语言的用户与权利\n1. SQL语言包含了DDL,DML和DCL。数据库安全性控制是属于DCL范畴\n2. 授权机制---自主安全性；视图的运用\n3. 关系级别(普通用户) <-- 账户级别(程序员用户) <-- 超级用户(DBA) \n    + (级别1)Select : 读(读DB, Table, Record, Attribute, … )\n    + (级别2)Modify : 更新\n        - Insert : 插入(插入新元组, … )\n        - Update : 更新(更新元组中的某些值, …)\n        - Delete : 删除(删除元组, …)\n    + (级别3)Create : 创建(创建表空间、模式、表、索引、视图等)\n        - Create : 创建\n        - Alter : 更新\n        - Drop : 删除\n4. 级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为账户级别的权利，而将级别1和2称为关系级别的权利。\n5. 授权命令`GRANT`\n```  sql\nGRANT {all PRIVILEGES | privilege {,privilege…}}\n    ON [TABLE] tablename | viewname\n    TO {public | user-id {, user-id…}}\n    [WITH GRANT OPTION];\n```\n    + user-id ，某一个用户账户，由DBA创建的合法账户\n    + public, 允许所有有效用户使用授予的权利\n    + privilege是下面的权利\n        - SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES\n    + WITH GRANT OPTION选项是允许被授权者传播这些权利\n\n6. SQL-DCL的控制安全性-授权示例:\n    + 假定高级领导为Emp0001, 部门领导为Emp0021, 员工管理员为Emp2001,收发员为Emp5001(均为UserId, 也即员工的P#)\n        - Grant All Priviledges ON Employee TO Emp2001;\n        - Grant SELECT ON EmpV2 TO Emp5001;\n        - Grant SELECT ON EmpV3 TO public;\n        - Grant SELECT ON EmpV4 TO Emp0021;\n    + 授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别)\n    + 授权者授予的权利必须是授权者已经拥有的权利\n\n7. 收回授权命令`REVOKE`\n``` sql\nREVOKE {all privilEges | priv {, priv…} } \n    ON tablename | viewname\n    FROM {public | user {, user…} }; \n```\n    + 示例: `revoke select on employee from UserB;`\n\n\n#### 18.2 自主安全性的授权过程及其问题\n##### 18.2.1 授权过程:\n1. 第一步：DBA创建DB, 并为每一个用户创建一个账户\n    + 假定建立了五个用户：UserA, UserB, UserC, UserD, UserE\n2. 第二步：DBA授予某用户账户级别的权利\n    + 假定授予UserA\n3. 第三步：具有账户级别的用户可以创建基本表或视图, 他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问 权利\n    + 假定UserA创建了Employee, 则UserA就是Employee表的属主账户\n4. 第四步：拥有属主账户的用户可以将其中的一部分权利授予另外的用户，该用户也可将权利进一步授给其他的用户…\n    + 假定UserA将读权限授予UserB, 而userB又将其拥有的权限授予UserC,如此将权利不断传递下去。\n\n* 注意授权的传播范围\n    + 传播范围包括两个方面：水平传播数量和垂直传播数量\n        - 水平传播数量是授权者的再授权用户数目(树的广度)\n        - 垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权者, …传播的深度(树的深度)\n    + 有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。\n    + 当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回\n    + 如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当UserB收回时，其还将保持UserE赋予其的权利。\n\n##### 18.2.2 强制安全性机制\n1. 强制安全性机制\n    * 强制安全性通过对数据对象进行安全性分级\n        + 绝密(Top Secret), 机密(Secret), 可信(Confidential) 和 无分类(Unclassified)\n    * 同时对用户也进行上述的安全性分级\n    * 从而强制实现不同级别用户访问不同级别数据的一种机制\n2. 强制安全性机制的实现\n    * DBMS引入强制安全性机制, 可以通过扩展关系模式来实现\n        + 关系模式: R(A1: D1, A2: D2, …, An:Dn)\n        + 对属性和元组引入安全性分级特性或称分类特性\n            - R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性\n    * 这样, 关系中的每个元组, 都将扩展为带有安全分级的元组\n    * 强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。\n\n\n","source":"_posts/【数据库】数据库语言SQL.md","raw":"---\ntitle: 【数据库】数据库语言SQL\ndate: 2019-07-01 19:36:31\ntags: [数据库, 后端开发]\ncategories: 数据库\n---\n\n### SQL语言概述\n**结构化查询语言**(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。\n+ SQL语言是集DDL、DML和DCL于一体的数据库语言<!-- more -->\n    1. **DDL语句**引导词：Create(建立),Alter(修改),Drop(撤消)\n        - 模式的定义和删除，包括定义Database,Table,View,Index,完整性约束条件等，也包括定义对象(RowType行对象,Type列对象)\n    2. **DML语句**引导词：Insert ,Delete, Update, Select\n        - 各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入\n        - 各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等\n        - 各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等\n    3. **DCL语句**引导词：Grant,Revoke\n        - 安全性控制：授权和撤消授权\n\n\n#### 目录：\n1. [利用SQL建立数据库](#id1)\n2. [利用SQL简单查询](#id2)\n3. [利用SQL多表联合查询](#id3)\n4. [利用SQL进行增-删-改](#id4)\n5. [利用SQL语言修正与撤销数据库](#id5)\n6. [SQL Server介绍](#id6)\n7. [SQL语言-子查询](#id7)\n8. [SQL语言-结果计算与聚集计算](#id8)\n9. [SQL语言-分组查询与分组过滤](#id9)\n10. [SQL语言实现关系代数操作](#id10)\n11. [SQL语言之视图及其应用](#id11)\n12. [数据库完整性](#id12)\n13. [数据库的静态完整性(约束)](#id13)\n14. [数据库的动态完整性(触发器)](#id14)\n15. [数据库索引](#id15)\n16. [数据库序列](#id16)\n17. [数据库安全性](#id17)\n18. [数据库自主安全性机制](#id18)\n\n\n<span id=\"id1\"><span>\n### 1. 利用SQL建立数据库\nDDL：数据定义语言（Data Definition Language)，\nDDL通常由**DBA(数据库管理员)**来使用，也有经DBA授权后由应用程序员来使用\n1. 创建数据库(DB)：**Create Database**\n    + 数据库(Database)是若干具有相互关联关系的Table/Relation的集合\n    + 简单语法形式：`create database database 数据库名;`\n2. 创建DB中的Table(定义关系模式)：**Create Table**\n    + `Create table 表名(列名 数据类型 [Primary key|Unique] [Not null][,列名 数据类型 [Not null], …]);`\n        - `[]`表示其括起的内容可以省略，`|`表示其隔开的两项可取其一\n        - `Primary key`: 主键约束。每个表只能创建一个主键约束\n        - `Unique`: 唯一性约束(即候选键)。可以有多个唯一性约束\n        - `Not null`: 非空约束。\n3. **数据类型**（SQL-92标准）\n    + `char(n)`:固定长度的字符串\n    + `varchar(n)`:可变长字符串\n    + `int`:整数 //有时不同系统也写作integer\n    + `numeric(p，q)`:固定精度数字，小数点左边p位，右边(p-q)位\n    + `real`:浮点精度数字 //有时不同系统也写作`float(n)`，小数点后保留n位\n    + `date`:日期 (如 2003-09-12)\n    + `time`:时间 (如 23:15:003)\n> 注意: 现行商用DBMS的数据类型有时有些差异\n\n\n<span id=\"id2\"><span>\n### 2. 利用SQL简单查询\nDML：数据操纵语言（Data Manipulation Language)，\nDML通常由**用户或应用程序员**使用，访问经授权的数据库\n1. 向Table中添加数据(追加元组)：**Insert into**\n    + **`insert into insert into 表名[(列名[, 列名] …] values (值[,值], …);`**\n        - values值的排列，须与列名排列一致\n        - 若所有列名省略，则values值的排列须与该表存储中的列名排列一致\n\n2. 单表查询**Select**\n    + **`Select Select 列名[[,列名] …] From 表名[Where 检索条件];`**\n        - 语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示。\n        - 相当于：`Π[列名,...,列名](σ检索条件(表名))`\n    + Select语句中的select … , from… , where…, 等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。\n\n3. 检索条件的书写**Where**\n    + 与选择运算`σF(R)`的条件F书写一样，只是其逻辑运算符用 and,or,not 来表示, 同时也要注意运算符的优先次序及括弧的使用。书写要点是注意对自然语言检索条件的正确理解。\n    + `Select Tname From Teacher Where Salary > 2000 and D# = ’03’;`//检索教师表中所有工资大于2000元 并且是03系的教师姓名\n\n4. 排重(`DISTINCT`)\n    + 关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组。\n    + 在Table中要求无重复元组是通过定义Primary key或Unique来保证的;\n    + 而在检索结果中要求无重复元组, 是通过**DISTINCT保留字**的使用来实现的。\n    + `Select DISTINCT S# From SC Where Score > 80; `\n\n5. 排序(`ORDER BY`)\n    + Select语句中结果排序是通过增加**order by**子句实现的\n    + `order by 列名 [asc|desc]`\n    + 意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。\n\n6. 模糊查询(`*LIKE*`)\n    + `_`：一个字符，`%`：任意长度字符。\n    + `Select Sname From Student Where Sname Like '张_ _';`//检索名字为张某某的所有同学姓名\n    + `Select Sname From Student Where Sname Not Like '张%';`//检索名字不姓张的所有同学姓名\n\n\n<span id=\"id3\"><span>\n### 3. 利用SQL多表联合查询\n多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进行选择运算来实现。\n+ 检索语句: **`Select 列名[[,列名] …] From 表名1,表名2,… Where 检索条件;`**\n+ 相当于`Π[列名,...,列名](σ检索条件(表名1 × 表名2 × …))`\n+ 检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种θ-连接\n\n1. θ-连接之**等值连接**\n    + 多表连接时，如两个表的属性名相同，则需采用**`表名.属性名`**方式来限定该属性是属于哪一个表\n    + `Select Sname From Student, SC Where Student.S#=SC.S# and SC.C#='001' Order By Score DESC;`//按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接)\n\n2. 属性重名重名处理(表别名)\n    + 连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用**`别名`**以便区分\n    + `Select 列名 as 列别名[[,列名 as 列别名] …] From 表名1 as 表别名1,表名2 as 表别名2,… Where Where 检索条件;`\n    + 当定义了别名后，在检索条件中可以使用别名来限定属性\n    + as 可以省略\n\n3. θ-连接之**不等值连接**\n    + `Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary>T2.Salary;`//求有薪水差额的任意两位教师\n\n4. 实例：\n    + `Select S1.S# From SC S1, SC S2 Where S1.S# = S2.S# and S1.C#='001' and S2.C#='002' and S1.Score > S2.Score;`//求“001”号课成绩比“002”号课成绩高的所有学生的学号\n\n\n<span id=\"id4\"><span>\n### 4. 利用SQL进行增-删-改\n1. SQL-之**更新操作**\n    + 元组新增Insert：新增一个或一些元组到数据库的Table中\n    + 元组更新Update:对某些元组中的某些属性值进行重新设定\n    + 元组删除Delete：删除某些元组\n\n>- SQL-DML既能单一记录操作，也能对记录集合进行批更新操作\n>- SQL-DML之更新操作需要利用前面介绍的子查询(Subquery)的概念，以便处理“一些”、“某些”等\n\n2. SQL-之**INSERT**\n    + 单一元组新增命令形式：插入一条指定元组值的元组\n        - **`insert into 表名 [(列名[,列名]…)] values (值 [,值]…);`**\n    + 批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元组由子查询给出。\n        - **`insert into 表名 [(列名[，列名]…)] 子查询;`**\n        - 示例：`Insert Into St (S#,Sname) Select S#,Sname From Student Where Sname like '%伟';`//将检索到的满足条件的同学新增到该表中\n\n> 注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作。\n\n3. SQL-之**DELETE**\n    + 元组删除Delete命令: 删除满足指定条件的元组\n    + **`Delete From 表名 [ Where 条件表达式];`**\n    + 如果Where条件省略，则删除所有的元组(清空表)。\n    + 示例：`Delete From Student Where S# in ( Select S# From SC Where Score < 60 Group by S# Having Count(*)>= 4);`//删除有四门不及格课程的所有同学\n\n4. SQL-之**UPDATE**\n    + 元组更新Update命令: 用指定要求的值更新指定表中满足指定条件的元组的指定列的值\n    + **`Update 表名 Set 列名=表达式 | (子查询) [[,列名=表达式 | (子查询) ] …] [ Where 条件表达式];`**\n    + 如果Where条件省略，则更新所有的元组。\n    + 示例：`Update Teacher Set Salary=Salary*1.1 Where D# in (Select D# From Dept Where Dname='计算机');`//将所有计算机系的教师工资上调10%\n\n\n<span id=\"id5\"><span>\n### 5. 利用SQL语言修正与撤销数据库\n1. 修正基本表的定义\n    + **`alter table tablename`**\n    + **`[add {colname datatype, …}]`** //增加新列\n    + **`[drop {完整性约束名}]`** //删除完整性约束\n    + **`[modify {colname datatype, …}]`** //修改列定义\n    + 示例：`Alter Table Student Drop Unique(Sname);`删除学生姓名必须取唯一值的约束\n    + 示例：`Alter Table Student Add Saddr char[40],PID char[18];`在学生表Student上增加二列Saddr, PID\n\n2. SQL-DDL之撤销与修改\n    + `drop table 表名;` //撤消基本表\n    + `drop database 数据库名;` //撤消数据库\n\n3. SQL-DDL之数据库指定与关闭命令\n    + 有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能。\n    + `use 数据库名;` //指定当前数据库\n    + `close 数据库名;` //关闭当前数据库\n\n\n\n<span id=\"id6\"><span>\n### 6. SQL Server介绍\nSQL Server 是 Microsoft提供的一款关系数据库管理系统\n1. SQL Server 的系统数据库\n    + Master：是SQL Server中最重要的系统数据库，存储SQL Server中的元数据。\n    + Model：模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础。\n    + Msdb：代理服务数据库，提供一个存储空间。\n    + Tempdb：临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。\n2. SQL Server的数据库\n    + 文件：有三种文件扩展名：.mdf、.ndf、.ldf\n        - 主数据库文件：扩展名为.mdf，是存储数据库的启动信息和部分或全部数据。一个数据库可以有多个数据库文件，但主数据库文件只有一个。\n        - 辅助数据文件：扩展名为.ndf，用于放置主数据库文件中所定义数据库的其它数据，可有多个。在数据庞大时，可以帮助存储数据。\n        - 日志文件：扩展名.ldf。每个数据库至少有一个事务日志文件。\n    + 页面：是SQL Server存储的最小单位。一页为8K或8192字节。\n    + 空间(extent)：是8个连续的页面，即64K数据，是分配数据表存储空间的一种单位\n\n#### 6.1 SQL Server数据库的创建-删除与维护\n1. 创建数据库\n    + 语法形式：Create Database 库名\n    + 可视化操作(查询分析器)：Database(鼠标右键) -> new Database… -> 填写数据库名及配置\n    + 创建数据库的过程就是为数据库设计名称、设计所占用存储空间和存 放文件位置的过程。特别是在网络数据库中，对数据库的设计显得尤为重要。如估计数据可能占用的磁盘空间有多大，日志文件及其他要占用多大空间。\n    + 创建数据库的用户自动成为数据库的拥有者。\n2. 删除数据库\n    + 语法形式：Drop Database 库名\n    + 可视化操作(查询分析器)：数据库名(鼠标右键) -> Delete\n    + 对不再需要的数据库，应删除以释放空间。删除的结果将是所有数据库文件都一并被删除。\n    + 当数据库处于正在使用或正在恢复状态时，不能删除。\n3. 备份数据库\n    + 可视化操作(查询分析器)：数据库名(鼠标右键) -> Tasks -> Back Up…\n    + 备份就是对数据库或事务日志进行备份。SQL的备份是动态的，备份的过程还可以让用户继续改写。只有系统管理员、数据库的拥有者及数据库的备份者才有权限进行数据备份。可以通过企业管理器进行数据库备份。\n        - 完全数据库备份：完全备份数据文件和日志文件。\n        - 差异备份（增量备份）：对最近一次数据库备份以来发生的数据变化进行备份。这要在完全备份的基础上进行。特点是速度快。\n        - 事务日志备份：对数据库发生的事务进行备份。包括从上次进行事务日志备份、差异备份和数据库完全备份之后，所有已经完成的事务。能尽可能的恢复最新的数据库记录。特点是所需磁盘空间小，时间少。\n        - 数据库文件和文件组备份：用在数据库相当大的情况下。\n4. 恢复数据库\n    + 可视化操作(查询分析器)：数据库名(鼠标右键) -> Tasks -> Restore\n    + 数据库的恢复是指将数据库备份加载到系统中的过程。在根据数据库备份文件恢复过程中，系统将自动执行安全性检查、重建数据库结构及完成填写数据库内容。\n    + 数据库的恢复是静态的。所以在恢复前，应将需要恢复的数据库访问属性设为单用户，不要让其他用户操作。\n    + 可以通过企业管理器来完成数据库恢复。\n5. 数据库授权: \n    + 语法形式：grant 权限 on 表名 to 用户名\n    + 权限有：select,update,insert,delete,exec,dri。\n    + 对被授权的用户，要先成为该数据库的使用者，即要把用户加到数据库里,才能授权.\n\n#### 6.2 SQL Server数据表的创建-与增/删/改/查\n1. 创建表\n    + 同一用户不能建立同一个表名的表，同一表名的表可有多个拥有者。但在使用时，需要在这些表上加上所有者的表名。\n    + 用T-SQL语句创建表，语法形式：`CREATE TABLE [数据库名.所有者名.]表名 ({<列名 数据类型>} [缺省值][约束][是否为空] …)`\n        > 注意：T-SQL是SQL Server软件的SQL语言，与标准版有些差异。但标准版SQL，一般情况下SQL Server软件也都支持\n    + 可视化操作(查询分析器)：数据库名 -> Tables -> New Table…\n2. 增加、修改表字段\n    + 语法形式：`ALTER TABLE ADD | ALTER 字段名 <类型>`\n3. 创建、删除与修改约束\n    + 约束是SQL提供自动保持数据库完整性的一种方法，共5种。\n    + 用T-SQL语句建立约束，语法形式：`CONSTRAINT 约束名 约束类型 (列名)`\n        - 约束名：在库中应该唯一，如不指定，系统会给出\n        - 约束类型 (5种)：\n            * primary key constraint (主键值)\n            * unique constraint (唯一性)\n            * check constraint (检查性)\n            * default constraint (默认)\n            * foreign key constraint (外部键)\n        - 列名：要约束的字段名\n    + 示例:`Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1), T# char(3) ) constraint pk primary key(C# ));`\n\n\n\n<span id=\"id7\"><span>\n### 7. SQL语言-子查询\n- 子查询：出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。\n- 三种类型的子查询：(NOT) IN-子查询；θ-Some/θ-All子查询；(NOT) EXISTS子查询\n\n#### 7.1 (NOT) IN子查询\n1. 基本语法：`表达式 [not] in (子查询)`\n    + 语法中，表达式的最简单形式就是列名或常数。\n    + 语义：判断某一表达式的值是否在子查询的结果中。\n    + 示例：\n        - `Select * From Student Where Sname in ('张三', '王三');`//列出张三、王三同学的所有信息\n        - `Select S#, Sname From Student Where S# in (Select S# From SC Where C#='001');`//列出选修了001号课程的学生的学号和姓名\n3. 非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询前面的子查询示例都是非相关子查询\n4. 相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询\n5. 外层向内层传递的参量需要使用外层的表名或表别名来限定\n    + 示例：`Select Sname From Student Stud Where S# in ( Select S# From SC Where S# = Stud.S# and C#='001');`//求学过001号课程的同学的姓名\n\n> 注意：相关子查询只能由外层向内层传递参数，而不能反之；这也称为变量的作用域原则。\n\n\n#### 7.2 θ-Some/θ-All子查询\n1. 基本语法：`表达式 θ some (子查询)` / `表达式 θ all (子查询)`\n    + 语法中，θ是比较运算符：`<, >, >=, <=, =, <>`。\n    + 语义：将表达式的值与子查询的结果进行比较：\n        - 如果表达式的值至少与子查询结果的某一个值相比较满足 关系，则`表达式 θ some (子查询)`的结果便为真\n        - 如果表达式的值与子查询结果的所有值相比较都满足 关系，则`表达式 θ all (子查询)`的结果便为真\n    + 示例：\n        - `Select Tname From Teacher Where Salary <= all ( Select Salary From Teacher);`//找出工资最低的教师姓名\n        - `Select S# From SC Where C# = “001” and Score < some ( Select Score From SC Where C#='001');`//找出001号课成绩不是最高的所有学生的学号\n\n> 在SQL标准中，也有θ-Any谓词，但由于其语义的模糊性：any,“任一”是指所有呢？还是指某一个？不清楚，所以被θ-Some替代以求更明晰。\n\n2. 等价性变换需要注意\n    + `表达式 = some (子查询)`和`表达式 in (子查询)`含义**相同**\n    + `表达式 <> some (子查询)`和`表达式 not in (子查询)`含义**不同**\n    + `表达式 <> all (子查询)`和`表达式 not in (子查询)`含义**相同**\n\n\n#### 7.3 (NOT) EXISTS子查询\n1. 基本语法：`[not] Exists [not] Exists (子查询)`\n    + 语义：子查询结果中有无元组存在\n\n``` sql\n--示例：检索选修了赵三老师主讲课程的所有同学的姓名\nSelect DISTINCT Sname From Student\n    Where exists ( Select * From SC, Course, Teacher\n        Where SC.C#=Course.C# and SC. S#=Student.S#\n        and Course.T# = Teacher.T# and Tname='赵三');\n\n--示例：检索学过001号教师主讲的所有课程的所有同学的姓名\nSelect Sname From Student\n    Where not exists //不存在\n        ( Select * From Course //有一门001教师主讲课程\n        Where Course.T# = ‘001’ and not exists //该同学没学过\n            ( Select * From SC\n            Where S# = Student.S# and C# = Course.C#));\n--上述语句的意思：不存在有一门001号教师主讲的课程该同学没学过\n```\n\n\n\n<span id=\"id8\"><span>\n### 8. SQL语言-结果计算与聚集计算\n#### 8.1 结果计算\nSelect-From-Where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表明在投影的同时直接进行一些运算\n+ `Select Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where Where 检索条件 ];`\n    - expr可以是常量、列名、或由常量、列名、特殊函数及算术运算符构成的算术运算式。特殊函数的使用需结合各自DBMS的说明书\n    - agfunc()是一些聚集函数\n\n``` sql\n--示例：求有差额(差额>0)的任意两位教师的薪水差额\nSelect T1.Tname as TR1, T2.Tname as TR2, T1.Salary – T2.Salary\n    From Teacher T1, Teacher T2\n    Where T1.Salary > T2.Salary;\n```\n\n#### 8.2 聚集函数\nSQL提供了五个作用在简单列值集合上的内置聚集函数agfunc,分别是：COUNT、SUM、AVG、MAX、MIN\n\n|聚合函数 |支持的数据类型|描述|\n|--------|------------|---|\n|count() |任何类型/*   |计算结果集中的总行数|\n|sum()   |Numeric     |计算指定列中所有非空值的总和|\n|avg()   |numeric     |计算指定列中所有非空值的平均值|\n|max()   |char/numeric|返回指定列中最大值|\n|min()   |char/numeric|返回指定列中最小值|\n\n``` sql\n--示例：求教师的工资总额\nSelect Sum(Salary) From Teacher;\n--示例：求计算机系教师的工资总额\nSelect Sum(Salary) From Teacher T, Dept\n    Where Dept.Dname = ‘计算机’ and Dept.D# = T.D#;\n--示例：求数据库课程的平均成绩\nSelect AVG(Score) From Course C, SC\n    Where C.Cname = ‘数据库’ and C.C# = SC.C#;\n```\n\n\n<span id=\"id9\"><span>\n### 9. SQL语言-分组查询与分组过滤\n#### 9.1 分组查询\n分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。\n1. 分组的基本语法：\n``` sql\nSelect Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]\n    From 表名1 [, 表名2 … ]\n    [ Where Where 检索条件 ]\n    [ Group by Group by 分组条件 ] ;\n```\n\n2. 分组条件可以是：`列名1, 列名2, …`\n3. 示例： 求每一个学生的平均成绩\n    + `Select S#, AVG(Score) From SC Group by S#;`\n\n#### 9.2 分组过滤\n聚集函数是不允许用于Where子句中的：Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤\n* 分组过滤：若要对集合(即分组)进行条件过滤，即满足条件的集合/分组留下，不满足条件的集合/分组剔除。\n* Having子句，又称分组过滤子句。需要有Groupby子句支持，换句话说，没有Groupby子句，便不能有Having子句。\n\n1. 基本语法：\n``` sql\nSelect Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]\n    From 表名1 [, 表名2 … ]\n    [ Where Where 检索条件 ]\n    [ Group by Group by 分组条件 [ Having Having 分组过滤条件] ] ;\n```\n\n2. 示例：求不及格课程超过两门的同学的学号\n    + `Select S# From SC Where Score<60 Group by S# Having Count(*)>2;` \n\n#### 9.3 where子句与having子句的区别\n1. 聚合函数是比较where、having 的关键。在from后面的执行顺序：\n    + `where -> 聚合函数(sum,min,max,avg,count) ->having`\n2. 列出group by来比较二者:\n    + where子句：是在分组之前使用，表示从所有数据中筛选出部分数据，以完成分组的要求，在where子句中不允许使用统计函数，没有group by子句也可以使用。\n    + having子句：是在分组之后使用的，表示对分组统计后的数据执行再次过滤，可以使用统计函数，有group by子句之后才可以出现having子句。\n\n> 注意事项 ： \n> 1. where 后不能跟聚合函数，因为where执行顺序大于聚合函数。 \n> 2. where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。 \n> 3. having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。\n\n\n\n<span id=\"id10\"><span>\n### 10. SQL语言实现关系代数操作\nSQL语言：并运算UNION, 交运算INTERSECT, 差运算EXCEPT。\n+ 基本语法形式：\n    - `子查询 {Union [ALL] | Intersect [ALL] | Except [ALL] 子查询}`\n+ 通常情况下自动删除重复元组：不带ALL。若要保留重复的元组，则要带ALL。\n    * 假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在：\n        - 子查询1 Union ALL 子查询2 ，出现m + n次\n        - 子查询1 Intersect ALL 子查询2 ，出现min(m,n)次\n        - 子查询1 Except ALL 子查询2 ，出现max(0, m – n)次\n\n> UNION运算符是Entry-SQL92的一部分, INTERSECT、EXCEPT运算符是Full-SQL92的一部分,它们都是Core-SQL99的一部分，但**有些DBMS并不支持**这些运算，使用时要注意。\n\n\n#### 10.1 SQL并运算(UNION)\n1. 示例：已知两个表\n    * Customers(Cid, Cname, City, Discnt)\n    * Agents(Aid, Aname, City, Percent)\n2. 求客户所在的或者代理商所在的城市\n``` sql\nSelect City From Customers\nUNION\nSelect City From Agents;\n```\n\n\n#### 10.2 SQL交运算(INTERSECT)\n1. 示例：求既学过002号课，又学过003号课的同学学号\n``` sql\nSelect S# From SC Where C# = ‘002’\nINTERSECT\nSelect S# From SC Where C# = ‘003’;\n```\n2. 上述语句也可采用如下不用INTERSECT的方式来进行\n    + `Select S# From SC Where C# = ‘002’ and S# IN (Select S# From SC Where C# = ‘003’);`\n\n3. 交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也可以用其他方式表达同样的查询需求。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。\n\n\n#### 10.3 SQL差运算(EXCEPT)\n1. 示例： 假定所有学生都有选课，求没学过002号课程的学生学号\n``` sql\nSelect DISTINCT S# From SC\nEXCEPT\nSelect S# From SC Where C# = ‘002’;\n```\n\n2. 上述语句也可采用如下不用INTERSECT的方式来进行\n``` sql\nSelect DISTINCT S# From SC SC1\n    Where not exists ( Select * From SC\n        Where C# = ‘002’ and S# = SC1.S#);\n```\n\n3. 差运算符Except也没有增强SQL的表达能力，没有Except， SQL也可以用其他方式表达同样的查询需求。只是有了Except更容易表达一些，但增加了SQL语言的不唯一性。\n\n\n#### 10.4 空值的处理\n空值是其值不知道、不确定、不存在的值；数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等\n1. 在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来标记，使用特殊的空值检测函数来获得某列的值是否为空值。\n2. 空值检测：\n    + `is [not ] null` //测试指定列的值是否为空值\n3. 示例：找出年龄值为空的学生姓名\n    + `Select Sname From Student Where Sage is null;`\n4. 现行DBMS的空值处理小结\n    + 除is[not]null之外，空值不满足任何查找条件\n    + 如果null参与算术运算，则该算术表达式的值为null\n    + 如果null参与比较运算，则结果可视为false。在SQL-92中可看成unknown\n    + 如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null\n\n\n#### 10.5 内连接、外连接\n1. 标准SQL语言中连接运算通常为：\n    + `Select Select 列名[[,列名]… ] From 表名1,表名2,… Where 检索条件;`\n    + 即相当于采用`Π[列名,…,列名](σ 检索条件(表名1 × 表名2 × …))`。\n2. SQL的高级语法中引入了内连接与外连接运算，具体形式：\n``` sql\nSelect Select 列名 [ [, 列名] … ]\n    From 表名1 [NATURAL]\n    [ INNER | { LEFT | RIGHT | FULL} [OUTER]] JOIN 表名2\n    { ON 连接条件 | Using (Colname {, Colname …}) }\n    [ Where Where 检索条件 ] … ;\n```\n3. 由 **连接类型** 和 **连接条件** 构成连接运算。\n    + **`Natural`**：出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次\n    + **`Inner Join`**: 即关系代数中的θ-连接运算\n    + **`Left Outer Join, Right Outer Join, Full Outer Join`**: 即关系代数中的外连接运算\n    + **`on <连接条件>`**：出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次\n    + **`using (Col1, Col2, …, Coln)`**：Col是两个连接关系的公共属性的子集，元组在(Col1,Col2,…,Coln)上取值相等，且(Col1,Col2,…,Coln)只出现一次\n4. 示例:\n\n``` sql\n-- (Inner Join)求所有教师的任课情况并按教师号排序(没有任课的教师也需列在表中)\nSelect Teacher.T#, Tname, Cname\n    From Teacher Inner Join Course\n        ON Teacher.T# = Course.T#\n    Order by Teacher.T# ASC;\n\n--(Outer Join)求所有教师的任课情况(没有任课的教师也需列在表中)\nSelect Teacher. T#, Tname, Cname\n    From Teacher Left Outer Join Course\n        ON Teacher.T# = Course.T#\n    Order by Teacher.T# ASC ;\n```\n\n\n\n<span id=\"id11\"><span>\n### 11. SQL语言之视图及其应用\n1. 数据库的三级模式两层映像\n    * 三级模式：数据库系统是由外模式、模式(概念模式)和内模式三级构成\n    * 应用--> **外模式**(多个) --> **概念模式**(一个) --> **内模式**(一个) --> 数据库\n    * 两层映像：`E-C`映像(外模式->概念模式)、`C-I`映像(概念模式->内模式)。\n2. 对应概念模式的数据在SQL中被称为**基本表(Table)**,而对应外模式的数据称为**视图(View)**。**视图不仅包含外模式，而且包含其E-C映像**。\n3. **基本表**是实际存储于存储文件中的表，基本表中的**数据是需要存储的**\n4. **视图**在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，其**数据并不存储**，而是在运行过程中动态产生与维护的\n5. 对视图数据的更改最终要反映在对基本表的更改上。\n\n#### 11.1 视图的定义\n视图需要“先定义，再使用”；定义视图，有时可方便用户进行检索操作。\n1. 定义视图: `create view view_name [(列名[列名] …)] as 子查询 [with check option]`\n    + 如果视图的属性名缺省，则默认为子查询结果中的属性名；也可以显式指明其所拥有的列名。\n    + with checkoption指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式\n2. 示例：定义一个视图 CompStud 为计算机系的学生，通过该视图可以将Student表中其他系的学生屏蔽掉\n``` sql\nCreate View CompStud AS\n    (Select * From Student\n        Where D# in (Select D# From Dept\n            Where Dname = ‘计算机’));\n```\n\n#### 11.2 视图的使用\n使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用\n+ 示例：检索计算机系的所有学生，我们可使用CompStud\n    - `Select * From CompStud;`\n+ 示例：检索计算机系的年龄小于20的所有学生，我们可使用CompStud\n    - `Select * From CompStud Where Sage<20;`\n\n#### 11.3 视图的更新\nSQL视图更新：是比较复杂的问题，因视图不保存数据，对视图的更新最终要反映到对基本表的更新上，而有时，视图定义的映射不是可逆的。\n1. SQL视图更新的可执行性\n    + 如果视图的select目标列包含聚集函数，则不能更新\n    + 如果视图的select子句使用了unique或distinct，则不能更新\n    + 如果视图中包括了groupby子句，则不能更新\n    + 如果视图中包括经算术表达式计算出来的列，则不能更新\n    + 如果视图是由单个表的列构成，但并没有包括主键，则不能更新\n2. 对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主键，则可以更新\n3. 可更新SQL视图示例：\n\n``` sql\n-- 定义视图\ncreate view CStud(S#, Sname, Sclass)\nas ( select S#, Sname, Sclass from Student where D# ='03');\n-- 更新视图\nInsert into CStud Values ('98030104', '张三丰', '980301');\n-- 更新视图 将转换为 更新基本表\ninsert into Student values ('98030104', '张三丰', Null, Null, '03', '980301')\n```\n\n#### 11.4 视图的撤销\n已经定义的视图也可以撤消\n* 撤消视图：`Drop View view_name`\n\n不仅视图可以撤消，基本表、数据库等都可以撤消\n* 撤消基本表：`Drop Table 表名`\n\n\n<span id=\"id12\"><span>\n### 12. 数据库完整性\n数据库完整性(DB Integrity)是指：DBMS应保证的DB的一种特性--在任何情况下的正确性、有效性和一致性\n* 广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等\n* 狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题。\n\n#### 12.1 基本概念\n关系模型中有完整性要求：实体完整性、参照完整性、用户自定义完整性\n1. 数据库完整性管理的作用\n    * 防止和避免数据库中不合理数据的出现\n    * DBMS应尽可能地自动防止DB中语义不合理现象\n    * 如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担\n2. DBMS怎样自动保证完整性：\n    * DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义)\n    * 当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性\n3. **完整性约束条件**(或称完整性约束规则)的一般形式：Integrity Constraint::=(O,P,A,R)\n    + O：数据集合：约束的对象(列、多列(元组)、元组集合)\n    + P：谓词条件：需要定义什么样的约束\n    + A：触发条件：默认更新时检查\n    + R：响应动作：默认拒绝\n\n#### 12.2 数据库完整性的分类\n1. 按约束对象分类:\n    - 域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的\n    - 关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断\n\n2. 按约束来源分类:\n    - 结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等；\n    - 内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等。\n\n3. 按约束状态分类:\n    - 静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。\n    - 动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。\n\n\n\n<span id=\"id13\"><span>\n### 13. 数据库的静态完整性(约束)\n1. SQL语言支持的约束类别：\n    + 静态约束\n        - 列完整性—域完整性约束\n        - 表完整性--关系完整性约束\n    + 动态约束\n        - 触发器\n\n2. CreateTable有三种功能：定义关系模式、定义完整性约束 和定义物理存储特性\n    + 定义完整性约束条件：列完整性、表完整性\n\n3. 列约束：一种**域约束类型**，对单一列的值进行约束\n``` sql\n{ NOT NULL |                  //列值非空\n[ CONSTRAINT constraintname ] //为约束命名，便于以后撤消\n{ UNIQUE                      //列值是唯一\n| PRIMARY KEY                 //列为主键\n| CHECK (search_cond)         //列值满足条件,条件只能使用列当前值\n| REFERENCES tablename [(colname) ]\n[ON DELETE { CASCADE | SET NULL } ] } } \n```\n\n4. 表约束：一种**关系约束类型**，对多列或元组的值进行约束\n``` sql\n[ CONSTRAINT constraintname ]       //为约束命名，便于以后撤消\n{ UNIQUE (colname {,colname…})      //几列值组合在一起是唯一\n| PRIMARY KEY (colname {,colname…}) //几列联合为主键\n| CHECK (search_condition)          //元组多列值共同满足条件\n                                    //条件中只能使用同一元组的不同列当前值\n| FOREIGN KEY (colname {,colname…})\nREFERENCES tablename [(colname {,colname…})]//引用另一表tablename的若干列的值作为外键\n```\n> check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。\n\n5. Create Table中定义的表约束或列约束可以在以后根据需要进行撤消或追加。撤消或追加约束的语句是 Alter Table(不同系统可能有差异)\n    + 示例：撤消SC表的ctscore约束(由此可见，未命名的约束是不能撤消)\n        - `Alter Table SC DROP CONSTRAINT ctscore;`\n    + 有些DBMS支持独立的追加约束,注意书写格式可能有些差异\n        - 示例：`Alter Table SC Add Constraint nctscore check (Score>=0.0 and Score<=150.0));`\n\n6. 现约束的方法-断言ASSERTION\n    + 一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件\n    + 表约束和列约束就是一些特殊的断言\n    + SQL还提供了复杂条件表达的断言。其语法形式为：\n        - `CREATE ASSERTION <assertion-name> CHECK <predicate>`\n    + 当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是否违反该断言。\n\n``` sql\n-- 示例: “每个分行的贷款总量必须小于该分行所有账户的余额总和”\ncreate assertion sum_constraint check\n    (not exists (select * from branch\n    where (select sum(amount ) from loan\n        where loan.branch_name = branch.branch_name )\n    >= (select sum (balance ) from account\n        where account.branch_name = branch.branch_name )))\n-- 数据表：\naccount(branch_name, account_number,…, balance) //分行，账户及其余额\nloan(branch_name , loan_number, amount,) //分行的每一笔贷款\nbranch(branch_name, … ) //分行\n```\n> 断言测试增加了数据库维护的负担，要小心使用复杂的断言。\n\n\n<span id=\"id14\"><span>\n### 14. 数据库的动态完整性(触发器)\n实现数据库动态完整的方法—触发器Trigger\n1. 触发器Trigger\n    + Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger\n    + Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。\n\n2. 基本语法\n``` sql\nCREATE TRIGGER trigger_name BEFORE | AFTER\n    { INSERT | DELETE | UPDATE [OF colname {, colname...}] }\n    ON tablename [REFERENCING corr_name_def {, corr_name_def...} ]\n    [FOR EACH ROW | FOR EACH STATEMENT]\n                //对更新操作的每一条结果(前者)，或整个更新操作完成(后者)\n    [WHEN (search_condition)]           //检查条件，如满足执行下述程序\n    { statement         //单行程序直接书写，多行程序要用下行方式\n    | BEGIN ATOMIC statement; { statement;...} END }\n```\n\n3. 触发器Trigger意义：\n    + 当某一事件发生时(Before|After),对该事件产生的结果(或是每一元组，或是整个操作的所有元组), 检查条件`search_condition`,如果满足条件，则执行后面的程序段。条件或程序段中引用的变量可用`corr_name_def`来限定。\n\n4. 事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}\n    + 当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后After触发\n    + 操作发生，执行触发器操作需处理两组值：更新前的值和更新后的值，这两个值由`corr_name_def`的使用来区分\n\n5. `corr_name_def`的定义\n``` sql\n{ OLD [ROW] [AS] old_row_corr_name //更新前的旧元组命别名为\n| NEW [ROW] [AS] new_row_corr_name //更新后的新元组命别名为\n| OLD TABLE [AS] old_table_corr_name //更新前的旧Table命别名为\n| NEW TABLE [AS] new_table_corr_name //更新后的新Table命别名为\n}\n```\n> `corr_name_def`将在检测条件或后面的动作程序段中被引用处理\n\n6. 示例1: 设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降\n``` sql\ncreate trigger teacher_chgsal before update of salary\n    on teacher\n    referencing new x, old y\n    for each row when (x.salary < y.salary)\nbegin\n    raise_application_error(-20003, 'invalid salary on update');\n    //此条语句为Oracle的错误处理函数\nend;\n```\n\n7. 示例2: 假设student(S#, Sname, SumCourse), SumCourse为该同学已学习课程的门数，初始值为0，以后每选修一门都要对其增1 。设计一个触发器自动完成上述功能。\n``` sql\ncreate trigger sumc after insert on sc\n    referencing new row newi\n    for each row\nbegin\n    update student set SumCourse = SumCourse + 1\n    where S# = :newi.S# ;\nend;\n```\n\n8. 示例3：假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。设计一个触发器完成上述功能\n``` sql\ncreate trigger delS# after delete on Student\n    referencing old oldi\n    for each row\nbegin\n    delete sc where S# = :oldi.S# ;\nend; \n```\n\n\n<span id=\"id15\"><span>\n### 15. 数据库索引\n索引是对数据库表中一列或多列的值进行排序的一种**数据结构**（最常见的是B-Tree）\n1. 索引的作用\n    1. 快速取数据；\n    2. 保证数据记录的唯一性；\n    3. 实现表与表之间的参照完整性；\n    4. 在使用ORDER by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。\n2. 创建索引：`CREATE INDEX  索引名称  on 表名(字段名);`\n3. 删除索引：`DROP INDEX 索引名称`\n4. 索引注意事项：\n    1. 查询时减少使用`*`返回全部列，不要返回不需要的列\n    2. where表达式子句包含索引的表达式置前\n    3. 避免在Order by中使用表达式\n    4. 索引技术是数据库自动使用，一个表格只存在一个索引就够了\n5. 缺点\n    1. 索引的缺点是创建和维护索引需要耗费时间和空间\n    2. 索引可以提高查询速度，会减慢写入速度\n    3. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n\n#### 15.1 索引主要种类\n根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。\n1. 唯一索引\n    + 唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。\n2. 主键索引\n    + 数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。\n3. 聚集索引\n    + 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。\n4. 索引列\n    + 可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。\n\n\n\n<span id=\"id16\"><span>\n### 16. 数据库序列\n序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。创建序列需要`CREATE SEQUENCE`系统权限。\n#### 16.1 Oracle中的序列（Sequence）\n1. 创建序列\n``` sql\ncreate sequence 序列名 \n    [increment by n]   --每次增加n个，默认为1\n    [start with n]     --起始值n，默认为1\n    [{maxvalue n | nomaxvalue}]  --最大值设置，递增默认10的27次方，递减默认-1\n    [{minvalue n | nominvalue}]  --最小值设置，递增默认1，递减默认-10的26次方\n    [{cycle | nocycle}]   --是否循环\n    [{cache n | nocache}] --是否对序列进行内存缓冲，默认为20\n```\n\n2. 查询序列\n    + `NEXTVAL`:返回序列中下一个有效的值，任何用户都可以引用。\n    + `CURRVAL`:中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。\n\n``` sql\n--查询下一个将要使用的序列\nselect 序列名.nextval from dual\n--查询当前序列\nselect 序列名.currval from dual \n```\n>- Oracle将sequence的定义存储在数据字典之中。\n>- Sequence是独立于事务的，就是说序列的增加不需要等待事务的完成，也就是说序列是异步于事务而增长的。这说明，你访问不到别的用户使用该sequence产生的值，也就是说你只能访问到你当前产生的值，即使其他用户已经增加了sequence的值；还说明如果事务回滚，sequence不会回滚，它所发生的改变是一维的。\n\n3. 删除序列：`Drop sequence 序列名`\n4. 更改序列：`Alter sequence 序列名 [其余参数同创建序列]`\n5. 使用序列示例：\n\n``` sql\n-- 1.直接使用\ninsert into person (id, name, password) values (序列名.nextval, '张三', '123')\n\n-- 2.也可以通过建立触发器，当有数据插入表person时，使用oracle序列为其去的递增的主键值\n-- 2.1创建触发器\ncreate or replace trigger 触发器名 before insert on person\nfor each row\nbegin\n    select 序列名.nextval into :new.id from dual;\nend;\n-- 2.2插入数据\ninsert into person ( username, age, password) values ('张三', 20, 'zhang123')\n```\n\n6. 注意点：\n    + 一个序列可以被多张别使用，不过一般建议为每个表建立单独的序列。\n    + 当使用到序列的事务发生回滚。会造成序列号不连续。在用生成的序列值作为编号做插入数据库操作时，可能遇到事务提交失败，从而导致序号不连续。\n    + 大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 n个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数最好不要设置过大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入n个。这种情况也能会在数据库关闭时也会导致序号不连续。\n\n\n#### 16.2 Mysql中的序列（AUTO_INCREMENT）\nMySQL中最简单使用序列的方法就是使用`AUTO_INCREMENT`来定义列。\n1. orale没有类似mysql的AUTO_INCREMENT这样的自增长字段，实现插入一条记录，自动增加1.oracle是通过sequence（序列）来完成的。\n2. 首先mysql的自增长“序列”和序列是两回事，mysql本身不提供序列机制。\n3. mysql的AUTO_INCREMENT可以设置起始值，但是不能设置步长，其步长默认就是1.\n4. mysql一个表只能有一个自增长字段。自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。并且只能是数字型。\n\n\n\n\n<span id=\"id17\"><span>\n### 17. 数据库安全性\n数据库安全性是指DBMS应该保证的数据库的一种特性(机制或手段)：免受非法、非授权用户的使用、泄漏、更改或破坏\n1. 数据库安全性管理涉及许多方面\n    1. 社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法\n    2. 公共政策/制度方面：例如，政府或组织的信息公开或非公开制度\n    3. 安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略)\n    4. 数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)\n    5. 数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制\n2. DBMS的安全机制\n    1. **自主安全性机制**：存取控制(AccessControl)\n        + 通过权限在用户之间的传递，使用户自主管理数据库安全性\n    2. **强制安全性机制**：\n        + 通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据\n    3. 推断控制机制：\n        + 防止通过历史信息，推断出不该被其知道的信息；\n        + 防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要\n    4. 数据加密存储机制：\n        + 通过加密、解密保护数据，密钥、加密/解密方法与传输\n3. DBA的责任和义务\n    + 熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略\n    + 规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应，\n    + **划分好数据的安全级别以及用户的安全级别**\n    + 实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等\n\n\n\n<span id=\"id18\"><span>\n### 18. 数据库自主安全性机制\n+ 通常情况下，自主安全性是通过授权机制来实现的。\n+ 用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。\n    + 授权者：决定用户权利的人\n    + 授权：授予用户访问的权利\n\n1. DBMS自动实现自主安全性：\n    + DBMS允许用户定义一些安全性控制规则(用SQL-DCL来定义)\n    + 当有DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许访问\n2. DBMS将权利和用户(账户)结合在一起，形成一个访问规则表，依据该规则表可以实现对数据库的安全性控制\n    + `AccessRule ::=(S, O, t, P)`\n        - S: 请求主体(用户)\n        - O: 访问对象\n        - t: 访问权利\n        - P: 谓词\n    + {AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利;\n    + 用户多时，可以按用户组建立访问规则\n    + 访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库\n    + 权利：包括创建、增、删、改、查等\n    + 谓词：拥有权利需满足的条件\n3. **示例**：员工管理数据库的安全性控制示例`Employee(P#,Pname,Page,Psex,Psalary,D#,HEAD)`\n    + 示例要求：\n        - 员工管理人员：能访问该数据库的所有内容，便于维护员工信息\n        - 收发人员：访问该数据库以确认某员工是哪一个部门的，便于收发工作，只能访问基本信息，其他信息不允许其访问\n        - 每个员工：允许其访问关于自己的记录，以便查询自己的工资情况，但不能修改\n        - 部门领导：能够查询其所领导部门人员的所有情况\n        - 高层领导：能访问该数据库的所有内容，但只能读\n    + 两种控制示例\n        - 按名控制安全性：存储矩阵\n        - 按内容控制安全性：视图\n    + 视图是安全性控制的重要手段\n    + 通过视图可以限制用户对关系中某些数据项的存取,例如：\n        - 视图1：CreateEmpV1as select*fromEmployee\n        - 视图2：CreateEmpV2as selectPname,D#fromEmployee\n    + 通过视图可将数据访问对象与谓词结合起来，限制用户对关系中某些元组的存取，例如：\n        - 视图1： CreateEmpV3asselect*fromEmployeewhereP#=:UserId\n        - 视图2： CreateEmpV4asselect*fromEmployeewhereHead=:UserId\n    + 用户定义视图后，视图便成为一新的数据对象，参与到存储矩阵与能力表中进行描述\n\n#### 18.1 SQL语言的用户与权利\n1. SQL语言包含了DDL,DML和DCL。数据库安全性控制是属于DCL范畴\n2. 授权机制---自主安全性；视图的运用\n3. 关系级别(普通用户) <-- 账户级别(程序员用户) <-- 超级用户(DBA) \n    + (级别1)Select : 读(读DB, Table, Record, Attribute, … )\n    + (级别2)Modify : 更新\n        - Insert : 插入(插入新元组, … )\n        - Update : 更新(更新元组中的某些值, …)\n        - Delete : 删除(删除元组, …)\n    + (级别3)Create : 创建(创建表空间、模式、表、索引、视图等)\n        - Create : 创建\n        - Alter : 更新\n        - Drop : 删除\n4. 级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为账户级别的权利，而将级别1和2称为关系级别的权利。\n5. 授权命令`GRANT`\n```  sql\nGRANT {all PRIVILEGES | privilege {,privilege…}}\n    ON [TABLE] tablename | viewname\n    TO {public | user-id {, user-id…}}\n    [WITH GRANT OPTION];\n```\n    + user-id ，某一个用户账户，由DBA创建的合法账户\n    + public, 允许所有有效用户使用授予的权利\n    + privilege是下面的权利\n        - SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES\n    + WITH GRANT OPTION选项是允许被授权者传播这些权利\n\n6. SQL-DCL的控制安全性-授权示例:\n    + 假定高级领导为Emp0001, 部门领导为Emp0021, 员工管理员为Emp2001,收发员为Emp5001(均为UserId, 也即员工的P#)\n        - Grant All Priviledges ON Employee TO Emp2001;\n        - Grant SELECT ON EmpV2 TO Emp5001;\n        - Grant SELECT ON EmpV3 TO public;\n        - Grant SELECT ON EmpV4 TO Emp0021;\n    + 授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别)\n    + 授权者授予的权利必须是授权者已经拥有的权利\n\n7. 收回授权命令`REVOKE`\n``` sql\nREVOKE {all privilEges | priv {, priv…} } \n    ON tablename | viewname\n    FROM {public | user {, user…} }; \n```\n    + 示例: `revoke select on employee from UserB;`\n\n\n#### 18.2 自主安全性的授权过程及其问题\n##### 18.2.1 授权过程:\n1. 第一步：DBA创建DB, 并为每一个用户创建一个账户\n    + 假定建立了五个用户：UserA, UserB, UserC, UserD, UserE\n2. 第二步：DBA授予某用户账户级别的权利\n    + 假定授予UserA\n3. 第三步：具有账户级别的用户可以创建基本表或视图, 他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问 权利\n    + 假定UserA创建了Employee, 则UserA就是Employee表的属主账户\n4. 第四步：拥有属主账户的用户可以将其中的一部分权利授予另外的用户，该用户也可将权利进一步授给其他的用户…\n    + 假定UserA将读权限授予UserB, 而userB又将其拥有的权限授予UserC,如此将权利不断传递下去。\n\n* 注意授权的传播范围\n    + 传播范围包括两个方面：水平传播数量和垂直传播数量\n        - 水平传播数量是授权者的再授权用户数目(树的广度)\n        - 垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权者, …传播的深度(树的深度)\n    + 有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。\n    + 当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回\n    + 如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当UserB收回时，其还将保持UserE赋予其的权利。\n\n##### 18.2.2 强制安全性机制\n1. 强制安全性机制\n    * 强制安全性通过对数据对象进行安全性分级\n        + 绝密(Top Secret), 机密(Secret), 可信(Confidential) 和 无分类(Unclassified)\n    * 同时对用户也进行上述的安全性分级\n    * 从而强制实现不同级别用户访问不同级别数据的一种机制\n2. 强制安全性机制的实现\n    * DBMS引入强制安全性机制, 可以通过扩展关系模式来实现\n        + 关系模式: R(A1: D1, A2: D2, …, An:Dn)\n        + 对属性和元组引入安全性分级特性或称分类特性\n            - R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性\n    * 这样, 关系中的每个元组, 都将扩展为带有安全分级的元组\n    * 强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。\n\n\n","slug":"【数据库】数据库语言SQL","published":1,"updated":"2021-12-12T02:50:23.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx2vb6x1002jvcuehtq9hsgh","content":"<h3 id=\"SQL语言概述\"><a href=\"#SQL语言概述\" class=\"headerlink\" title=\"SQL语言概述\"></a>SQL语言概述</h3><p><strong>结构化查询语言</strong>(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p>\n<ul>\n<li>SQL语言是集DDL、DML和DCL于一体的数据库语言<span id=\"more\"></span><ol>\n<li><strong>DDL语句</strong>引导词：Create(建立),Alter(修改),Drop(撤消)<ul>\n<li>模式的定义和删除，包括定义Database,Table,View,Index,完整性约束条件等，也包括定义对象(RowType行对象,Type列对象)</li>\n</ul>\n</li>\n<li><strong>DML语句</strong>引导词：Insert ,Delete, Update, Select<ul>\n<li>各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入</li>\n<li>各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等</li>\n<li>各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等</li>\n</ul>\n</li>\n<li><strong>DCL语句</strong>引导词：Grant,Revoke<ul>\n<li>安全性控制：授权和撤消授权</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h4><ol>\n<li><a href=\"#id1\">利用SQL建立数据库</a></li>\n<li><a href=\"#id2\">利用SQL简单查询</a></li>\n<li><a href=\"#id3\">利用SQL多表联合查询</a></li>\n<li><a href=\"#id4\">利用SQL进行增-删-改</a></li>\n<li><a href=\"#id5\">利用SQL语言修正与撤销数据库</a></li>\n<li><a href=\"#id6\">SQL Server介绍</a></li>\n<li><a href=\"#id7\">SQL语言-子查询</a></li>\n<li><a href=\"#id8\">SQL语言-结果计算与聚集计算</a></li>\n<li><a href=\"#id9\">SQL语言-分组查询与分组过滤</a></li>\n<li><a href=\"#id10\">SQL语言实现关系代数操作</a></li>\n<li><a href=\"#id11\">SQL语言之视图及其应用</a></li>\n<li><a href=\"#id12\">数据库完整性</a></li>\n<li><a href=\"#id13\">数据库的静态完整性(约束)</a></li>\n<li><a href=\"#id14\">数据库的动态完整性(触发器)</a></li>\n<li><a href=\"#id15\">数据库索引</a></li>\n<li><a href=\"#id16\">数据库序列</a></li>\n<li><a href=\"#id17\">数据库安全性</a></li>\n<li><a href=\"#id18\">数据库自主安全性机制</a></li>\n</ol>\n<p><span id=\"id1\"><span></p>\n<h3 id=\"1-利用SQL建立数据库\"><a href=\"#1-利用SQL建立数据库\" class=\"headerlink\" title=\"1. 利用SQL建立数据库\"></a>1. 利用SQL建立数据库</h3><p>DDL：数据定义语言（Data Definition Language)，<br>DDL通常由**DBA(数据库管理员)**来使用，也有经DBA授权后由应用程序员来使用</p>\n<ol>\n<li>创建数据库(DB)：<strong>Create Database</strong><ul>\n<li>数据库(Database)是若干具有相互关联关系的Table/Relation的集合</li>\n<li>简单语法形式：<code>create database database 数据库名;</code></li>\n</ul>\n</li>\n<li>创建DB中的Table(定义关系模式)：<strong>Create Table</strong><ul>\n<li><code>Create table 表名(列名 数据类型 [Primary key|Unique] [Not null][,列名 数据类型 [Not null], …]);</code><ul>\n<li><code>[]</code>表示其括起的内容可以省略，<code>|</code>表示其隔开的两项可取其一</li>\n<li><code>Primary key</code>: 主键约束。每个表只能创建一个主键约束</li>\n<li><code>Unique</code>: 唯一性约束(即候选键)。可以有多个唯一性约束</li>\n<li><code>Not null</code>: 非空约束。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>数据类型</strong>（SQL-92标准）<ul>\n<li><code>char(n)</code>:固定长度的字符串</li>\n<li><code>varchar(n)</code>:可变长字符串</li>\n<li><code>int</code>:整数 //有时不同系统也写作integer</li>\n<li><code>numeric(p，q)</code>:固定精度数字，小数点左边p位，右边(p-q)位</li>\n<li><code>real</code>:浮点精度数字 //有时不同系统也写作<code>float(n)</code>，小数点后保留n位</li>\n<li><code>date</code>:日期 (如 2003-09-12)</li>\n<li><code>time</code>:时间 (如 23:15:003)<blockquote>\n<p>注意: 现行商用DBMS的数据类型有时有些差异</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id2\"><span></p>\n<h3 id=\"2-利用SQL简单查询\"><a href=\"#2-利用SQL简单查询\" class=\"headerlink\" title=\"2. 利用SQL简单查询\"></a>2. 利用SQL简单查询</h3><p>DML：数据操纵语言（Data Manipulation Language)，<br>DML通常由<strong>用户或应用程序员</strong>使用，访问经授权的数据库</p>\n<ol>\n<li><p>向Table中添加数据(追加元组)：<strong>Insert into</strong></p>\n<ul>\n<li><strong><code>insert into insert into 表名[(列名[, 列名] …] values (值[,值], …);</code></strong><ul>\n<li>values值的排列，须与列名排列一致</li>\n<li>若所有列名省略，则values值的排列须与该表存储中的列名排列一致</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>单表查询<strong>Select</strong></p>\n<ul>\n<li><strong><code>Select Select 列名[[,列名] …] From 表名[Where 检索条件];</code></strong><ul>\n<li>语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示。</li>\n<li>相当于：<code>Π[列名,...,列名](σ检索条件(表名))</code></li>\n</ul>\n</li>\n<li>Select语句中的select … , from… , where…, 等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。</li>\n</ul>\n</li>\n<li><p>检索条件的书写<strong>Where</strong></p>\n<ul>\n<li>与选择运算<code>σF(R)</code>的条件F书写一样，只是其逻辑运算符用 and,or,not 来表示, 同时也要注意运算符的优先次序及括弧的使用。书写要点是注意对自然语言检索条件的正确理解。</li>\n<li><code>Select Tname From Teacher Where Salary &gt; 2000 and D# = ’03’;</code>//检索教师表中所有工资大于2000元 并且是03系的教师姓名</li>\n</ul>\n</li>\n<li><p>排重(<code>DISTINCT</code>)</p>\n<ul>\n<li>关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组。</li>\n<li>在Table中要求无重复元组是通过定义Primary key或Unique来保证的;</li>\n<li>而在检索结果中要求无重复元组, 是通过<strong>DISTINCT保留字</strong>的使用来实现的。</li>\n<li><code>Select DISTINCT S# From SC Where Score &gt; 80; </code></li>\n</ul>\n</li>\n<li><p>排序(<code>ORDER BY</code>)</p>\n<ul>\n<li>Select语句中结果排序是通过增加<strong>order by</strong>子句实现的</li>\n<li><code>order by 列名 [asc|desc]</code></li>\n<li>意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。</li>\n</ul>\n</li>\n<li><p>模糊查询(<code>*LIKE*</code>)</p>\n<ul>\n<li><code>_</code>：一个字符，<code>%</code>：任意长度字符。</li>\n<li><code>Select Sname From Student Where Sname Like &#39;张_ _&#39;;</code>//检索名字为张某某的所有同学姓名</li>\n<li><code>Select Sname From Student Where Sname Not Like &#39;张%&#39;;</code>//检索名字不姓张的所有同学姓名</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id3\"><span></p>\n<h3 id=\"3-利用SQL多表联合查询\"><a href=\"#3-利用SQL多表联合查询\" class=\"headerlink\" title=\"3. 利用SQL多表联合查询\"></a>3. 利用SQL多表联合查询</h3><p>多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进行选择运算来实现。</p>\n<ul>\n<li>检索语句: <strong><code>Select 列名[[,列名] …] From 表名1,表名2,… Where 检索条件;</code></strong></li>\n<li>相当于<code>Π[列名,...,列名](σ检索条件(表名1 × 表名2 × …))</code></li>\n<li>检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种θ-连接</li>\n</ul>\n<ol>\n<li><p>θ-连接之<strong>等值连接</strong></p>\n<ul>\n<li>多表连接时，如两个表的属性名相同，则需采用**<code>表名.属性名</code>**方式来限定该属性是属于哪一个表</li>\n<li><code>Select Sname From Student, SC Where Student.S#=SC.S# and SC.C#=&#39;001&#39; Order By Score DESC;</code>//按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接)</li>\n</ul>\n</li>\n<li><p>属性重名重名处理(表别名)</p>\n<ul>\n<li>连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用**<code>别名</code>**以便区分</li>\n<li><code>Select 列名 as 列别名[[,列名 as 列别名] …] From 表名1 as 表别名1,表名2 as 表别名2,… Where Where 检索条件;</code></li>\n<li>当定义了别名后，在检索条件中可以使用别名来限定属性</li>\n<li>as 可以省略</li>\n</ul>\n</li>\n<li><p>θ-连接之<strong>不等值连接</strong></p>\n<ul>\n<li><code>Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary&gt;T2.Salary;</code>//求有薪水差额的任意两位教师</li>\n</ul>\n</li>\n<li><p>实例：</p>\n<ul>\n<li><code>Select S1.S# From SC S1, SC S2 Where S1.S# = S2.S# and S1.C#=&#39;001&#39; and S2.C#=&#39;002&#39; and S1.Score &gt; S2.Score;</code>//求“001”号课成绩比“002”号课成绩高的所有学生的学号</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id4\"><span></p>\n<h3 id=\"4-利用SQL进行增-删-改\"><a href=\"#4-利用SQL进行增-删-改\" class=\"headerlink\" title=\"4. 利用SQL进行增-删-改\"></a>4. 利用SQL进行增-删-改</h3><ol>\n<li>SQL-之<strong>更新操作</strong><ul>\n<li>元组新增Insert：新增一个或一些元组到数据库的Table中</li>\n<li>元组更新Update:对某些元组中的某些属性值进行重新设定</li>\n<li>元组删除Delete：删除某些元组</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li>SQL-DML既能单一记录操作，也能对记录集合进行批更新操作</li>\n<li>SQL-DML之更新操作需要利用前面介绍的子查询(Subquery)的概念，以便处理“一些”、“某些”等</li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li>SQL-之<strong>INSERT</strong><ul>\n<li>单一元组新增命令形式：插入一条指定元组值的元组<ul>\n<li><strong><code>insert into 表名 [(列名[,列名]…)] values (值 [,值]…);</code></strong></li>\n</ul>\n</li>\n<li>批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元组由子查询给出。<ul>\n<li><strong><code>insert into 表名 [(列名[，列名]…)] 子查询;</code></strong></li>\n<li>示例：<code>Insert Into St (S#,Sname) Select S#,Sname From Student Where Sname like &#39;%伟&#39;;</code>//将检索到的满足条件的同学新增到该表中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作。</p>\n</blockquote>\n<ol start=\"3\">\n<li><p>SQL-之<strong>DELETE</strong></p>\n<ul>\n<li>元组删除Delete命令: 删除满足指定条件的元组</li>\n<li><strong><code>Delete From 表名 [ Where 条件表达式];</code></strong></li>\n<li>如果Where条件省略，则删除所有的元组(清空表)。</li>\n<li>示例：<code>Delete From Student Where S# in ( Select S# From SC Where Score &lt; 60 Group by S# Having Count(*)&gt;= 4);</code>//删除有四门不及格课程的所有同学</li>\n</ul>\n</li>\n<li><p>SQL-之<strong>UPDATE</strong></p>\n<ul>\n<li>元组更新Update命令: 用指定要求的值更新指定表中满足指定条件的元组的指定列的值</li>\n<li><strong><code>Update 表名 Set 列名=表达式 | (子查询) [[,列名=表达式 | (子查询) ] …] [ Where 条件表达式];</code></strong></li>\n<li>如果Where条件省略，则更新所有的元组。</li>\n<li>示例：<code>Update Teacher Set Salary=Salary*1.1 Where D# in (Select D# From Dept Where Dname=&#39;计算机&#39;);</code>//将所有计算机系的教师工资上调10%</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></p>\n<h3 id=\"5-利用SQL语言修正与撤销数据库\"><a href=\"#5-利用SQL语言修正与撤销数据库\" class=\"headerlink\" title=\"5. 利用SQL语言修正与撤销数据库\"></a>5. 利用SQL语言修正与撤销数据库</h3><ol>\n<li><p>修正基本表的定义</p>\n<ul>\n<li><strong><code>alter table tablename</code></strong></li>\n<li><strong><code>[add &#123;colname datatype, …&#125;]</code></strong> //增加新列</li>\n<li><strong><code>[drop &#123;完整性约束名&#125;]</code></strong> //删除完整性约束</li>\n<li><strong><code>[modify &#123;colname datatype, …&#125;]</code></strong> //修改列定义</li>\n<li>示例：<code>Alter Table Student Drop Unique(Sname);</code>删除学生姓名必须取唯一值的约束</li>\n<li>示例：<code>Alter Table Student Add Saddr char[40],PID char[18];</code>在学生表Student上增加二列Saddr, PID</li>\n</ul>\n</li>\n<li><p>SQL-DDL之撤销与修改</p>\n<ul>\n<li><code>drop table 表名;</code> //撤消基本表</li>\n<li><code>drop database 数据库名;</code> //撤消数据库</li>\n</ul>\n</li>\n<li><p>SQL-DDL之数据库指定与关闭命令</p>\n<ul>\n<li>有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能。</li>\n<li><code>use 数据库名;</code> //指定当前数据库</li>\n<li><code>close 数据库名;</code> //关闭当前数据库</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id6\"><span></p>\n<h3 id=\"6-SQL-Server介绍\"><a href=\"#6-SQL-Server介绍\" class=\"headerlink\" title=\"6. SQL Server介绍\"></a>6. SQL Server介绍</h3><p>SQL Server 是 Microsoft提供的一款关系数据库管理系统</p>\n<ol>\n<li>SQL Server 的系统数据库<ul>\n<li>Master：是SQL Server中最重要的系统数据库，存储SQL Server中的元数据。</li>\n<li>Model：模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础。</li>\n<li>Msdb：代理服务数据库，提供一个存储空间。</li>\n<li>Tempdb：临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。</li>\n</ul>\n</li>\n<li>SQL Server的数据库<ul>\n<li>文件：有三种文件扩展名：.mdf、.ndf、.ldf<ul>\n<li>主数据库文件：扩展名为.mdf，是存储数据库的启动信息和部分或全部数据。一个数据库可以有多个数据库文件，但主数据库文件只有一个。</li>\n<li>辅助数据文件：扩展名为.ndf，用于放置主数据库文件中所定义数据库的其它数据，可有多个。在数据庞大时，可以帮助存储数据。</li>\n<li>日志文件：扩展名.ldf。每个数据库至少有一个事务日志文件。</li>\n</ul>\n</li>\n<li>页面：是SQL Server存储的最小单位。一页为8K或8192字节。</li>\n<li>空间(extent)：是8个连续的页面，即64K数据，是分配数据表存储空间的一种单位</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-SQL-Server数据库的创建-删除与维护\"><a href=\"#6-1-SQL-Server数据库的创建-删除与维护\" class=\"headerlink\" title=\"6.1 SQL Server数据库的创建-删除与维护\"></a>6.1 SQL Server数据库的创建-删除与维护</h4><ol>\n<li>创建数据库<ul>\n<li>语法形式：Create Database 库名</li>\n<li>可视化操作(查询分析器)：Database(鼠标右键) -&gt; new Database… -&gt; 填写数据库名及配置</li>\n<li>创建数据库的过程就是为数据库设计名称、设计所占用存储空间和存 放文件位置的过程。特别是在网络数据库中，对数据库的设计显得尤为重要。如估计数据可能占用的磁盘空间有多大，日志文件及其他要占用多大空间。</li>\n<li>创建数据库的用户自动成为数据库的拥有者。</li>\n</ul>\n</li>\n<li>删除数据库<ul>\n<li>语法形式：Drop Database 库名</li>\n<li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Delete</li>\n<li>对不再需要的数据库，应删除以释放空间。删除的结果将是所有数据库文件都一并被删除。</li>\n<li>当数据库处于正在使用或正在恢复状态时，不能删除。</li>\n</ul>\n</li>\n<li>备份数据库<ul>\n<li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Back Up…</li>\n<li>备份就是对数据库或事务日志进行备份。SQL的备份是动态的，备份的过程还可以让用户继续改写。只有系统管理员、数据库的拥有者及数据库的备份者才有权限进行数据备份。可以通过企业管理器进行数据库备份。<ul>\n<li>完全数据库备份：完全备份数据文件和日志文件。</li>\n<li>差异备份（增量备份）：对最近一次数据库备份以来发生的数据变化进行备份。这要在完全备份的基础上进行。特点是速度快。</li>\n<li>事务日志备份：对数据库发生的事务进行备份。包括从上次进行事务日志备份、差异备份和数据库完全备份之后，所有已经完成的事务。能尽可能的恢复最新的数据库记录。特点是所需磁盘空间小，时间少。</li>\n<li>数据库文件和文件组备份：用在数据库相当大的情况下。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>恢复数据库<ul>\n<li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Restore</li>\n<li>数据库的恢复是指将数据库备份加载到系统中的过程。在根据数据库备份文件恢复过程中，系统将自动执行安全性检查、重建数据库结构及完成填写数据库内容。</li>\n<li>数据库的恢复是静态的。所以在恢复前，应将需要恢复的数据库访问属性设为单用户，不要让其他用户操作。</li>\n<li>可以通过企业管理器来完成数据库恢复。</li>\n</ul>\n</li>\n<li>数据库授权: <ul>\n<li>语法形式：grant 权限 on 表名 to 用户名</li>\n<li>权限有：select,update,insert,delete,exec,dri。</li>\n<li>对被授权的用户，要先成为该数据库的使用者，即要把用户加到数据库里,才能授权.</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-2-SQL-Server数据表的创建-与增-删-改-查\"><a href=\"#6-2-SQL-Server数据表的创建-与增-删-改-查\" class=\"headerlink\" title=\"6.2 SQL Server数据表的创建-与增/删/改/查\"></a>6.2 SQL Server数据表的创建-与增/删/改/查</h4><ol>\n<li>创建表<ul>\n<li>同一用户不能建立同一个表名的表，同一表名的表可有多个拥有者。但在使用时，需要在这些表上加上所有者的表名。</li>\n<li>用T-SQL语句创建表，语法形式：<code>CREATE TABLE [数据库名.所有者名.]表名 (&#123;&lt;列名 数据类型&gt;&#125; [缺省值][约束][是否为空] …)</code><blockquote>\n<p>注意：T-SQL是SQL Server软件的SQL语言，与标准版有些差异。但标准版SQL，一般情况下SQL Server软件也都支持</p>\n</blockquote>\n</li>\n<li>可视化操作(查询分析器)：数据库名 -&gt; Tables -&gt; New Table…</li>\n</ul>\n</li>\n<li>增加、修改表字段<ul>\n<li>语法形式：<code>ALTER TABLE ADD | ALTER 字段名 &lt;类型&gt;</code></li>\n</ul>\n</li>\n<li>创建、删除与修改约束<ul>\n<li>约束是SQL提供自动保持数据库完整性的一种方法，共5种。</li>\n<li>用T-SQL语句建立约束，语法形式：<code>CONSTRAINT 约束名 约束类型 (列名)</code><ul>\n<li>约束名：在库中应该唯一，如不指定，系统会给出</li>\n<li>约束类型 (5种)：<ul>\n<li>primary key constraint (主键值)</li>\n<li>unique constraint (唯一性)</li>\n<li>check constraint (检查性)</li>\n<li>default constraint (默认)</li>\n<li>foreign key constraint (外部键)</li>\n</ul>\n</li>\n<li>列名：要约束的字段名</li>\n</ul>\n</li>\n<li>示例:<code>Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1), T# char(3) ) constraint pk primary key(C# ));</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id7\"><span></p>\n<h3 id=\"7-SQL语言-子查询\"><a href=\"#7-SQL语言-子查询\" class=\"headerlink\" title=\"7. SQL语言-子查询\"></a>7. SQL语言-子查询</h3><ul>\n<li>子查询：出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。</li>\n<li>三种类型的子查询：(NOT) IN-子查询；θ-Some/θ-All子查询；(NOT) EXISTS子查询</li>\n</ul>\n<h4 id=\"7-1-NOT-IN子查询\"><a href=\"#7-1-NOT-IN子查询\" class=\"headerlink\" title=\"7.1 (NOT) IN子查询\"></a>7.1 (NOT) IN子查询</h4><ol>\n<li>基本语法：<code>表达式 [not] in (子查询)</code><ul>\n<li>语法中，表达式的最简单形式就是列名或常数。</li>\n<li>语义：判断某一表达式的值是否在子查询的结果中。</li>\n<li>示例：<ul>\n<li><code>Select * From Student Where Sname in (&#39;张三&#39;, &#39;王三&#39;);</code>//列出张三、王三同学的所有信息</li>\n<li><code>Select S#, Sname From Student Where S# in (Select S# From SC Where C#=&#39;001&#39;);</code>//列出选修了001号课程的学生的学号和姓名</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询前面的子查询示例都是非相关子查询</li>\n<li>相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询</li>\n<li>外层向内层传递的参量需要使用外层的表名或表别名来限定<ul>\n<li>示例：<code>Select Sname From Student Stud Where S# in ( Select S# From SC Where S# = Stud.S# and C#=&#39;001&#39;);</code>//求学过001号课程的同学的姓名</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>注意：相关子查询只能由外层向内层传递参数，而不能反之；这也称为变量的作用域原则。</p>\n</blockquote>\n<h4 id=\"7-2-θ-Some-θ-All子查询\"><a href=\"#7-2-θ-Some-θ-All子查询\" class=\"headerlink\" title=\"7.2 θ-Some/θ-All子查询\"></a>7.2 θ-Some/θ-All子查询</h4><ol>\n<li>基本语法：<code>表达式 θ some (子查询)</code> / <code>表达式 θ all (子查询)</code><ul>\n<li>语法中，θ是比较运算符：<code>&lt;, &gt;, &gt;=, &lt;=, =, &lt;&gt;</code>。</li>\n<li>语义：将表达式的值与子查询的结果进行比较：<ul>\n<li>如果表达式的值至少与子查询结果的某一个值相比较满足 关系，则<code>表达式 θ some (子查询)</code>的结果便为真</li>\n<li>如果表达式的值与子查询结果的所有值相比较都满足 关系，则<code>表达式 θ all (子查询)</code>的结果便为真</li>\n</ul>\n</li>\n<li>示例：<ul>\n<li><code>Select Tname From Teacher Where Salary &lt;= all ( Select Salary From Teacher);</code>//找出工资最低的教师姓名</li>\n<li><code>Select S# From SC Where C# = “001” and Score &lt; some ( Select Score From SC Where C#=&#39;001&#39;);</code>//找出001号课成绩不是最高的所有学生的学号</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>在SQL标准中，也有θ-Any谓词，但由于其语义的模糊性：any,“任一”是指所有呢？还是指某一个？不清楚，所以被θ-Some替代以求更明晰。</p>\n</blockquote>\n<ol start=\"2\">\n<li>等价性变换需要注意<ul>\n<li><code>表达式 = some (子查询)</code>和<code>表达式 in (子查询)</code>含义<strong>相同</strong></li>\n<li><code>表达式 &lt;&gt; some (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>不同</strong></li>\n<li><code>表达式 &lt;&gt; all (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>相同</strong></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-3-NOT-EXISTS子查询\"><a href=\"#7-3-NOT-EXISTS子查询\" class=\"headerlink\" title=\"7.3 (NOT) EXISTS子查询\"></a>7.3 (NOT) EXISTS子查询</h4><ol>\n<li>基本语法：<code>[not] Exists [not] Exists (子查询)</code><ul>\n<li>语义：子查询结果中有无元组存在</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--示例：检索选修了赵三老师主讲课程的所有同学的姓名</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">DISTINCT</span> Sname <span class=\"keyword\">From</span> Student</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> <span class=\"keyword\">exists</span> ( <span class=\"keyword\">Select</span> <span class=\"operator\">*</span> <span class=\"keyword\">From</span> SC, Course, Teacher</span><br><span class=\"line\">        <span class=\"keyword\">Where</span> SC.C#<span class=\"operator\">=</span>Course.C# <span class=\"keyword\">and</span> SC. S#<span class=\"operator\">=</span>Student.S#</span><br><span class=\"line\">        <span class=\"keyword\">and</span> Course.T# <span class=\"operator\">=</span> Teacher.T# <span class=\"keyword\">and</span> Tname<span class=\"operator\">=</span><span class=\"string\">&#x27;赵三&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--示例：检索学过001号教师主讲的所有课程的所有同学的姓名</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> Sname <span class=\"keyword\">From</span> Student</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> <span class=\"operator\">/</span><span class=\"operator\">/</span>不存在</span><br><span class=\"line\">        ( <span class=\"keyword\">Select</span> <span class=\"operator\">*</span> <span class=\"keyword\">From</span> Course <span class=\"operator\">/</span><span class=\"operator\">/</span>有一门<span class=\"number\">001</span>教师主讲课程</span><br><span class=\"line\">        <span class=\"keyword\">Where</span> Course.T# <span class=\"operator\">=</span> ‘<span class=\"number\">001</span>’ <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> <span class=\"operator\">/</span><span class=\"operator\">/</span>该同学没学过</span><br><span class=\"line\">            ( <span class=\"keyword\">Select</span> <span class=\"operator\">*</span> <span class=\"keyword\">From</span> SC</span><br><span class=\"line\">            <span class=\"keyword\">Where</span> S# <span class=\"operator\">=</span> Student.S# <span class=\"keyword\">and</span> C# <span class=\"operator\">=</span> Course.C#));</span><br><span class=\"line\"><span class=\"comment\">--上述语句的意思：不存在有一门001号教师主讲的课程该同学没学过</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><span id=\"id8\"><span></p>\n<h3 id=\"8-SQL语言-结果计算与聚集计算\"><a href=\"#8-SQL语言-结果计算与聚集计算\" class=\"headerlink\" title=\"8. SQL语言-结果计算与聚集计算\"></a>8. SQL语言-结果计算与聚集计算</h3><h4 id=\"8-1-结果计算\"><a href=\"#8-1-结果计算\" class=\"headerlink\" title=\"8.1 结果计算\"></a>8.1 结果计算</h4><p>Select-From-Where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表明在投影的同时直接进行一些运算</p>\n<ul>\n<li><code>Select Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where Where 检索条件 ];</code><ul>\n<li>expr可以是常量、列名、或由常量、列名、特殊函数及算术运算符构成的算术运算式。特殊函数的使用需结合各自DBMS的说明书</li>\n<li>agfunc()是一些聚集函数</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--示例：求有差额(差额&gt;0)的任意两位教师的薪水差额</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> T1.Tname <span class=\"keyword\">as</span> TR1, T2.Tname <span class=\"keyword\">as</span> TR2, T1.Salary – T2.Salary</span><br><span class=\"line\">    <span class=\"keyword\">From</span> Teacher T1, Teacher T2</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> T1.Salary <span class=\"operator\">&gt;</span> T2.Salary;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"8-2-聚集函数\"><a href=\"#8-2-聚集函数\" class=\"headerlink\" title=\"8.2 聚集函数\"></a>8.2 聚集函数</h4><p>SQL提供了五个作用在简单列值集合上的内置聚集函数agfunc,分别是：COUNT、SUM、AVG、MAX、MIN</p>\n<table>\n<thead>\n<tr>\n<th>聚合函数</th>\n<th>支持的数据类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>count()</td>\n<td>任何类型/*</td>\n<td>计算结果集中的总行数</td>\n</tr>\n<tr>\n<td>sum()</td>\n<td>Numeric</td>\n<td>计算指定列中所有非空值的总和</td>\n</tr>\n<tr>\n<td>avg()</td>\n<td>numeric</td>\n<td>计算指定列中所有非空值的平均值</td>\n</tr>\n<tr>\n<td>max()</td>\n<td>char/numeric</td>\n<td>返回指定列中最大值</td>\n</tr>\n<tr>\n<td>min()</td>\n<td>char/numeric</td>\n<td>返回指定列中最小值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--示例：求教师的工资总额</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"built_in\">Sum</span>(Salary) <span class=\"keyword\">From</span> Teacher;</span><br><span class=\"line\"><span class=\"comment\">--示例：求计算机系教师的工资总额</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"built_in\">Sum</span>(Salary) <span class=\"keyword\">From</span> Teacher T, Dept</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> Dept.Dname <span class=\"operator\">=</span> ‘计算机’ <span class=\"keyword\">and</span> Dept.D# <span class=\"operator\">=</span> T.D#;</span><br><span class=\"line\"><span class=\"comment\">--示例：求数据库课程的平均成绩</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"built_in\">AVG</span>(Score) <span class=\"keyword\">From</span> Course C, SC</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> C.Cname <span class=\"operator\">=</span> ‘数据库’ <span class=\"keyword\">and</span> C.C# <span class=\"operator\">=</span> SC.C#;</span><br></pre></td></tr></table></figure>\n\n\n<p><span id=\"id9\"><span></p>\n<h3 id=\"9-SQL语言-分组查询与分组过滤\"><a href=\"#9-SQL语言-分组查询与分组过滤\" class=\"headerlink\" title=\"9. SQL语言-分组查询与分组过滤\"></a>9. SQL语言-分组查询与分组过滤</h3><h4 id=\"9-1-分组查询\"><a href=\"#9-1-分组查询\" class=\"headerlink\" title=\"9.1 分组查询\"></a>9.1 分组查询</h4><p>分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。</p>\n<ol>\n<li><p>分组的基本语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">Select</span> 列名 <span class=\"operator\">|</span> expr <span class=\"operator\">|</span> agfunc(列名) [[, 列名 <span class=\"operator\">|</span> expr <span class=\"operator\">|</span> agfunc(列名) ] … ]</span><br><span class=\"line\">    <span class=\"keyword\">From</span> 表名<span class=\"number\">1</span> [, 表名<span class=\"number\">2</span> … ]</span><br><span class=\"line\">    [ <span class=\"keyword\">Where</span> <span class=\"keyword\">Where</span> 检索条件 ]</span><br><span class=\"line\">    [ <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> 分组条件 ] ;</span><br></pre></td></tr></table></figure></li>\n<li><p>分组条件可以是：<code>列名1, 列名2, …</code></p>\n</li>\n<li><p>示例： 求每一个学生的平均成绩</p>\n<ul>\n<li><code>Select S#, AVG(Score) From SC Group by S#;</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"9-2-分组过滤\"><a href=\"#9-2-分组过滤\" class=\"headerlink\" title=\"9.2 分组过滤\"></a>9.2 分组过滤</h4><p>聚集函数是不允许用于Where子句中的：Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤</p>\n<ul>\n<li>分组过滤：若要对集合(即分组)进行条件过滤，即满足条件的集合/分组留下，不满足条件的集合/分组剔除。</li>\n<li>Having子句，又称分组过滤子句。需要有Groupby子句支持，换句话说，没有Groupby子句，便不能有Having子句。</li>\n</ul>\n<ol>\n<li><p>基本语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">Select</span> 列名 <span class=\"operator\">|</span> expr <span class=\"operator\">|</span> agfunc(列名) [[, 列名 <span class=\"operator\">|</span> expr <span class=\"operator\">|</span> agfunc(列名) ] … ]</span><br><span class=\"line\">    <span class=\"keyword\">From</span> 表名<span class=\"number\">1</span> [, 表名<span class=\"number\">2</span> … ]</span><br><span class=\"line\">    [ <span class=\"keyword\">Where</span> <span class=\"keyword\">Where</span> 检索条件 ]</span><br><span class=\"line\">    [ <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> 分组条件 [ <span class=\"keyword\">Having</span> <span class=\"keyword\">Having</span> 分组过滤条件] ] ;</span><br></pre></td></tr></table></figure></li>\n<li><p>示例：求不及格课程超过两门的同学的学号</p>\n<ul>\n<li><code>Select S# From SC Where Score&lt;60 Group by S# Having Count(*)&gt;2;</code> </li>\n</ul>\n</li>\n</ol>\n<h4 id=\"9-3-where子句与having子句的区别\"><a href=\"#9-3-where子句与having子句的区别\" class=\"headerlink\" title=\"9.3 where子句与having子句的区别\"></a>9.3 where子句与having子句的区别</h4><ol>\n<li>聚合函数是比较where、having 的关键。在from后面的执行顺序：<ul>\n<li><code>where -&gt; 聚合函数(sum,min,max,avg,count) -&gt;having</code></li>\n</ul>\n</li>\n<li>列出group by来比较二者:<ul>\n<li>where子句：是在分组之前使用，表示从所有数据中筛选出部分数据，以完成分组的要求，在where子句中不允许使用统计函数，没有group by子句也可以使用。</li>\n<li>having子句：是在分组之后使用的，表示对分组统计后的数据执行再次过滤，可以使用统计函数，有group by子句之后才可以出现having子句。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>注意事项 ： </p>\n<ol>\n<li>where 后不能跟聚合函数，因为where执行顺序大于聚合函数。 </li>\n<li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。 </li>\n<li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</li>\n</ol>\n</blockquote>\n<p><span id=\"id10\"><span></p>\n<h3 id=\"10-SQL语言实现关系代数操作\"><a href=\"#10-SQL语言实现关系代数操作\" class=\"headerlink\" title=\"10. SQL语言实现关系代数操作\"></a>10. SQL语言实现关系代数操作</h3><p>SQL语言：并运算UNION, 交运算INTERSECT, 差运算EXCEPT。</p>\n<ul>\n<li>基本语法形式：<ul>\n<li><code>子查询 &#123;Union [ALL] | Intersect [ALL] | Except [ALL] 子查询&#125;</code></li>\n</ul>\n</li>\n<li>通常情况下自动删除重复元组：不带ALL。若要保留重复的元组，则要带ALL。<ul>\n<li>假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在：<ul>\n<li>子查询1 Union ALL 子查询2 ，出现m + n次</li>\n<li>子查询1 Intersect ALL 子查询2 ，出现min(m,n)次</li>\n<li>子查询1 Except ALL 子查询2 ，出现max(0, m – n)次</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>UNION运算符是Entry-SQL92的一部分, INTERSECT、EXCEPT运算符是Full-SQL92的一部分,它们都是Core-SQL99的一部分，但<strong>有些DBMS并不支持</strong>这些运算，使用时要注意。</p>\n</blockquote>\n<h4 id=\"10-1-SQL并运算-UNION\"><a href=\"#10-1-SQL并运算-UNION\" class=\"headerlink\" title=\"10.1 SQL并运算(UNION)\"></a>10.1 SQL并运算(UNION)</h4><ol>\n<li>示例：已知两个表<ul>\n<li>Customers(Cid, Cname, City, Discnt)</li>\n<li>Agents(Aid, Aname, City, Percent)</li>\n</ul>\n</li>\n<li>求客户所在的或者代理商所在的城市<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> City <span class=\"keyword\">From</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> City <span class=\"keyword\">From</span> Agents;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"10-2-SQL交运算-INTERSECT\"><a href=\"#10-2-SQL交运算-INTERSECT\" class=\"headerlink\" title=\"10.2 SQL交运算(INTERSECT)\"></a>10.2 SQL交运算(INTERSECT)</h4><ol>\n<li><p>示例：求既学过002号课，又学过003号课的同学学号</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# <span class=\"operator\">=</span> ‘<span class=\"number\">002</span>’</span><br><span class=\"line\"><span class=\"keyword\">INTERSECT</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# <span class=\"operator\">=</span> ‘<span class=\"number\">003</span>’;</span><br></pre></td></tr></table></figure></li>\n<li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p>\n<ul>\n<li><code>Select S# From SC Where C# = ‘002’ and S# IN (Select S# From SC Where C# = ‘003’);</code></li>\n</ul>\n</li>\n<li><p>交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也可以用其他方式表达同样的查询需求。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。</p>\n</li>\n</ol>\n<h4 id=\"10-3-SQL差运算-EXCEPT\"><a href=\"#10-3-SQL差运算-EXCEPT\" class=\"headerlink\" title=\"10.3 SQL差运算(EXCEPT)\"></a>10.3 SQL差运算(EXCEPT)</h4><ol>\n<li><p>示例： 假定所有学生都有选课，求没学过002号课程的学生学号</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">DISTINCT</span> S# <span class=\"keyword\">From</span> SC</span><br><span class=\"line\"><span class=\"keyword\">EXCEPT</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# <span class=\"operator\">=</span> ‘<span class=\"number\">002</span>’;</span><br></pre></td></tr></table></figure></li>\n<li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">DISTINCT</span> S# <span class=\"keyword\">From</span> SC SC1</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> ( <span class=\"keyword\">Select</span> <span class=\"operator\">*</span> <span class=\"keyword\">From</span> SC</span><br><span class=\"line\">        <span class=\"keyword\">Where</span> C# <span class=\"operator\">=</span> ‘<span class=\"number\">002</span>’ <span class=\"keyword\">and</span> S# <span class=\"operator\">=</span> SC1.S#);</span><br></pre></td></tr></table></figure></li>\n<li><p>差运算符Except也没有增强SQL的表达能力，没有Except， SQL也可以用其他方式表达同样的查询需求。只是有了Except更容易表达一些，但增加了SQL语言的不唯一性。</p>\n</li>\n</ol>\n<h4 id=\"10-4-空值的处理\"><a href=\"#10-4-空值的处理\" class=\"headerlink\" title=\"10.4 空值的处理\"></a>10.4 空值的处理</h4><p>空值是其值不知道、不确定、不存在的值；数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等</p>\n<ol>\n<li>在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来标记，使用特殊的空值检测函数来获得某列的值是否为空值。</li>\n<li>空值检测：<ul>\n<li><code>is [not ] null</code> //测试指定列的值是否为空值</li>\n</ul>\n</li>\n<li>示例：找出年龄值为空的学生姓名<ul>\n<li><code>Select Sname From Student Where Sage is null;</code></li>\n</ul>\n</li>\n<li>现行DBMS的空值处理小结<ul>\n<li>除is[not]null之外，空值不满足任何查找条件</li>\n<li>如果null参与算术运算，则该算术表达式的值为null</li>\n<li>如果null参与比较运算，则结果可视为false。在SQL-92中可看成unknown</li>\n<li>如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"10-5-内连接、外连接\"><a href=\"#10-5-内连接、外连接\" class=\"headerlink\" title=\"10.5 内连接、外连接\"></a>10.5 内连接、外连接</h4><ol>\n<li>标准SQL语言中连接运算通常为：<ul>\n<li><code>Select Select 列名[[,列名]… ] From 表名1,表名2,… Where 检索条件;</code></li>\n<li>即相当于采用<code>Π[列名,…,列名](σ 检索条件(表名1 × 表名2 × …))</code>。</li>\n</ul>\n</li>\n<li>SQL的高级语法中引入了内连接与外连接运算，具体形式：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">Select</span> 列名 [ [, 列名] … ]</span><br><span class=\"line\">    <span class=\"keyword\">From</span> 表名<span class=\"number\">1</span> [<span class=\"keyword\">NATURAL</span>]</span><br><span class=\"line\">    [ <span class=\"keyword\">INNER</span> <span class=\"operator\">|</span> &#123; <span class=\"keyword\">LEFT</span> <span class=\"operator\">|</span> <span class=\"keyword\">RIGHT</span> <span class=\"operator\">|</span> <span class=\"keyword\">FULL</span>&#125; [<span class=\"keyword\">OUTER</span>]] <span class=\"keyword\">JOIN</span> 表名<span class=\"number\">2</span></span><br><span class=\"line\">    &#123; <span class=\"keyword\">ON</span> 连接条件 <span class=\"operator\">|</span> <span class=\"keyword\">Using</span> (Colname &#123;, Colname …&#125;) &#125;</span><br><span class=\"line\">    [ <span class=\"keyword\">Where</span> <span class=\"keyword\">Where</span> 检索条件 ] … ;</span><br></pre></td></tr></table></figure></li>\n<li>由 <strong>连接类型</strong> 和 <strong>连接条件</strong> 构成连接运算。<ul>\n<li>**<code>Natural</code>**：出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次</li>\n<li><strong><code>Inner Join</code></strong>: 即关系代数中的θ-连接运算</li>\n<li><strong><code>Left Outer Join, Right Outer Join, Full Outer Join</code></strong>: 即关系代数中的外连接运算</li>\n<li>**<code>on &lt;连接条件&gt;</code>**：出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次</li>\n<li>**<code>using (Col1, Col2, …, Coln)</code>**：Col是两个连接关系的公共属性的子集，元组在(Col1,Col2,…,Coln)上取值相等，且(Col1,Col2,…,Coln)只出现一次</li>\n</ul>\n</li>\n<li>示例:</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- (Inner Join)求所有教师的任课情况并按教师号排序(没有任课的教师也需列在表中)</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> Teacher.T#, Tname, Cname</span><br><span class=\"line\">    <span class=\"keyword\">From</span> Teacher <span class=\"keyword\">Inner</span> <span class=\"keyword\">Join</span> Course</span><br><span class=\"line\">        <span class=\"keyword\">ON</span> Teacher.T# <span class=\"operator\">=</span> Course.T#</span><br><span class=\"line\">    <span class=\"keyword\">Order</span> <span class=\"keyword\">by</span> Teacher.T# <span class=\"keyword\">ASC</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--(Outer Join)求所有教师的任课情况(没有任课的教师也需列在表中)</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> Teacher. T#, Tname, Cname</span><br><span class=\"line\">    <span class=\"keyword\">From</span> Teacher <span class=\"keyword\">Left</span> <span class=\"keyword\">Outer</span> <span class=\"keyword\">Join</span> Course</span><br><span class=\"line\">        <span class=\"keyword\">ON</span> Teacher.T# <span class=\"operator\">=</span> Course.T#</span><br><span class=\"line\">    <span class=\"keyword\">Order</span> <span class=\"keyword\">by</span> Teacher.T# <span class=\"keyword\">ASC</span> ;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><span id=\"id11\"><span></p>\n<h3 id=\"11-SQL语言之视图及其应用\"><a href=\"#11-SQL语言之视图及其应用\" class=\"headerlink\" title=\"11. SQL语言之视图及其应用\"></a>11. SQL语言之视图及其应用</h3><ol>\n<li>数据库的三级模式两层映像<ul>\n<li>三级模式：数据库系统是由外模式、模式(概念模式)和内模式三级构成</li>\n<li>应用–&gt; <strong>外模式</strong>(多个) –&gt; <strong>概念模式</strong>(一个) –&gt; <strong>内模式</strong>(一个) –&gt; 数据库</li>\n<li>两层映像：<code>E-C</code>映像(外模式-&gt;概念模式)、<code>C-I</code>映像(概念模式-&gt;内模式)。</li>\n</ul>\n</li>\n<li>对应概念模式的数据在SQL中被称为<strong>基本表(Table)</strong>,而对应外模式的数据称为<strong>视图(View)<strong>。</strong>视图不仅包含外模式，而且包含其E-C映像</strong>。</li>\n<li><strong>基本表</strong>是实际存储于存储文件中的表，基本表中的<strong>数据是需要存储的</strong></li>\n<li><strong>视图</strong>在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，其<strong>数据并不存储</strong>，而是在运行过程中动态产生与维护的</li>\n<li>对视图数据的更改最终要反映在对基本表的更改上。</li>\n</ol>\n<h4 id=\"11-1-视图的定义\"><a href=\"#11-1-视图的定义\" class=\"headerlink\" title=\"11.1 视图的定义\"></a>11.1 视图的定义</h4><p>视图需要“先定义，再使用”；定义视图，有时可方便用户进行检索操作。</p>\n<ol>\n<li>定义视图: <code>create view view_name [(列名[列名] …)] as 子查询 [with check option]</code><ul>\n<li>如果视图的属性名缺省，则默认为子查询结果中的属性名；也可以显式指明其所拥有的列名。</li>\n<li>with checkoption指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式</li>\n</ul>\n</li>\n<li>示例：定义一个视图 CompStud 为计算机系的学生，通过该视图可以将Student表中其他系的学生屏蔽掉<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">View</span> CompStud <span class=\"keyword\">AS</span></span><br><span class=\"line\">    (<span class=\"keyword\">Select</span> <span class=\"operator\">*</span> <span class=\"keyword\">From</span> Student</span><br><span class=\"line\">        <span class=\"keyword\">Where</span> D# <span class=\"keyword\">in</span> (<span class=\"keyword\">Select</span> D# <span class=\"keyword\">From</span> Dept</span><br><span class=\"line\">            <span class=\"keyword\">Where</span> Dname <span class=\"operator\">=</span> ‘计算机’));</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"11-2-视图的使用\"><a href=\"#11-2-视图的使用\" class=\"headerlink\" title=\"11.2 视图的使用\"></a>11.2 视图的使用</h4><p>使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用</p>\n<ul>\n<li>示例：检索计算机系的所有学生，我们可使用CompStud<ul>\n<li><code>Select * From CompStud;</code></li>\n</ul>\n</li>\n<li>示例：检索计算机系的年龄小于20的所有学生，我们可使用CompStud<ul>\n<li><code>Select * From CompStud Where Sage&lt;20;</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-3-视图的更新\"><a href=\"#11-3-视图的更新\" class=\"headerlink\" title=\"11.3 视图的更新\"></a>11.3 视图的更新</h4><p>SQL视图更新：是比较复杂的问题，因视图不保存数据，对视图的更新最终要反映到对基本表的更新上，而有时，视图定义的映射不是可逆的。</p>\n<ol>\n<li>SQL视图更新的可执行性<ul>\n<li>如果视图的select目标列包含聚集函数，则不能更新</li>\n<li>如果视图的select子句使用了unique或distinct，则不能更新</li>\n<li>如果视图中包括了groupby子句，则不能更新</li>\n<li>如果视图中包括经算术表达式计算出来的列，则不能更新</li>\n<li>如果视图是由单个表的列构成，但并没有包括主键，则不能更新</li>\n</ul>\n</li>\n<li>对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主键，则可以更新</li>\n<li>可更新SQL视图示例：</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 定义视图</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> CStud(S#, Sname, Sclass)</span><br><span class=\"line\"><span class=\"keyword\">as</span> ( <span class=\"keyword\">select</span> S#, Sname, Sclass <span class=\"keyword\">from</span> Student <span class=\"keyword\">where</span> D# <span class=\"operator\">=</span><span class=\"string\">&#x27;03&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 更新视图</span></span><br><span class=\"line\"><span class=\"keyword\">Insert</span> <span class=\"keyword\">into</span> CStud <span class=\"keyword\">Values</span> (<span class=\"string\">&#x27;98030104&#x27;</span>, <span class=\"string\">&#x27;张三丰&#x27;</span>, <span class=\"string\">&#x27;980301&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 更新视图 将转换为 更新基本表</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;98030104&#x27;</span>, <span class=\"string\">&#x27;张三丰&#x27;</span>, <span class=\"keyword\">Null</span>, <span class=\"keyword\">Null</span>, <span class=\"string\">&#x27;03&#x27;</span>, <span class=\"string\">&#x27;980301&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-4-视图的撤销\"><a href=\"#11-4-视图的撤销\" class=\"headerlink\" title=\"11.4 视图的撤销\"></a>11.4 视图的撤销</h4><p>已经定义的视图也可以撤消</p>\n<ul>\n<li>撤消视图：<code>Drop View view_name</code></li>\n</ul>\n<p>不仅视图可以撤消，基本表、数据库等都可以撤消</p>\n<ul>\n<li>撤消基本表：<code>Drop Table 表名</code></li>\n</ul>\n<p><span id=\"id12\"><span></p>\n<h3 id=\"12-数据库完整性\"><a href=\"#12-数据库完整性\" class=\"headerlink\" title=\"12. 数据库完整性\"></a>12. 数据库完整性</h3><p>数据库完整性(DB Integrity)是指：DBMS应保证的DB的一种特性–在任何情况下的正确性、有效性和一致性</p>\n<ul>\n<li>广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等</li>\n<li>狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题。</li>\n</ul>\n<h4 id=\"12-1-基本概念\"><a href=\"#12-1-基本概念\" class=\"headerlink\" title=\"12.1 基本概念\"></a>12.1 基本概念</h4><p>关系模型中有完整性要求：实体完整性、参照完整性、用户自定义完整性</p>\n<ol>\n<li>数据库完整性管理的作用<ul>\n<li>防止和避免数据库中不合理数据的出现</li>\n<li>DBMS应尽可能地自动防止DB中语义不合理现象</li>\n<li>如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担</li>\n</ul>\n</li>\n<li>DBMS怎样自动保证完整性：<ul>\n<li>DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义)</li>\n<li>当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性</li>\n</ul>\n</li>\n<li><strong>完整性约束条件</strong>(或称完整性约束规则)的一般形式：Integrity Constraint::=(O,P,A,R)<ul>\n<li>O：数据集合：约束的对象(列、多列(元组)、元组集合)</li>\n<li>P：谓词条件：需要定义什么样的约束</li>\n<li>A：触发条件：默认更新时检查</li>\n<li>R：响应动作：默认拒绝</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"12-2-数据库完整性的分类\"><a href=\"#12-2-数据库完整性的分类\" class=\"headerlink\" title=\"12.2 数据库完整性的分类\"></a>12.2 数据库完整性的分类</h4><ol>\n<li><p>按约束对象分类:</p>\n<ul>\n<li>域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的</li>\n<li>关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断</li>\n</ul>\n</li>\n<li><p>按约束来源分类:</p>\n<ul>\n<li>结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等；</li>\n<li>内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等。</li>\n</ul>\n</li>\n<li><p>按约束状态分类:</p>\n<ul>\n<li>静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。</li>\n<li>动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id13\"><span></p>\n<h3 id=\"13-数据库的静态完整性-约束\"><a href=\"#13-数据库的静态完整性-约束\" class=\"headerlink\" title=\"13. 数据库的静态完整性(约束)\"></a>13. 数据库的静态完整性(约束)</h3><ol>\n<li><p>SQL语言支持的约束类别：</p>\n<ul>\n<li>静态约束<ul>\n<li>列完整性—域完整性约束</li>\n<li>表完整性–关系完整性约束</li>\n</ul>\n</li>\n<li>动态约束<ul>\n<li>触发器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CreateTable有三种功能：定义关系模式、定义完整性约束 和定义物理存储特性</p>\n<ul>\n<li>定义完整性约束条件：列完整性、表完整性</li>\n</ul>\n</li>\n<li><p>列约束：一种<strong>域约束类型</strong>，对单一列的值进行约束</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>                  <span class=\"operator\">/</span><span class=\"operator\">/</span>列值非空</span><br><span class=\"line\">[ <span class=\"keyword\">CONSTRAINT</span> constraintname ] <span class=\"operator\">/</span><span class=\"operator\">/</span>为约束命名，便于以后撤消</span><br><span class=\"line\">&#123; <span class=\"keyword\">UNIQUE</span>                      <span class=\"operator\">/</span><span class=\"operator\">/</span>列值是唯一</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">PRIMARY</span> KEY                 <span class=\"operator\">/</span><span class=\"operator\">/</span>列为主键</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">CHECK</span> (search_cond)         <span class=\"operator\">/</span><span class=\"operator\">/</span>列值满足条件,条件只能使用列当前值</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">REFERENCES</span> tablename [(colname) ]</span><br><span class=\"line\">[<span class=\"keyword\">ON</span> <span class=\"keyword\">DELETE</span> &#123; CASCADE <span class=\"operator\">|</span> <span class=\"keyword\">SET</span> <span class=\"keyword\">NULL</span> &#125; ] &#125; &#125; </span><br></pre></td></tr></table></figure></li>\n<li><p>表约束：一种<strong>关系约束类型</strong>，对多列或元组的值进行约束</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ <span class=\"keyword\">CONSTRAINT</span> constraintname ]       <span class=\"operator\">/</span><span class=\"operator\">/</span>为约束命名，便于以后撤消</span><br><span class=\"line\">&#123; <span class=\"keyword\">UNIQUE</span> (colname &#123;,colname…&#125;)      <span class=\"operator\">/</span><span class=\"operator\">/</span>几列值组合在一起是唯一</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">PRIMARY</span> KEY (colname &#123;,colname…&#125;) <span class=\"operator\">/</span><span class=\"operator\">/</span>几列联合为主键</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">CHECK</span> (search_condition)          <span class=\"operator\">/</span><span class=\"operator\">/</span>元组多列值共同满足条件</span><br><span class=\"line\">                                    <span class=\"operator\">/</span><span class=\"operator\">/</span>条件中只能使用同一元组的不同列当前值</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">FOREIGN</span> KEY (colname &#123;,colname…&#125;)</span><br><span class=\"line\"><span class=\"keyword\">REFERENCES</span> tablename [(colname &#123;,colname…&#125;)]<span class=\"operator\">/</span><span class=\"operator\">/</span>引用另一表tablename的若干列的值作为外键</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。</p>\n</blockquote>\n</li>\n<li><p>Create Table中定义的表约束或列约束可以在以后根据需要进行撤消或追加。撤消或追加约束的语句是 Alter Table(不同系统可能有差异)</p>\n<ul>\n<li>示例：撤消SC表的ctscore约束(由此可见，未命名的约束是不能撤消)<ul>\n<li><code>Alter Table SC DROP CONSTRAINT ctscore;</code></li>\n</ul>\n</li>\n<li>有些DBMS支持独立的追加约束,注意书写格式可能有些差异<ul>\n<li>示例：<code>Alter Table SC Add Constraint nctscore check (Score&gt;=0.0 and Score&lt;=150.0));</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>现约束的方法-断言ASSERTION</p>\n<ul>\n<li>一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件</li>\n<li>表约束和列约束就是一些特殊的断言</li>\n<li>SQL还提供了复杂条件表达的断言。其语法形式为：<ul>\n<li><code>CREATE ASSERTION &lt;assertion-name&gt; CHECK &lt;predicate&gt;</code></li>\n</ul>\n</li>\n<li>当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是否违反该断言。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 示例: “每个分行的贷款总量必须小于该分行所有账户的余额总和”</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> assertion sum_constraint <span class=\"keyword\">check</span></span><br><span class=\"line\">    (<span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> branch</span><br><span class=\"line\">    <span class=\"keyword\">where</span> (<span class=\"keyword\">select</span> <span class=\"built_in\">sum</span>(amount ) <span class=\"keyword\">from</span> loan</span><br><span class=\"line\">        <span class=\"keyword\">where</span> loan.branch_name <span class=\"operator\">=</span> branch.branch_name )</span><br><span class=\"line\">    <span class=\"operator\">&gt;=</span> (<span class=\"keyword\">select</span> <span class=\"built_in\">sum</span> (balance ) <span class=\"keyword\">from</span> account</span><br><span class=\"line\">        <span class=\"keyword\">where</span> account.branch_name <span class=\"operator\">=</span> branch.branch_name )))</span><br><span class=\"line\"><span class=\"comment\">-- 数据表：</span></span><br><span class=\"line\">account(branch_name, account_number,…, balance) <span class=\"operator\">/</span><span class=\"operator\">/</span>分行，账户及其余额</span><br><span class=\"line\">loan(branch_name , loan_number, amount,) <span class=\"operator\">/</span><span class=\"operator\">/</span>分行的每一笔贷款</span><br><span class=\"line\">branch(branch_name, … ) <span class=\"operator\">/</span><span class=\"operator\">/</span>分行</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>断言测试增加了数据库维护的负担，要小心使用复杂的断言。</p>\n</blockquote>\n<p><span id=\"id14\"><span></p>\n<h3 id=\"14-数据库的动态完整性-触发器\"><a href=\"#14-数据库的动态完整性-触发器\" class=\"headerlink\" title=\"14. 数据库的动态完整性(触发器)\"></a>14. 数据库的动态完整性(触发器)</h3><p>实现数据库动态完整的方法—触发器Trigger</p>\n<ol>\n<li><p>触发器Trigger</p>\n<ul>\n<li>Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger</li>\n<li>Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。</li>\n</ul>\n</li>\n<li><p>基本语法</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> trigger_name BEFORE <span class=\"operator\">|</span> AFTER</span><br><span class=\"line\">    &#123; <span class=\"keyword\">INSERT</span> <span class=\"operator\">|</span> <span class=\"keyword\">DELETE</span> <span class=\"operator\">|</span> UPDATE [<span class=\"keyword\">OF</span> colname &#123;, colname...&#125;] &#125;</span><br><span class=\"line\">    <span class=\"keyword\">ON</span> tablename [<span class=\"keyword\">REFERENCING</span> corr_name_def &#123;, corr_name_def...&#125; ]</span><br><span class=\"line\">    [<span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"type\">ROW</span> <span class=\"operator\">|</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> STATEMENT]</span><br><span class=\"line\">                <span class=\"operator\">/</span><span class=\"operator\">/</span>对更新操作的每一条结果(前者)，或整个更新操作完成(后者)</span><br><span class=\"line\">    [<span class=\"keyword\">WHEN</span> (search_condition)]           <span class=\"operator\">/</span><span class=\"operator\">/</span>检查条件，如满足执行下述程序</span><br><span class=\"line\">    &#123; statement         <span class=\"operator\">/</span><span class=\"operator\">/</span>单行程序直接书写，多行程序要用下行方式</span><br><span class=\"line\">    <span class=\"operator\">|</span> <span class=\"keyword\">BEGIN</span> <span class=\"keyword\">ATOMIC</span> statement; &#123; statement;...&#125; <span class=\"keyword\">END</span> &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>触发器Trigger意义：</p>\n<ul>\n<li>当某一事件发生时(Before|After),对该事件产生的结果(或是每一元组，或是整个操作的所有元组), 检查条件<code>search_condition</code>,如果满足条件，则执行后面的程序段。条件或程序段中引用的变量可用<code>corr_name_def</code>来限定。</li>\n</ul>\n</li>\n<li><p>事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}</p>\n<ul>\n<li>当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后After触发</li>\n<li>操作发生，执行触发器操作需处理两组值：更新前的值和更新后的值，这两个值由<code>corr_name_def</code>的使用来区分</li>\n</ul>\n</li>\n<li><p><code>corr_name_def</code>的定义</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"keyword\">OLD</span> [<span class=\"type\">ROW</span>] [<span class=\"keyword\">AS</span>] old_row_corr_name <span class=\"operator\">/</span><span class=\"operator\">/</span>更新前的旧元组命别名为</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">NEW</span> [<span class=\"type\">ROW</span>] [<span class=\"keyword\">AS</span>] new_row_corr_name <span class=\"operator\">/</span><span class=\"operator\">/</span>更新后的新元组命别名为</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">OLD</span> <span class=\"keyword\">TABLE</span> [<span class=\"keyword\">AS</span>] old_table_corr_name <span class=\"operator\">/</span><span class=\"operator\">/</span>更新前的旧<span class=\"keyword\">Table</span>命别名为</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">NEW</span> <span class=\"keyword\">TABLE</span> [<span class=\"keyword\">AS</span>] new_table_corr_name <span class=\"operator\">/</span><span class=\"operator\">/</span>更新后的新<span class=\"keyword\">Table</span>命别名为</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>corr_name_def</code>将在检测条件或后面的动作程序段中被引用处理</p>\n</blockquote>\n</li>\n<li><p>示例1: 设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> teacher_chgsal before update <span class=\"keyword\">of</span> salary</span><br><span class=\"line\">    <span class=\"keyword\">on</span> teacher</span><br><span class=\"line\">    <span class=\"keyword\">referencing</span> <span class=\"keyword\">new</span> x, <span class=\"keyword\">old</span> y</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span> <span class=\"keyword\">when</span> (x.salary <span class=\"operator\">&lt;</span> y.salary)</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">    raise_application_error(<span class=\"number\">-20003</span>, <span class=\"string\">&#x27;invalid salary on update&#x27;</span>);</span><br><span class=\"line\">    <span class=\"operator\">/</span><span class=\"operator\">/</span>此条语句为Oracle的错误处理函数</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>示例2: 假设student(S#, Sname, SumCourse), SumCourse为该同学已学习课程的门数，初始值为0，以后每选修一门都要对其增1 。设计一个触发器自动完成上述功能。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> sumc after <span class=\"keyword\">insert</span> <span class=\"keyword\">on</span> sc</span><br><span class=\"line\">    <span class=\"keyword\">referencing</span> <span class=\"keyword\">new</span> <span class=\"type\">row</span> newi</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">    update student <span class=\"keyword\">set</span> SumCourse <span class=\"operator\">=</span> SumCourse <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">where</span> S# <span class=\"operator\">=</span> :newi.S# ;</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>示例3：假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。设计一个触发器完成上述功能</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> delS# after <span class=\"keyword\">delete</span> <span class=\"keyword\">on</span> Student</span><br><span class=\"line\">    <span class=\"keyword\">referencing</span> <span class=\"keyword\">old</span> oldi</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> sc <span class=\"keyword\">where</span> S# <span class=\"operator\">=</span> :oldi.S# ;</span><br><span class=\"line\"><span class=\"keyword\">end</span>; </span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><span id=\"id15\"><span></p>\n<h3 id=\"15-数据库索引\"><a href=\"#15-数据库索引\" class=\"headerlink\" title=\"15. 数据库索引\"></a>15. 数据库索引</h3><p>索引是对数据库表中一列或多列的值进行排序的一种<strong>数据结构</strong>（最常见的是B-Tree）</p>\n<ol>\n<li>索引的作用<ol>\n<li>快速取数据；</li>\n<li>保证数据记录的唯一性；</li>\n<li>实现表与表之间的参照完整性；</li>\n<li>在使用ORDER by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。</li>\n</ol>\n</li>\n<li>创建索引：<code>CREATE INDEX  索引名称  on 表名(字段名);</code></li>\n<li>删除索引：<code>DROP INDEX 索引名称</code></li>\n<li>索引注意事项：<ol>\n<li>查询时减少使用<code>*</code>返回全部列，不要返回不需要的列</li>\n<li>where表达式子句包含索引的表达式置前</li>\n<li>避免在Order by中使用表达式</li>\n<li>索引技术是数据库自动使用，一个表格只存在一个索引就够了</li>\n</ol>\n</li>\n<li>缺点<ol>\n<li>索引的缺点是创建和维护索引需要耗费时间和空间</li>\n<li>索引可以提高查询速度，会减慢写入速度</li>\n<li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"15-1-索引主要种类\"><a href=\"#15-1-索引主要种类\" class=\"headerlink\" title=\"15.1 索引主要种类\"></a>15.1 索引主要种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</p>\n<ol>\n<li>唯一索引<ul>\n<li>唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</li>\n</ul>\n</li>\n<li>主键索引<ul>\n<li>数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</li>\n</ul>\n</li>\n<li>聚集索引<ul>\n<li>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</li>\n</ul>\n</li>\n<li>索引列<ul>\n<li>可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id16\"><span></p>\n<h3 id=\"16-数据库序列\"><a href=\"#16-数据库序列\" class=\"headerlink\" title=\"16. 数据库序列\"></a>16. 数据库序列</h3><p>序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。创建序列需要<code>CREATE SEQUENCE</code>系统权限。</p>\n<h4 id=\"16-1-Oracle中的序列（Sequence）\"><a href=\"#16-1-Oracle中的序列（Sequence）\" class=\"headerlink\" title=\"16.1 Oracle中的序列（Sequence）\"></a>16.1 Oracle中的序列（Sequence）</h4><ol>\n<li><p>创建序列</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> sequence 序列名 </span><br><span class=\"line\">    [increment <span class=\"keyword\">by</span> n]   <span class=\"comment\">--每次增加n个，默认为1</span></span><br><span class=\"line\">    [<span class=\"keyword\">start</span> <span class=\"keyword\">with</span> n]     <span class=\"comment\">--起始值n，默认为1</span></span><br><span class=\"line\">    [&#123;maxvalue n <span class=\"operator\">|</span> nomaxvalue&#125;]  <span class=\"comment\">--最大值设置，递增默认10的27次方，递减默认-1</span></span><br><span class=\"line\">    [&#123;minvalue n <span class=\"operator\">|</span> nominvalue&#125;]  <span class=\"comment\">--最小值设置，递增默认1，递减默认-10的26次方</span></span><br><span class=\"line\">    [&#123;<span class=\"keyword\">cycle</span> <span class=\"operator\">|</span> nocycle&#125;]   <span class=\"comment\">--是否循环</span></span><br><span class=\"line\">    [&#123;cache n <span class=\"operator\">|</span> nocache&#125;] <span class=\"comment\">--是否对序列进行内存缓冲，默认为20</span></span><br></pre></td></tr></table></figure></li>\n<li><p>查询序列</p>\n<ul>\n<li><code>NEXTVAL</code>:返回序列中下一个有效的值，任何用户都可以引用。</li>\n<li><code>CURRVAL</code>:中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--查询下一个将要使用的序列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> 序列名.nextval <span class=\"keyword\">from</span> dual</span><br><span class=\"line\"><span class=\"comment\">--查询当前序列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> 序列名.currval <span class=\"keyword\">from</span> dual </span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>Oracle将sequence的定义存储在数据字典之中。</li>\n<li>Sequence是独立于事务的，就是说序列的增加不需要等待事务的完成，也就是说序列是异步于事务而增长的。这说明，你访问不到别的用户使用该sequence产生的值，也就是说你只能访问到你当前产生的值，即使其他用户已经增加了sequence的值；还说明如果事务回滚，sequence不会回滚，它所发生的改变是一维的。</li>\n</ul>\n</blockquote>\n<ol start=\"3\">\n<li>删除序列：<code>Drop sequence 序列名</code></li>\n<li>更改序列：<code>Alter sequence 序列名 [其余参数同创建序列]</code></li>\n<li>使用序列示例：</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 1.直接使用</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> person (id, name, password) <span class=\"keyword\">values</span> (序列名.nextval, <span class=\"string\">&#x27;张三&#x27;</span>, <span class=\"string\">&#x27;123&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 2.也可以通过建立触发器，当有数据插入表person时，使用oracle序列为其去的递增的主键值</span></span><br><span class=\"line\"><span class=\"comment\">-- 2.1创建触发器</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">or</span> replace <span class=\"keyword\">trigger</span> 触发器名 before <span class=\"keyword\">insert</span> <span class=\"keyword\">on</span> person</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> 序列名.nextval <span class=\"keyword\">into</span> :new.id <span class=\"keyword\">from</span> dual;</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 2.2插入数据</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> person ( username, age, password) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;张三&#x27;</span>, <span class=\"number\">20</span>, <span class=\"string\">&#x27;zhang123&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>注意点：<ul>\n<li>一个序列可以被多张别使用，不过一般建议为每个表建立单独的序列。</li>\n<li>当使用到序列的事务发生回滚。会造成序列号不连续。在用生成的序列值作为编号做插入数据库操作时，可能遇到事务提交失败，从而导致序号不连续。</li>\n<li>大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 n个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数最好不要设置过大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入n个。这种情况也能会在数据库关闭时也会导致序号不连续。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"16-2-Mysql中的序列（AUTO-INCREMENT）\"><a href=\"#16-2-Mysql中的序列（AUTO-INCREMENT）\" class=\"headerlink\" title=\"16.2 Mysql中的序列（AUTO_INCREMENT）\"></a>16.2 Mysql中的序列（AUTO_INCREMENT）</h4><p>MySQL中最简单使用序列的方法就是使用<code>AUTO_INCREMENT</code>来定义列。</p>\n<ol>\n<li>orale没有类似mysql的AUTO_INCREMENT这样的自增长字段，实现插入一条记录，自动增加1.oracle是通过sequence（序列）来完成的。</li>\n<li>首先mysql的自增长“序列”和序列是两回事，mysql本身不提供序列机制。</li>\n<li>mysql的AUTO_INCREMENT可以设置起始值，但是不能设置步长，其步长默认就是1.</li>\n<li>mysql一个表只能有一个自增长字段。自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。并且只能是数字型。</li>\n</ol>\n<p><span id=\"id17\"><span></p>\n<h3 id=\"17-数据库安全性\"><a href=\"#17-数据库安全性\" class=\"headerlink\" title=\"17. 数据库安全性\"></a>17. 数据库安全性</h3><p>数据库安全性是指DBMS应该保证的数据库的一种特性(机制或手段)：免受非法、非授权用户的使用、泄漏、更改或破坏</p>\n<ol>\n<li>数据库安全性管理涉及许多方面<ol>\n<li>社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法</li>\n<li>公共政策/制度方面：例如，政府或组织的信息公开或非公开制度</li>\n<li>安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略)</li>\n<li>数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)</li>\n<li>数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制</li>\n</ol>\n</li>\n<li>DBMS的安全机制<ol>\n<li><strong>自主安全性机制</strong>：存取控制(AccessControl)<ul>\n<li>通过权限在用户之间的传递，使用户自主管理数据库安全性</li>\n</ul>\n</li>\n<li><strong>强制安全性机制</strong>：<ul>\n<li>通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据</li>\n</ul>\n</li>\n<li>推断控制机制：<ul>\n<li>防止通过历史信息，推断出不该被其知道的信息；</li>\n<li>防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要</li>\n</ul>\n</li>\n<li>数据加密存储机制：<ul>\n<li>通过加密、解密保护数据，密钥、加密/解密方法与传输</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>DBA的责任和义务<ul>\n<li>熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略</li>\n<li>规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应，</li>\n<li><strong>划分好数据的安全级别以及用户的安全级别</strong></li>\n<li>实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id18\"><span></p>\n<h3 id=\"18-数据库自主安全性机制\"><a href=\"#18-数据库自主安全性机制\" class=\"headerlink\" title=\"18. 数据库自主安全性机制\"></a>18. 数据库自主安全性机制</h3><ul>\n<li>通常情况下，自主安全性是通过授权机制来实现的。</li>\n<li>用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。<ul>\n<li>授权者：决定用户权利的人</li>\n<li>授权：授予用户访问的权利</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>DBMS自动实现自主安全性：<ul>\n<li>DBMS允许用户定义一些安全性控制规则(用SQL-DCL来定义)</li>\n<li>当有DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许访问</li>\n</ul>\n</li>\n<li>DBMS将权利和用户(账户)结合在一起，形成一个访问规则表，依据该规则表可以实现对数据库的安全性控制<ul>\n<li><code>AccessRule ::=(S, O, t, P)</code><ul>\n<li>S: 请求主体(用户)</li>\n<li>O: 访问对象</li>\n<li>t: 访问权利</li>\n<li>P: 谓词</li>\n</ul>\n</li>\n<li>{AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利;</li>\n<li>用户多时，可以按用户组建立访问规则</li>\n<li>访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库</li>\n<li>权利：包括创建、增、删、改、查等</li>\n<li>谓词：拥有权利需满足的条件</li>\n</ul>\n</li>\n<li><strong>示例</strong>：员工管理数据库的安全性控制示例<code>Employee(P#,Pname,Page,Psex,Psalary,D#,HEAD)</code><ul>\n<li>示例要求：<ul>\n<li>员工管理人员：能访问该数据库的所有内容，便于维护员工信息</li>\n<li>收发人员：访问该数据库以确认某员工是哪一个部门的，便于收发工作，只能访问基本信息，其他信息不允许其访问</li>\n<li>每个员工：允许其访问关于自己的记录，以便查询自己的工资情况，但不能修改</li>\n<li>部门领导：能够查询其所领导部门人员的所有情况</li>\n<li>高层领导：能访问该数据库的所有内容，但只能读</li>\n</ul>\n</li>\n<li>两种控制示例<ul>\n<li>按名控制安全性：存储矩阵</li>\n<li>按内容控制安全性：视图</li>\n</ul>\n</li>\n<li>视图是安全性控制的重要手段</li>\n<li>通过视图可以限制用户对关系中某些数据项的存取,例如：<ul>\n<li>视图1：CreateEmpV1as select*fromEmployee</li>\n<li>视图2：CreateEmpV2as selectPname,D#fromEmployee</li>\n</ul>\n</li>\n<li>通过视图可将数据访问对象与谓词结合起来，限制用户对关系中某些元组的存取，例如：<ul>\n<li>视图1： CreateEmpV3asselect*fromEmployeewhereP#=:UserId</li>\n<li>视图2： CreateEmpV4asselect*fromEmployeewhereHead=:UserId</li>\n</ul>\n</li>\n<li>用户定义视图后，视图便成为一新的数据对象，参与到存储矩阵与能力表中进行描述</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"18-1-SQL语言的用户与权利\"><a href=\"#18-1-SQL语言的用户与权利\" class=\"headerlink\" title=\"18.1 SQL语言的用户与权利\"></a>18.1 SQL语言的用户与权利</h4><ol>\n<li><p>SQL语言包含了DDL,DML和DCL。数据库安全性控制是属于DCL范畴</p>\n</li>\n<li><p>授权机制—自主安全性；视图的运用</p>\n</li>\n<li><p>关系级别(普通用户) &lt;– 账户级别(程序员用户) &lt;– 超级用户(DBA) </p>\n<ul>\n<li>(级别1)Select : 读(读DB, Table, Record, Attribute, … )</li>\n<li>(级别2)Modify : 更新<ul>\n<li>Insert : 插入(插入新元组, … )</li>\n<li>Update : 更新(更新元组中的某些值, …)</li>\n<li>Delete : 删除(删除元组, …)</li>\n</ul>\n</li>\n<li>(级别3)Create : 创建(创建表空间、模式、表、索引、视图等)<ul>\n<li>Create : 创建</li>\n<li>Alter : 更新</li>\n<li>Drop : 删除</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为账户级别的权利，而将级别1和2称为关系级别的权利。</p>\n</li>\n<li><p>授权命令<code>GRANT</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> &#123;<span class=\"keyword\">all</span> PRIVILEGES <span class=\"operator\">|</span> privilege &#123;,privilege…&#125;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">ON</span> [<span class=\"keyword\">TABLE</span>] tablename <span class=\"operator\">|</span> viewname</span><br><span class=\"line\">    <span class=\"keyword\">TO</span> &#123;public <span class=\"operator\">|</span> <span class=\"keyword\">user</span><span class=\"operator\">-</span>id &#123;, <span class=\"keyword\">user</span><span class=\"operator\">-</span>id…&#125;&#125;</span><br><span class=\"line\">    [<span class=\"keyword\">WITH</span> <span class=\"keyword\">GRANT</span> OPTION];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>user-id ，某一个用户账户，由DBA创建的合法账户</li>\n<li>public, 允许所有有效用户使用授予的权利</li>\n<li>privilege是下面的权利<ul>\n<li>SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES</li>\n</ul>\n</li>\n<li>WITH GRANT OPTION选项是允许被授权者传播这些权利</li>\n</ul>\n</li>\n<li><p>SQL-DCL的控制安全性-授权示例:</p>\n<ul>\n<li>假定高级领导为Emp0001, 部门领导为Emp0021, 员工管理员为Emp2001,收发员为Emp5001(均为UserId, 也即员工的P#)<ul>\n<li>Grant All Priviledges ON Employee TO Emp2001;</li>\n<li>Grant SELECT ON EmpV2 TO Emp5001;</li>\n<li>Grant SELECT ON EmpV3 TO public;</li>\n<li>Grant SELECT ON EmpV4 TO Emp0021;</li>\n</ul>\n</li>\n<li>授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别)</li>\n<li>授权者授予的权利必须是授权者已经拥有的权利</li>\n</ul>\n</li>\n<li><p>收回授权命令<code>REVOKE</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">REVOKE</span> &#123;<span class=\"keyword\">all</span> privilEges <span class=\"operator\">|</span> priv &#123;, priv…&#125; &#125; </span><br><span class=\"line\">    <span class=\"keyword\">ON</span> tablename <span class=\"operator\">|</span> viewname</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> &#123;public <span class=\"operator\">|</span> <span class=\"keyword\">user</span> &#123;, <span class=\"keyword\">user</span>…&#125; &#125;; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>示例: <code>revoke select on employee from UserB;</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"18-2-自主安全性的授权过程及其问题\"><a href=\"#18-2-自主安全性的授权过程及其问题\" class=\"headerlink\" title=\"18.2 自主安全性的授权过程及其问题\"></a>18.2 自主安全性的授权过程及其问题</h4><h5 id=\"18-2-1-授权过程\"><a href=\"#18-2-1-授权过程\" class=\"headerlink\" title=\"18.2.1 授权过程:\"></a>18.2.1 授权过程:</h5><ol>\n<li>第一步：DBA创建DB, 并为每一个用户创建一个账户<ul>\n<li>假定建立了五个用户：UserA, UserB, UserC, UserD, UserE</li>\n</ul>\n</li>\n<li>第二步：DBA授予某用户账户级别的权利<ul>\n<li>假定授予UserA</li>\n</ul>\n</li>\n<li>第三步：具有账户级别的用户可以创建基本表或视图, 他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问 权利<ul>\n<li>假定UserA创建了Employee, 则UserA就是Employee表的属主账户</li>\n</ul>\n</li>\n<li>第四步：拥有属主账户的用户可以将其中的一部分权利授予另外的用户，该用户也可将权利进一步授给其他的用户…<ul>\n<li>假定UserA将读权限授予UserB, 而userB又将其拥有的权限授予UserC,如此将权利不断传递下去。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>注意授权的传播范围<ul>\n<li>传播范围包括两个方面：水平传播数量和垂直传播数量<ul>\n<li>水平传播数量是授权者的再授权用户数目(树的广度)</li>\n<li>垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权者, …传播的深度(树的深度)</li>\n</ul>\n</li>\n<li>有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。</li>\n<li>当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回</li>\n<li>如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当UserB收回时，其还将保持UserE赋予其的权利。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"18-2-2-强制安全性机制\"><a href=\"#18-2-2-强制安全性机制\" class=\"headerlink\" title=\"18.2.2 强制安全性机制\"></a>18.2.2 强制安全性机制</h5><ol>\n<li>强制安全性机制<ul>\n<li>强制安全性通过对数据对象进行安全性分级<ul>\n<li>绝密(Top Secret), 机密(Secret), 可信(Confidential) 和 无分类(Unclassified)</li>\n</ul>\n</li>\n<li>同时对用户也进行上述的安全性分级</li>\n<li>从而强制实现不同级别用户访问不同级别数据的一种机制</li>\n</ul>\n</li>\n<li>强制安全性机制的实现<ul>\n<li>DBMS引入强制安全性机制, 可以通过扩展关系模式来实现<ul>\n<li>关系模式: R(A1: D1, A2: D2, …, An:Dn)</li>\n<li>对属性和元组引入安全性分级特性或称分类特性<ul>\n<li>R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>这样, 关系中的每个元组, 都将扩展为带有安全分级的元组</li>\n<li>强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"<h3 id=\"SQL语言概述\"><a href=\"#SQL语言概述\" class=\"headerlink\" title=\"SQL语言概述\"></a>SQL语言概述</h3><p><strong>结构化查询语言</strong>(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p>\n<ul>\n<li>SQL语言是集DDL、DML和DCL于一体的数据库语言","more":"<ol>\n<li><strong>DDL语句</strong>引导词：Create(建立),Alter(修改),Drop(撤消)<ul>\n<li>模式的定义和删除，包括定义Database,Table,View,Index,完整性约束条件等，也包括定义对象(RowType行对象,Type列对象)</li>\n</ul>\n</li>\n<li><strong>DML语句</strong>引导词：Insert ,Delete, Update, Select<ul>\n<li>各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入</li>\n<li>各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等</li>\n<li>各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等</li>\n</ul>\n</li>\n<li><strong>DCL语句</strong>引导词：Grant,Revoke<ul>\n<li>安全性控制：授权和撤消授权</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h4><ol>\n<li><a href=\"#id1\">利用SQL建立数据库</a></li>\n<li><a href=\"#id2\">利用SQL简单查询</a></li>\n<li><a href=\"#id3\">利用SQL多表联合查询</a></li>\n<li><a href=\"#id4\">利用SQL进行增-删-改</a></li>\n<li><a href=\"#id5\">利用SQL语言修正与撤销数据库</a></li>\n<li><a href=\"#id6\">SQL Server介绍</a></li>\n<li><a href=\"#id7\">SQL语言-子查询</a></li>\n<li><a href=\"#id8\">SQL语言-结果计算与聚集计算</a></li>\n<li><a href=\"#id9\">SQL语言-分组查询与分组过滤</a></li>\n<li><a href=\"#id10\">SQL语言实现关系代数操作</a></li>\n<li><a href=\"#id11\">SQL语言之视图及其应用</a></li>\n<li><a href=\"#id12\">数据库完整性</a></li>\n<li><a href=\"#id13\">数据库的静态完整性(约束)</a></li>\n<li><a href=\"#id14\">数据库的动态完整性(触发器)</a></li>\n<li><a href=\"#id15\">数据库索引</a></li>\n<li><a href=\"#id16\">数据库序列</a></li>\n<li><a href=\"#id17\">数据库安全性</a></li>\n<li><a href=\"#id18\">数据库自主安全性机制</a></li>\n</ol>\n<p><span id=\"id1\"><span></p>\n<h3 id=\"1-利用SQL建立数据库\"><a href=\"#1-利用SQL建立数据库\" class=\"headerlink\" title=\"1. 利用SQL建立数据库\"></a>1. 利用SQL建立数据库</h3><p>DDL：数据定义语言（Data Definition Language)，<br>DDL通常由**DBA(数据库管理员)**来使用，也有经DBA授权后由应用程序员来使用</p>\n<ol>\n<li>创建数据库(DB)：<strong>Create Database</strong><ul>\n<li>数据库(Database)是若干具有相互关联关系的Table/Relation的集合</li>\n<li>简单语法形式：<code>create database database 数据库名;</code></li>\n</ul>\n</li>\n<li>创建DB中的Table(定义关系模式)：<strong>Create Table</strong><ul>\n<li><code>Create table 表名(列名 数据类型 [Primary key|Unique] [Not null][,列名 数据类型 [Not null], …]);</code><ul>\n<li><code>[]</code>表示其括起的内容可以省略，<code>|</code>表示其隔开的两项可取其一</li>\n<li><code>Primary key</code>: 主键约束。每个表只能创建一个主键约束</li>\n<li><code>Unique</code>: 唯一性约束(即候选键)。可以有多个唯一性约束</li>\n<li><code>Not null</code>: 非空约束。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>数据类型</strong>（SQL-92标准）<ul>\n<li><code>char(n)</code>:固定长度的字符串</li>\n<li><code>varchar(n)</code>:可变长字符串</li>\n<li><code>int</code>:整数 //有时不同系统也写作integer</li>\n<li><code>numeric(p，q)</code>:固定精度数字，小数点左边p位，右边(p-q)位</li>\n<li><code>real</code>:浮点精度数字 //有时不同系统也写作<code>float(n)</code>，小数点后保留n位</li>\n<li><code>date</code>:日期 (如 2003-09-12)</li>\n<li><code>time</code>:时间 (如 23:15:003)<blockquote>\n<p>注意: 现行商用DBMS的数据类型有时有些差异</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id2\"><span></p>\n<h3 id=\"2-利用SQL简单查询\"><a href=\"#2-利用SQL简单查询\" class=\"headerlink\" title=\"2. 利用SQL简单查询\"></a>2. 利用SQL简单查询</h3><p>DML：数据操纵语言（Data Manipulation Language)，<br>DML通常由<strong>用户或应用程序员</strong>使用，访问经授权的数据库</p>\n<ol>\n<li><p>向Table中添加数据(追加元组)：<strong>Insert into</strong></p>\n<ul>\n<li><strong><code>insert into insert into 表名[(列名[, 列名] …] values (值[,值], …);</code></strong><ul>\n<li>values值的排列，须与列名排列一致</li>\n<li>若所有列名省略，则values值的排列须与该表存储中的列名排列一致</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>单表查询<strong>Select</strong></p>\n<ul>\n<li><strong><code>Select Select 列名[[,列名] …] From 表名[Where 检索条件];</code></strong><ul>\n<li>语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示。</li>\n<li>相当于：<code>Π[列名,...,列名](σ检索条件(表名))</code></li>\n</ul>\n</li>\n<li>Select语句中的select … , from… , where…, 等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。</li>\n</ul>\n</li>\n<li><p>检索条件的书写<strong>Where</strong></p>\n<ul>\n<li>与选择运算<code>σF(R)</code>的条件F书写一样，只是其逻辑运算符用 and,or,not 来表示, 同时也要注意运算符的优先次序及括弧的使用。书写要点是注意对自然语言检索条件的正确理解。</li>\n<li><code>Select Tname From Teacher Where Salary &gt; 2000 and D# = ’03’;</code>//检索教师表中所有工资大于2000元 并且是03系的教师姓名</li>\n</ul>\n</li>\n<li><p>排重(<code>DISTINCT</code>)</p>\n<ul>\n<li>关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组。</li>\n<li>在Table中要求无重复元组是通过定义Primary key或Unique来保证的;</li>\n<li>而在检索结果中要求无重复元组, 是通过<strong>DISTINCT保留字</strong>的使用来实现的。</li>\n<li><code>Select DISTINCT S# From SC Where Score &gt; 80; </code></li>\n</ul>\n</li>\n<li><p>排序(<code>ORDER BY</code>)</p>\n<ul>\n<li>Select语句中结果排序是通过增加<strong>order by</strong>子句实现的</li>\n<li><code>order by 列名 [asc|desc]</code></li>\n<li>意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。</li>\n</ul>\n</li>\n<li><p>模糊查询(<code>*LIKE*</code>)</p>\n<ul>\n<li><code>_</code>：一个字符，<code>%</code>：任意长度字符。</li>\n<li><code>Select Sname From Student Where Sname Like &#39;张_ _&#39;;</code>//检索名字为张某某的所有同学姓名</li>\n<li><code>Select Sname From Student Where Sname Not Like &#39;张%&#39;;</code>//检索名字不姓张的所有同学姓名</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id3\"><span></p>\n<h3 id=\"3-利用SQL多表联合查询\"><a href=\"#3-利用SQL多表联合查询\" class=\"headerlink\" title=\"3. 利用SQL多表联合查询\"></a>3. 利用SQL多表联合查询</h3><p>多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进行选择运算来实现。</p>\n<ul>\n<li>检索语句: <strong><code>Select 列名[[,列名] …] From 表名1,表名2,… Where 检索条件;</code></strong></li>\n<li>相当于<code>Π[列名,...,列名](σ检索条件(表名1 × 表名2 × …))</code></li>\n<li>检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种θ-连接</li>\n</ul>\n<ol>\n<li><p>θ-连接之<strong>等值连接</strong></p>\n<ul>\n<li>多表连接时，如两个表的属性名相同，则需采用**<code>表名.属性名</code>**方式来限定该属性是属于哪一个表</li>\n<li><code>Select Sname From Student, SC Where Student.S#=SC.S# and SC.C#=&#39;001&#39; Order By Score DESC;</code>//按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接)</li>\n</ul>\n</li>\n<li><p>属性重名重名处理(表别名)</p>\n<ul>\n<li>连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用**<code>别名</code>**以便区分</li>\n<li><code>Select 列名 as 列别名[[,列名 as 列别名] …] From 表名1 as 表别名1,表名2 as 表别名2,… Where Where 检索条件;</code></li>\n<li>当定义了别名后，在检索条件中可以使用别名来限定属性</li>\n<li>as 可以省略</li>\n</ul>\n</li>\n<li><p>θ-连接之<strong>不等值连接</strong></p>\n<ul>\n<li><code>Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary&gt;T2.Salary;</code>//求有薪水差额的任意两位教师</li>\n</ul>\n</li>\n<li><p>实例：</p>\n<ul>\n<li><code>Select S1.S# From SC S1, SC S2 Where S1.S# = S2.S# and S1.C#=&#39;001&#39; and S2.C#=&#39;002&#39; and S1.Score &gt; S2.Score;</code>//求“001”号课成绩比“002”号课成绩高的所有学生的学号</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id4\"><span></p>\n<h3 id=\"4-利用SQL进行增-删-改\"><a href=\"#4-利用SQL进行增-删-改\" class=\"headerlink\" title=\"4. 利用SQL进行增-删-改\"></a>4. 利用SQL进行增-删-改</h3><ol>\n<li>SQL-之<strong>更新操作</strong><ul>\n<li>元组新增Insert：新增一个或一些元组到数据库的Table中</li>\n<li>元组更新Update:对某些元组中的某些属性值进行重新设定</li>\n<li>元组删除Delete：删除某些元组</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li>SQL-DML既能单一记录操作，也能对记录集合进行批更新操作</li>\n<li>SQL-DML之更新操作需要利用前面介绍的子查询(Subquery)的概念，以便处理“一些”、“某些”等</li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li>SQL-之<strong>INSERT</strong><ul>\n<li>单一元组新增命令形式：插入一条指定元组值的元组<ul>\n<li><strong><code>insert into 表名 [(列名[,列名]…)] values (值 [,值]…);</code></strong></li>\n</ul>\n</li>\n<li>批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元组由子查询给出。<ul>\n<li><strong><code>insert into 表名 [(列名[，列名]…)] 子查询;</code></strong></li>\n<li>示例：<code>Insert Into St (S#,Sname) Select S#,Sname From Student Where Sname like &#39;%伟&#39;;</code>//将检索到的满足条件的同学新增到该表中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作。</p>\n</blockquote>\n<ol start=\"3\">\n<li><p>SQL-之<strong>DELETE</strong></p>\n<ul>\n<li>元组删除Delete命令: 删除满足指定条件的元组</li>\n<li><strong><code>Delete From 表名 [ Where 条件表达式];</code></strong></li>\n<li>如果Where条件省略，则删除所有的元组(清空表)。</li>\n<li>示例：<code>Delete From Student Where S# in ( Select S# From SC Where Score &lt; 60 Group by S# Having Count(*)&gt;= 4);</code>//删除有四门不及格课程的所有同学</li>\n</ul>\n</li>\n<li><p>SQL-之<strong>UPDATE</strong></p>\n<ul>\n<li>元组更新Update命令: 用指定要求的值更新指定表中满足指定条件的元组的指定列的值</li>\n<li><strong><code>Update 表名 Set 列名=表达式 | (子查询) [[,列名=表达式 | (子查询) ] …] [ Where 条件表达式];</code></strong></li>\n<li>如果Where条件省略，则更新所有的元组。</li>\n<li>示例：<code>Update Teacher Set Salary=Salary*1.1 Where D# in (Select D# From Dept Where Dname=&#39;计算机&#39;);</code>//将所有计算机系的教师工资上调10%</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></p>\n<h3 id=\"5-利用SQL语言修正与撤销数据库\"><a href=\"#5-利用SQL语言修正与撤销数据库\" class=\"headerlink\" title=\"5. 利用SQL语言修正与撤销数据库\"></a>5. 利用SQL语言修正与撤销数据库</h3><ol>\n<li><p>修正基本表的定义</p>\n<ul>\n<li><strong><code>alter table tablename</code></strong></li>\n<li><strong><code>[add &#123;colname datatype, …&#125;]</code></strong> //增加新列</li>\n<li><strong><code>[drop &#123;完整性约束名&#125;]</code></strong> //删除完整性约束</li>\n<li><strong><code>[modify &#123;colname datatype, …&#125;]</code></strong> //修改列定义</li>\n<li>示例：<code>Alter Table Student Drop Unique(Sname);</code>删除学生姓名必须取唯一值的约束</li>\n<li>示例：<code>Alter Table Student Add Saddr char[40],PID char[18];</code>在学生表Student上增加二列Saddr, PID</li>\n</ul>\n</li>\n<li><p>SQL-DDL之撤销与修改</p>\n<ul>\n<li><code>drop table 表名;</code> //撤消基本表</li>\n<li><code>drop database 数据库名;</code> //撤消数据库</li>\n</ul>\n</li>\n<li><p>SQL-DDL之数据库指定与关闭命令</p>\n<ul>\n<li>有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能。</li>\n<li><code>use 数据库名;</code> //指定当前数据库</li>\n<li><code>close 数据库名;</code> //关闭当前数据库</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id6\"><span></p>\n<h3 id=\"6-SQL-Server介绍\"><a href=\"#6-SQL-Server介绍\" class=\"headerlink\" title=\"6. SQL Server介绍\"></a>6. SQL Server介绍</h3><p>SQL Server 是 Microsoft提供的一款关系数据库管理系统</p>\n<ol>\n<li>SQL Server 的系统数据库<ul>\n<li>Master：是SQL Server中最重要的系统数据库，存储SQL Server中的元数据。</li>\n<li>Model：模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础。</li>\n<li>Msdb：代理服务数据库，提供一个存储空间。</li>\n<li>Tempdb：临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。</li>\n</ul>\n</li>\n<li>SQL Server的数据库<ul>\n<li>文件：有三种文件扩展名：.mdf、.ndf、.ldf<ul>\n<li>主数据库文件：扩展名为.mdf，是存储数据库的启动信息和部分或全部数据。一个数据库可以有多个数据库文件，但主数据库文件只有一个。</li>\n<li>辅助数据文件：扩展名为.ndf，用于放置主数据库文件中所定义数据库的其它数据，可有多个。在数据庞大时，可以帮助存储数据。</li>\n<li>日志文件：扩展名.ldf。每个数据库至少有一个事务日志文件。</li>\n</ul>\n</li>\n<li>页面：是SQL Server存储的最小单位。一页为8K或8192字节。</li>\n<li>空间(extent)：是8个连续的页面，即64K数据，是分配数据表存储空间的一种单位</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-SQL-Server数据库的创建-删除与维护\"><a href=\"#6-1-SQL-Server数据库的创建-删除与维护\" class=\"headerlink\" title=\"6.1 SQL Server数据库的创建-删除与维护\"></a>6.1 SQL Server数据库的创建-删除与维护</h4><ol>\n<li>创建数据库<ul>\n<li>语法形式：Create Database 库名</li>\n<li>可视化操作(查询分析器)：Database(鼠标右键) -&gt; new Database… -&gt; 填写数据库名及配置</li>\n<li>创建数据库的过程就是为数据库设计名称、设计所占用存储空间和存 放文件位置的过程。特别是在网络数据库中，对数据库的设计显得尤为重要。如估计数据可能占用的磁盘空间有多大，日志文件及其他要占用多大空间。</li>\n<li>创建数据库的用户自动成为数据库的拥有者。</li>\n</ul>\n</li>\n<li>删除数据库<ul>\n<li>语法形式：Drop Database 库名</li>\n<li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Delete</li>\n<li>对不再需要的数据库，应删除以释放空间。删除的结果将是所有数据库文件都一并被删除。</li>\n<li>当数据库处于正在使用或正在恢复状态时，不能删除。</li>\n</ul>\n</li>\n<li>备份数据库<ul>\n<li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Back Up…</li>\n<li>备份就是对数据库或事务日志进行备份。SQL的备份是动态的，备份的过程还可以让用户继续改写。只有系统管理员、数据库的拥有者及数据库的备份者才有权限进行数据备份。可以通过企业管理器进行数据库备份。<ul>\n<li>完全数据库备份：完全备份数据文件和日志文件。</li>\n<li>差异备份（增量备份）：对最近一次数据库备份以来发生的数据变化进行备份。这要在完全备份的基础上进行。特点是速度快。</li>\n<li>事务日志备份：对数据库发生的事务进行备份。包括从上次进行事务日志备份、差异备份和数据库完全备份之后，所有已经完成的事务。能尽可能的恢复最新的数据库记录。特点是所需磁盘空间小，时间少。</li>\n<li>数据库文件和文件组备份：用在数据库相当大的情况下。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>恢复数据库<ul>\n<li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Restore</li>\n<li>数据库的恢复是指将数据库备份加载到系统中的过程。在根据数据库备份文件恢复过程中，系统将自动执行安全性检查、重建数据库结构及完成填写数据库内容。</li>\n<li>数据库的恢复是静态的。所以在恢复前，应将需要恢复的数据库访问属性设为单用户，不要让其他用户操作。</li>\n<li>可以通过企业管理器来完成数据库恢复。</li>\n</ul>\n</li>\n<li>数据库授权: <ul>\n<li>语法形式：grant 权限 on 表名 to 用户名</li>\n<li>权限有：select,update,insert,delete,exec,dri。</li>\n<li>对被授权的用户，要先成为该数据库的使用者，即要把用户加到数据库里,才能授权.</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-2-SQL-Server数据表的创建-与增-删-改-查\"><a href=\"#6-2-SQL-Server数据表的创建-与增-删-改-查\" class=\"headerlink\" title=\"6.2 SQL Server数据表的创建-与增/删/改/查\"></a>6.2 SQL Server数据表的创建-与增/删/改/查</h4><ol>\n<li>创建表<ul>\n<li>同一用户不能建立同一个表名的表，同一表名的表可有多个拥有者。但在使用时，需要在这些表上加上所有者的表名。</li>\n<li>用T-SQL语句创建表，语法形式：<code>CREATE TABLE [数据库名.所有者名.]表名 (&#123;&lt;列名 数据类型&gt;&#125; [缺省值][约束][是否为空] …)</code><blockquote>\n<p>注意：T-SQL是SQL Server软件的SQL语言，与标准版有些差异。但标准版SQL，一般情况下SQL Server软件也都支持</p>\n</blockquote>\n</li>\n<li>可视化操作(查询分析器)：数据库名 -&gt; Tables -&gt; New Table…</li>\n</ul>\n</li>\n<li>增加、修改表字段<ul>\n<li>语法形式：<code>ALTER TABLE ADD | ALTER 字段名 &lt;类型&gt;</code></li>\n</ul>\n</li>\n<li>创建、删除与修改约束<ul>\n<li>约束是SQL提供自动保持数据库完整性的一种方法，共5种。</li>\n<li>用T-SQL语句建立约束，语法形式：<code>CONSTRAINT 约束名 约束类型 (列名)</code><ul>\n<li>约束名：在库中应该唯一，如不指定，系统会给出</li>\n<li>约束类型 (5种)：<ul>\n<li>primary key constraint (主键值)</li>\n<li>unique constraint (唯一性)</li>\n<li>check constraint (检查性)</li>\n<li>default constraint (默认)</li>\n<li>foreign key constraint (外部键)</li>\n</ul>\n</li>\n<li>列名：要约束的字段名</li>\n</ul>\n</li>\n<li>示例:<code>Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1), T# char(3) ) constraint pk primary key(C# ));</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id7\"><span></p>\n<h3 id=\"7-SQL语言-子查询\"><a href=\"#7-SQL语言-子查询\" class=\"headerlink\" title=\"7. SQL语言-子查询\"></a>7. SQL语言-子查询</h3><ul>\n<li>子查询：出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。</li>\n<li>三种类型的子查询：(NOT) IN-子查询；θ-Some/θ-All子查询；(NOT) EXISTS子查询</li>\n</ul>\n<h4 id=\"7-1-NOT-IN子查询\"><a href=\"#7-1-NOT-IN子查询\" class=\"headerlink\" title=\"7.1 (NOT) IN子查询\"></a>7.1 (NOT) IN子查询</h4><ol>\n<li>基本语法：<code>表达式 [not] in (子查询)</code><ul>\n<li>语法中，表达式的最简单形式就是列名或常数。</li>\n<li>语义：判断某一表达式的值是否在子查询的结果中。</li>\n<li>示例：<ul>\n<li><code>Select * From Student Where Sname in (&#39;张三&#39;, &#39;王三&#39;);</code>//列出张三、王三同学的所有信息</li>\n<li><code>Select S#, Sname From Student Where S# in (Select S# From SC Where C#=&#39;001&#39;);</code>//列出选修了001号课程的学生的学号和姓名</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询前面的子查询示例都是非相关子查询</li>\n<li>相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询</li>\n<li>外层向内层传递的参量需要使用外层的表名或表别名来限定<ul>\n<li>示例：<code>Select Sname From Student Stud Where S# in ( Select S# From SC Where S# = Stud.S# and C#=&#39;001&#39;);</code>//求学过001号课程的同学的姓名</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>注意：相关子查询只能由外层向内层传递参数，而不能反之；这也称为变量的作用域原则。</p>\n</blockquote>\n<h4 id=\"7-2-θ-Some-θ-All子查询\"><a href=\"#7-2-θ-Some-θ-All子查询\" class=\"headerlink\" title=\"7.2 θ-Some/θ-All子查询\"></a>7.2 θ-Some/θ-All子查询</h4><ol>\n<li>基本语法：<code>表达式 θ some (子查询)</code> / <code>表达式 θ all (子查询)</code><ul>\n<li>语法中，θ是比较运算符：<code>&lt;, &gt;, &gt;=, &lt;=, =, &lt;&gt;</code>。</li>\n<li>语义：将表达式的值与子查询的结果进行比较：<ul>\n<li>如果表达式的值至少与子查询结果的某一个值相比较满足 关系，则<code>表达式 θ some (子查询)</code>的结果便为真</li>\n<li>如果表达式的值与子查询结果的所有值相比较都满足 关系，则<code>表达式 θ all (子查询)</code>的结果便为真</li>\n</ul>\n</li>\n<li>示例：<ul>\n<li><code>Select Tname From Teacher Where Salary &lt;= all ( Select Salary From Teacher);</code>//找出工资最低的教师姓名</li>\n<li><code>Select S# From SC Where C# = “001” and Score &lt; some ( Select Score From SC Where C#=&#39;001&#39;);</code>//找出001号课成绩不是最高的所有学生的学号</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>在SQL标准中，也有θ-Any谓词，但由于其语义的模糊性：any,“任一”是指所有呢？还是指某一个？不清楚，所以被θ-Some替代以求更明晰。</p>\n</blockquote>\n<ol start=\"2\">\n<li>等价性变换需要注意<ul>\n<li><code>表达式 = some (子查询)</code>和<code>表达式 in (子查询)</code>含义<strong>相同</strong></li>\n<li><code>表达式 &lt;&gt; some (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>不同</strong></li>\n<li><code>表达式 &lt;&gt; all (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>相同</strong></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-3-NOT-EXISTS子查询\"><a href=\"#7-3-NOT-EXISTS子查询\" class=\"headerlink\" title=\"7.3 (NOT) EXISTS子查询\"></a>7.3 (NOT) EXISTS子查询</h4><ol>\n<li>基本语法：<code>[not] Exists [not] Exists (子查询)</code><ul>\n<li>语义：子查询结果中有无元组存在</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--示例：检索选修了赵三老师主讲课程的所有同学的姓名</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">DISTINCT</span> Sname <span class=\"keyword\">From</span> Student</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> <span class=\"keyword\">exists</span> ( <span class=\"keyword\">Select</span> <span class=\"operator\">*</span> <span class=\"keyword\">From</span> SC, Course, Teacher</span><br><span class=\"line\">        <span class=\"keyword\">Where</span> SC.C#<span class=\"operator\">=</span>Course.C# <span class=\"keyword\">and</span> SC. S#<span class=\"operator\">=</span>Student.S#</span><br><span class=\"line\">        <span class=\"keyword\">and</span> Course.T# <span class=\"operator\">=</span> Teacher.T# <span class=\"keyword\">and</span> Tname<span class=\"operator\">=</span><span class=\"string\">&#x27;赵三&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--示例：检索学过001号教师主讲的所有课程的所有同学的姓名</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> Sname <span class=\"keyword\">From</span> Student</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> <span class=\"operator\">/</span><span class=\"operator\">/</span>不存在</span><br><span class=\"line\">        ( <span class=\"keyword\">Select</span> <span class=\"operator\">*</span> <span class=\"keyword\">From</span> Course <span class=\"operator\">/</span><span class=\"operator\">/</span>有一门<span class=\"number\">001</span>教师主讲课程</span><br><span class=\"line\">        <span class=\"keyword\">Where</span> Course.T# <span class=\"operator\">=</span> ‘<span class=\"number\">001</span>’ <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> <span class=\"operator\">/</span><span class=\"operator\">/</span>该同学没学过</span><br><span class=\"line\">            ( <span class=\"keyword\">Select</span> <span class=\"operator\">*</span> <span class=\"keyword\">From</span> SC</span><br><span class=\"line\">            <span class=\"keyword\">Where</span> S# <span class=\"operator\">=</span> Student.S# <span class=\"keyword\">and</span> C# <span class=\"operator\">=</span> Course.C#));</span><br><span class=\"line\"><span class=\"comment\">--上述语句的意思：不存在有一门001号教师主讲的课程该同学没学过</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><span id=\"id8\"><span></p>\n<h3 id=\"8-SQL语言-结果计算与聚集计算\"><a href=\"#8-SQL语言-结果计算与聚集计算\" class=\"headerlink\" title=\"8. SQL语言-结果计算与聚集计算\"></a>8. SQL语言-结果计算与聚集计算</h3><h4 id=\"8-1-结果计算\"><a href=\"#8-1-结果计算\" class=\"headerlink\" title=\"8.1 结果计算\"></a>8.1 结果计算</h4><p>Select-From-Where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表明在投影的同时直接进行一些运算</p>\n<ul>\n<li><code>Select Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where Where 检索条件 ];</code><ul>\n<li>expr可以是常量、列名、或由常量、列名、特殊函数及算术运算符构成的算术运算式。特殊函数的使用需结合各自DBMS的说明书</li>\n<li>agfunc()是一些聚集函数</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--示例：求有差额(差额&gt;0)的任意两位教师的薪水差额</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> T1.Tname <span class=\"keyword\">as</span> TR1, T2.Tname <span class=\"keyword\">as</span> TR2, T1.Salary – T2.Salary</span><br><span class=\"line\">    <span class=\"keyword\">From</span> Teacher T1, Teacher T2</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> T1.Salary <span class=\"operator\">&gt;</span> T2.Salary;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"8-2-聚集函数\"><a href=\"#8-2-聚集函数\" class=\"headerlink\" title=\"8.2 聚集函数\"></a>8.2 聚集函数</h4><p>SQL提供了五个作用在简单列值集合上的内置聚集函数agfunc,分别是：COUNT、SUM、AVG、MAX、MIN</p>\n<table>\n<thead>\n<tr>\n<th>聚合函数</th>\n<th>支持的数据类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>count()</td>\n<td>任何类型/*</td>\n<td>计算结果集中的总行数</td>\n</tr>\n<tr>\n<td>sum()</td>\n<td>Numeric</td>\n<td>计算指定列中所有非空值的总和</td>\n</tr>\n<tr>\n<td>avg()</td>\n<td>numeric</td>\n<td>计算指定列中所有非空值的平均值</td>\n</tr>\n<tr>\n<td>max()</td>\n<td>char/numeric</td>\n<td>返回指定列中最大值</td>\n</tr>\n<tr>\n<td>min()</td>\n<td>char/numeric</td>\n<td>返回指定列中最小值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--示例：求教师的工资总额</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"built_in\">Sum</span>(Salary) <span class=\"keyword\">From</span> Teacher;</span><br><span class=\"line\"><span class=\"comment\">--示例：求计算机系教师的工资总额</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"built_in\">Sum</span>(Salary) <span class=\"keyword\">From</span> Teacher T, Dept</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> Dept.Dname <span class=\"operator\">=</span> ‘计算机’ <span class=\"keyword\">and</span> Dept.D# <span class=\"operator\">=</span> T.D#;</span><br><span class=\"line\"><span class=\"comment\">--示例：求数据库课程的平均成绩</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"built_in\">AVG</span>(Score) <span class=\"keyword\">From</span> Course C, SC</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> C.Cname <span class=\"operator\">=</span> ‘数据库’ <span class=\"keyword\">and</span> C.C# <span class=\"operator\">=</span> SC.C#;</span><br></pre></td></tr></table></figure>\n\n\n<p><span id=\"id9\"><span></p>\n<h3 id=\"9-SQL语言-分组查询与分组过滤\"><a href=\"#9-SQL语言-分组查询与分组过滤\" class=\"headerlink\" title=\"9. SQL语言-分组查询与分组过滤\"></a>9. SQL语言-分组查询与分组过滤</h3><h4 id=\"9-1-分组查询\"><a href=\"#9-1-分组查询\" class=\"headerlink\" title=\"9.1 分组查询\"></a>9.1 分组查询</h4><p>分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。</p>\n<ol>\n<li><p>分组的基本语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">Select</span> 列名 <span class=\"operator\">|</span> expr <span class=\"operator\">|</span> agfunc(列名) [[, 列名 <span class=\"operator\">|</span> expr <span class=\"operator\">|</span> agfunc(列名) ] … ]</span><br><span class=\"line\">    <span class=\"keyword\">From</span> 表名<span class=\"number\">1</span> [, 表名<span class=\"number\">2</span> … ]</span><br><span class=\"line\">    [ <span class=\"keyword\">Where</span> <span class=\"keyword\">Where</span> 检索条件 ]</span><br><span class=\"line\">    [ <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> 分组条件 ] ;</span><br></pre></td></tr></table></figure></li>\n<li><p>分组条件可以是：<code>列名1, 列名2, …</code></p>\n</li>\n<li><p>示例： 求每一个学生的平均成绩</p>\n<ul>\n<li><code>Select S#, AVG(Score) From SC Group by S#;</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"9-2-分组过滤\"><a href=\"#9-2-分组过滤\" class=\"headerlink\" title=\"9.2 分组过滤\"></a>9.2 分组过滤</h4><p>聚集函数是不允许用于Where子句中的：Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤</p>\n<ul>\n<li>分组过滤：若要对集合(即分组)进行条件过滤，即满足条件的集合/分组留下，不满足条件的集合/分组剔除。</li>\n<li>Having子句，又称分组过滤子句。需要有Groupby子句支持，换句话说，没有Groupby子句，便不能有Having子句。</li>\n</ul>\n<ol>\n<li><p>基本语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">Select</span> 列名 <span class=\"operator\">|</span> expr <span class=\"operator\">|</span> agfunc(列名) [[, 列名 <span class=\"operator\">|</span> expr <span class=\"operator\">|</span> agfunc(列名) ] … ]</span><br><span class=\"line\">    <span class=\"keyword\">From</span> 表名<span class=\"number\">1</span> [, 表名<span class=\"number\">2</span> … ]</span><br><span class=\"line\">    [ <span class=\"keyword\">Where</span> <span class=\"keyword\">Where</span> 检索条件 ]</span><br><span class=\"line\">    [ <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> 分组条件 [ <span class=\"keyword\">Having</span> <span class=\"keyword\">Having</span> 分组过滤条件] ] ;</span><br></pre></td></tr></table></figure></li>\n<li><p>示例：求不及格课程超过两门的同学的学号</p>\n<ul>\n<li><code>Select S# From SC Where Score&lt;60 Group by S# Having Count(*)&gt;2;</code> </li>\n</ul>\n</li>\n</ol>\n<h4 id=\"9-3-where子句与having子句的区别\"><a href=\"#9-3-where子句与having子句的区别\" class=\"headerlink\" title=\"9.3 where子句与having子句的区别\"></a>9.3 where子句与having子句的区别</h4><ol>\n<li>聚合函数是比较where、having 的关键。在from后面的执行顺序：<ul>\n<li><code>where -&gt; 聚合函数(sum,min,max,avg,count) -&gt;having</code></li>\n</ul>\n</li>\n<li>列出group by来比较二者:<ul>\n<li>where子句：是在分组之前使用，表示从所有数据中筛选出部分数据，以完成分组的要求，在where子句中不允许使用统计函数，没有group by子句也可以使用。</li>\n<li>having子句：是在分组之后使用的，表示对分组统计后的数据执行再次过滤，可以使用统计函数，有group by子句之后才可以出现having子句。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>注意事项 ： </p>\n<ol>\n<li>where 后不能跟聚合函数，因为where执行顺序大于聚合函数。 </li>\n<li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。 </li>\n<li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</li>\n</ol>\n</blockquote>\n<p><span id=\"id10\"><span></p>\n<h3 id=\"10-SQL语言实现关系代数操作\"><a href=\"#10-SQL语言实现关系代数操作\" class=\"headerlink\" title=\"10. SQL语言实现关系代数操作\"></a>10. SQL语言实现关系代数操作</h3><p>SQL语言：并运算UNION, 交运算INTERSECT, 差运算EXCEPT。</p>\n<ul>\n<li>基本语法形式：<ul>\n<li><code>子查询 &#123;Union [ALL] | Intersect [ALL] | Except [ALL] 子查询&#125;</code></li>\n</ul>\n</li>\n<li>通常情况下自动删除重复元组：不带ALL。若要保留重复的元组，则要带ALL。<ul>\n<li>假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在：<ul>\n<li>子查询1 Union ALL 子查询2 ，出现m + n次</li>\n<li>子查询1 Intersect ALL 子查询2 ，出现min(m,n)次</li>\n<li>子查询1 Except ALL 子查询2 ，出现max(0, m – n)次</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>UNION运算符是Entry-SQL92的一部分, INTERSECT、EXCEPT运算符是Full-SQL92的一部分,它们都是Core-SQL99的一部分，但<strong>有些DBMS并不支持</strong>这些运算，使用时要注意。</p>\n</blockquote>\n<h4 id=\"10-1-SQL并运算-UNION\"><a href=\"#10-1-SQL并运算-UNION\" class=\"headerlink\" title=\"10.1 SQL并运算(UNION)\"></a>10.1 SQL并运算(UNION)</h4><ol>\n<li>示例：已知两个表<ul>\n<li>Customers(Cid, Cname, City, Discnt)</li>\n<li>Agents(Aid, Aname, City, Percent)</li>\n</ul>\n</li>\n<li>求客户所在的或者代理商所在的城市<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> City <span class=\"keyword\">From</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> City <span class=\"keyword\">From</span> Agents;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"10-2-SQL交运算-INTERSECT\"><a href=\"#10-2-SQL交运算-INTERSECT\" class=\"headerlink\" title=\"10.2 SQL交运算(INTERSECT)\"></a>10.2 SQL交运算(INTERSECT)</h4><ol>\n<li><p>示例：求既学过002号课，又学过003号课的同学学号</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# <span class=\"operator\">=</span> ‘<span class=\"number\">002</span>’</span><br><span class=\"line\"><span class=\"keyword\">INTERSECT</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# <span class=\"operator\">=</span> ‘<span class=\"number\">003</span>’;</span><br></pre></td></tr></table></figure></li>\n<li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p>\n<ul>\n<li><code>Select S# From SC Where C# = ‘002’ and S# IN (Select S# From SC Where C# = ‘003’);</code></li>\n</ul>\n</li>\n<li><p>交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也可以用其他方式表达同样的查询需求。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。</p>\n</li>\n</ol>\n<h4 id=\"10-3-SQL差运算-EXCEPT\"><a href=\"#10-3-SQL差运算-EXCEPT\" class=\"headerlink\" title=\"10.3 SQL差运算(EXCEPT)\"></a>10.3 SQL差运算(EXCEPT)</h4><ol>\n<li><p>示例： 假定所有学生都有选课，求没学过002号课程的学生学号</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">DISTINCT</span> S# <span class=\"keyword\">From</span> SC</span><br><span class=\"line\"><span class=\"keyword\">EXCEPT</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# <span class=\"operator\">=</span> ‘<span class=\"number\">002</span>’;</span><br></pre></td></tr></table></figure></li>\n<li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">DISTINCT</span> S# <span class=\"keyword\">From</span> SC SC1</span><br><span class=\"line\">    <span class=\"keyword\">Where</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> ( <span class=\"keyword\">Select</span> <span class=\"operator\">*</span> <span class=\"keyword\">From</span> SC</span><br><span class=\"line\">        <span class=\"keyword\">Where</span> C# <span class=\"operator\">=</span> ‘<span class=\"number\">002</span>’ <span class=\"keyword\">and</span> S# <span class=\"operator\">=</span> SC1.S#);</span><br></pre></td></tr></table></figure></li>\n<li><p>差运算符Except也没有增强SQL的表达能力，没有Except， SQL也可以用其他方式表达同样的查询需求。只是有了Except更容易表达一些，但增加了SQL语言的不唯一性。</p>\n</li>\n</ol>\n<h4 id=\"10-4-空值的处理\"><a href=\"#10-4-空值的处理\" class=\"headerlink\" title=\"10.4 空值的处理\"></a>10.4 空值的处理</h4><p>空值是其值不知道、不确定、不存在的值；数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等</p>\n<ol>\n<li>在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来标记，使用特殊的空值检测函数来获得某列的值是否为空值。</li>\n<li>空值检测：<ul>\n<li><code>is [not ] null</code> //测试指定列的值是否为空值</li>\n</ul>\n</li>\n<li>示例：找出年龄值为空的学生姓名<ul>\n<li><code>Select Sname From Student Where Sage is null;</code></li>\n</ul>\n</li>\n<li>现行DBMS的空值处理小结<ul>\n<li>除is[not]null之外，空值不满足任何查找条件</li>\n<li>如果null参与算术运算，则该算术表达式的值为null</li>\n<li>如果null参与比较运算，则结果可视为false。在SQL-92中可看成unknown</li>\n<li>如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"10-5-内连接、外连接\"><a href=\"#10-5-内连接、外连接\" class=\"headerlink\" title=\"10.5 内连接、外连接\"></a>10.5 内连接、外连接</h4><ol>\n<li>标准SQL语言中连接运算通常为：<ul>\n<li><code>Select Select 列名[[,列名]… ] From 表名1,表名2,… Where 检索条件;</code></li>\n<li>即相当于采用<code>Π[列名,…,列名](σ 检索条件(表名1 × 表名2 × …))</code>。</li>\n</ul>\n</li>\n<li>SQL的高级语法中引入了内连接与外连接运算，具体形式：<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">Select</span> 列名 [ [, 列名] … ]</span><br><span class=\"line\">    <span class=\"keyword\">From</span> 表名<span class=\"number\">1</span> [<span class=\"keyword\">NATURAL</span>]</span><br><span class=\"line\">    [ <span class=\"keyword\">INNER</span> <span class=\"operator\">|</span> &#123; <span class=\"keyword\">LEFT</span> <span class=\"operator\">|</span> <span class=\"keyword\">RIGHT</span> <span class=\"operator\">|</span> <span class=\"keyword\">FULL</span>&#125; [<span class=\"keyword\">OUTER</span>]] <span class=\"keyword\">JOIN</span> 表名<span class=\"number\">2</span></span><br><span class=\"line\">    &#123; <span class=\"keyword\">ON</span> 连接条件 <span class=\"operator\">|</span> <span class=\"keyword\">Using</span> (Colname &#123;, Colname …&#125;) &#125;</span><br><span class=\"line\">    [ <span class=\"keyword\">Where</span> <span class=\"keyword\">Where</span> 检索条件 ] … ;</span><br></pre></td></tr></table></figure></li>\n<li>由 <strong>连接类型</strong> 和 <strong>连接条件</strong> 构成连接运算。<ul>\n<li>**<code>Natural</code>**：出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次</li>\n<li><strong><code>Inner Join</code></strong>: 即关系代数中的θ-连接运算</li>\n<li><strong><code>Left Outer Join, Right Outer Join, Full Outer Join</code></strong>: 即关系代数中的外连接运算</li>\n<li>**<code>on &lt;连接条件&gt;</code>**：出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次</li>\n<li>**<code>using (Col1, Col2, …, Coln)</code>**：Col是两个连接关系的公共属性的子集，元组在(Col1,Col2,…,Coln)上取值相等，且(Col1,Col2,…,Coln)只出现一次</li>\n</ul>\n</li>\n<li>示例:</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- (Inner Join)求所有教师的任课情况并按教师号排序(没有任课的教师也需列在表中)</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> Teacher.T#, Tname, Cname</span><br><span class=\"line\">    <span class=\"keyword\">From</span> Teacher <span class=\"keyword\">Inner</span> <span class=\"keyword\">Join</span> Course</span><br><span class=\"line\">        <span class=\"keyword\">ON</span> Teacher.T# <span class=\"operator\">=</span> Course.T#</span><br><span class=\"line\">    <span class=\"keyword\">Order</span> <span class=\"keyword\">by</span> Teacher.T# <span class=\"keyword\">ASC</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--(Outer Join)求所有教师的任课情况(没有任课的教师也需列在表中)</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> Teacher. T#, Tname, Cname</span><br><span class=\"line\">    <span class=\"keyword\">From</span> Teacher <span class=\"keyword\">Left</span> <span class=\"keyword\">Outer</span> <span class=\"keyword\">Join</span> Course</span><br><span class=\"line\">        <span class=\"keyword\">ON</span> Teacher.T# <span class=\"operator\">=</span> Course.T#</span><br><span class=\"line\">    <span class=\"keyword\">Order</span> <span class=\"keyword\">by</span> Teacher.T# <span class=\"keyword\">ASC</span> ;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><span id=\"id11\"><span></p>\n<h3 id=\"11-SQL语言之视图及其应用\"><a href=\"#11-SQL语言之视图及其应用\" class=\"headerlink\" title=\"11. SQL语言之视图及其应用\"></a>11. SQL语言之视图及其应用</h3><ol>\n<li>数据库的三级模式两层映像<ul>\n<li>三级模式：数据库系统是由外模式、模式(概念模式)和内模式三级构成</li>\n<li>应用–&gt; <strong>外模式</strong>(多个) –&gt; <strong>概念模式</strong>(一个) –&gt; <strong>内模式</strong>(一个) –&gt; 数据库</li>\n<li>两层映像：<code>E-C</code>映像(外模式-&gt;概念模式)、<code>C-I</code>映像(概念模式-&gt;内模式)。</li>\n</ul>\n</li>\n<li>对应概念模式的数据在SQL中被称为<strong>基本表(Table)</strong>,而对应外模式的数据称为<strong>视图(View)<strong>。</strong>视图不仅包含外模式，而且包含其E-C映像</strong>。</li>\n<li><strong>基本表</strong>是实际存储于存储文件中的表，基本表中的<strong>数据是需要存储的</strong></li>\n<li><strong>视图</strong>在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，其<strong>数据并不存储</strong>，而是在运行过程中动态产生与维护的</li>\n<li>对视图数据的更改最终要反映在对基本表的更改上。</li>\n</ol>\n<h4 id=\"11-1-视图的定义\"><a href=\"#11-1-视图的定义\" class=\"headerlink\" title=\"11.1 视图的定义\"></a>11.1 视图的定义</h4><p>视图需要“先定义，再使用”；定义视图，有时可方便用户进行检索操作。</p>\n<ol>\n<li>定义视图: <code>create view view_name [(列名[列名] …)] as 子查询 [with check option]</code><ul>\n<li>如果视图的属性名缺省，则默认为子查询结果中的属性名；也可以显式指明其所拥有的列名。</li>\n<li>with checkoption指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式</li>\n</ul>\n</li>\n<li>示例：定义一个视图 CompStud 为计算机系的学生，通过该视图可以将Student表中其他系的学生屏蔽掉<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">View</span> CompStud <span class=\"keyword\">AS</span></span><br><span class=\"line\">    (<span class=\"keyword\">Select</span> <span class=\"operator\">*</span> <span class=\"keyword\">From</span> Student</span><br><span class=\"line\">        <span class=\"keyword\">Where</span> D# <span class=\"keyword\">in</span> (<span class=\"keyword\">Select</span> D# <span class=\"keyword\">From</span> Dept</span><br><span class=\"line\">            <span class=\"keyword\">Where</span> Dname <span class=\"operator\">=</span> ‘计算机’));</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"11-2-视图的使用\"><a href=\"#11-2-视图的使用\" class=\"headerlink\" title=\"11.2 视图的使用\"></a>11.2 视图的使用</h4><p>使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用</p>\n<ul>\n<li>示例：检索计算机系的所有学生，我们可使用CompStud<ul>\n<li><code>Select * From CompStud;</code></li>\n</ul>\n</li>\n<li>示例：检索计算机系的年龄小于20的所有学生，我们可使用CompStud<ul>\n<li><code>Select * From CompStud Where Sage&lt;20;</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-3-视图的更新\"><a href=\"#11-3-视图的更新\" class=\"headerlink\" title=\"11.3 视图的更新\"></a>11.3 视图的更新</h4><p>SQL视图更新：是比较复杂的问题，因视图不保存数据，对视图的更新最终要反映到对基本表的更新上，而有时，视图定义的映射不是可逆的。</p>\n<ol>\n<li>SQL视图更新的可执行性<ul>\n<li>如果视图的select目标列包含聚集函数，则不能更新</li>\n<li>如果视图的select子句使用了unique或distinct，则不能更新</li>\n<li>如果视图中包括了groupby子句，则不能更新</li>\n<li>如果视图中包括经算术表达式计算出来的列，则不能更新</li>\n<li>如果视图是由单个表的列构成，但并没有包括主键，则不能更新</li>\n</ul>\n</li>\n<li>对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主键，则可以更新</li>\n<li>可更新SQL视图示例：</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 定义视图</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> CStud(S#, Sname, Sclass)</span><br><span class=\"line\"><span class=\"keyword\">as</span> ( <span class=\"keyword\">select</span> S#, Sname, Sclass <span class=\"keyword\">from</span> Student <span class=\"keyword\">where</span> D# <span class=\"operator\">=</span><span class=\"string\">&#x27;03&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 更新视图</span></span><br><span class=\"line\"><span class=\"keyword\">Insert</span> <span class=\"keyword\">into</span> CStud <span class=\"keyword\">Values</span> (<span class=\"string\">&#x27;98030104&#x27;</span>, <span class=\"string\">&#x27;张三丰&#x27;</span>, <span class=\"string\">&#x27;980301&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 更新视图 将转换为 更新基本表</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> Student <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;98030104&#x27;</span>, <span class=\"string\">&#x27;张三丰&#x27;</span>, <span class=\"keyword\">Null</span>, <span class=\"keyword\">Null</span>, <span class=\"string\">&#x27;03&#x27;</span>, <span class=\"string\">&#x27;980301&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-4-视图的撤销\"><a href=\"#11-4-视图的撤销\" class=\"headerlink\" title=\"11.4 视图的撤销\"></a>11.4 视图的撤销</h4><p>已经定义的视图也可以撤消</p>\n<ul>\n<li>撤消视图：<code>Drop View view_name</code></li>\n</ul>\n<p>不仅视图可以撤消，基本表、数据库等都可以撤消</p>\n<ul>\n<li>撤消基本表：<code>Drop Table 表名</code></li>\n</ul>\n<p><span id=\"id12\"><span></p>\n<h3 id=\"12-数据库完整性\"><a href=\"#12-数据库完整性\" class=\"headerlink\" title=\"12. 数据库完整性\"></a>12. 数据库完整性</h3><p>数据库完整性(DB Integrity)是指：DBMS应保证的DB的一种特性–在任何情况下的正确性、有效性和一致性</p>\n<ul>\n<li>广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等</li>\n<li>狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题。</li>\n</ul>\n<h4 id=\"12-1-基本概念\"><a href=\"#12-1-基本概念\" class=\"headerlink\" title=\"12.1 基本概念\"></a>12.1 基本概念</h4><p>关系模型中有完整性要求：实体完整性、参照完整性、用户自定义完整性</p>\n<ol>\n<li>数据库完整性管理的作用<ul>\n<li>防止和避免数据库中不合理数据的出现</li>\n<li>DBMS应尽可能地自动防止DB中语义不合理现象</li>\n<li>如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担</li>\n</ul>\n</li>\n<li>DBMS怎样自动保证完整性：<ul>\n<li>DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义)</li>\n<li>当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性</li>\n</ul>\n</li>\n<li><strong>完整性约束条件</strong>(或称完整性约束规则)的一般形式：Integrity Constraint::=(O,P,A,R)<ul>\n<li>O：数据集合：约束的对象(列、多列(元组)、元组集合)</li>\n<li>P：谓词条件：需要定义什么样的约束</li>\n<li>A：触发条件：默认更新时检查</li>\n<li>R：响应动作：默认拒绝</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"12-2-数据库完整性的分类\"><a href=\"#12-2-数据库完整性的分类\" class=\"headerlink\" title=\"12.2 数据库完整性的分类\"></a>12.2 数据库完整性的分类</h4><ol>\n<li><p>按约束对象分类:</p>\n<ul>\n<li>域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的</li>\n<li>关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断</li>\n</ul>\n</li>\n<li><p>按约束来源分类:</p>\n<ul>\n<li>结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等；</li>\n<li>内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等。</li>\n</ul>\n</li>\n<li><p>按约束状态分类:</p>\n<ul>\n<li>静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。</li>\n<li>动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id13\"><span></p>\n<h3 id=\"13-数据库的静态完整性-约束\"><a href=\"#13-数据库的静态完整性-约束\" class=\"headerlink\" title=\"13. 数据库的静态完整性(约束)\"></a>13. 数据库的静态完整性(约束)</h3><ol>\n<li><p>SQL语言支持的约束类别：</p>\n<ul>\n<li>静态约束<ul>\n<li>列完整性—域完整性约束</li>\n<li>表完整性–关系完整性约束</li>\n</ul>\n</li>\n<li>动态约束<ul>\n<li>触发器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CreateTable有三种功能：定义关系模式、定义完整性约束 和定义物理存储特性</p>\n<ul>\n<li>定义完整性约束条件：列完整性、表完整性</li>\n</ul>\n</li>\n<li><p>列约束：一种<strong>域约束类型</strong>，对单一列的值进行约束</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>                  <span class=\"operator\">/</span><span class=\"operator\">/</span>列值非空</span><br><span class=\"line\">[ <span class=\"keyword\">CONSTRAINT</span> constraintname ] <span class=\"operator\">/</span><span class=\"operator\">/</span>为约束命名，便于以后撤消</span><br><span class=\"line\">&#123; <span class=\"keyword\">UNIQUE</span>                      <span class=\"operator\">/</span><span class=\"operator\">/</span>列值是唯一</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">PRIMARY</span> KEY                 <span class=\"operator\">/</span><span class=\"operator\">/</span>列为主键</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">CHECK</span> (search_cond)         <span class=\"operator\">/</span><span class=\"operator\">/</span>列值满足条件,条件只能使用列当前值</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">REFERENCES</span> tablename [(colname) ]</span><br><span class=\"line\">[<span class=\"keyword\">ON</span> <span class=\"keyword\">DELETE</span> &#123; CASCADE <span class=\"operator\">|</span> <span class=\"keyword\">SET</span> <span class=\"keyword\">NULL</span> &#125; ] &#125; &#125; </span><br></pre></td></tr></table></figure></li>\n<li><p>表约束：一种<strong>关系约束类型</strong>，对多列或元组的值进行约束</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ <span class=\"keyword\">CONSTRAINT</span> constraintname ]       <span class=\"operator\">/</span><span class=\"operator\">/</span>为约束命名，便于以后撤消</span><br><span class=\"line\">&#123; <span class=\"keyword\">UNIQUE</span> (colname &#123;,colname…&#125;)      <span class=\"operator\">/</span><span class=\"operator\">/</span>几列值组合在一起是唯一</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">PRIMARY</span> KEY (colname &#123;,colname…&#125;) <span class=\"operator\">/</span><span class=\"operator\">/</span>几列联合为主键</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">CHECK</span> (search_condition)          <span class=\"operator\">/</span><span class=\"operator\">/</span>元组多列值共同满足条件</span><br><span class=\"line\">                                    <span class=\"operator\">/</span><span class=\"operator\">/</span>条件中只能使用同一元组的不同列当前值</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">FOREIGN</span> KEY (colname &#123;,colname…&#125;)</span><br><span class=\"line\"><span class=\"keyword\">REFERENCES</span> tablename [(colname &#123;,colname…&#125;)]<span class=\"operator\">/</span><span class=\"operator\">/</span>引用另一表tablename的若干列的值作为外键</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。</p>\n</blockquote>\n</li>\n<li><p>Create Table中定义的表约束或列约束可以在以后根据需要进行撤消或追加。撤消或追加约束的语句是 Alter Table(不同系统可能有差异)</p>\n<ul>\n<li>示例：撤消SC表的ctscore约束(由此可见，未命名的约束是不能撤消)<ul>\n<li><code>Alter Table SC DROP CONSTRAINT ctscore;</code></li>\n</ul>\n</li>\n<li>有些DBMS支持独立的追加约束,注意书写格式可能有些差异<ul>\n<li>示例：<code>Alter Table SC Add Constraint nctscore check (Score&gt;=0.0 and Score&lt;=150.0));</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>现约束的方法-断言ASSERTION</p>\n<ul>\n<li>一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件</li>\n<li>表约束和列约束就是一些特殊的断言</li>\n<li>SQL还提供了复杂条件表达的断言。其语法形式为：<ul>\n<li><code>CREATE ASSERTION &lt;assertion-name&gt; CHECK &lt;predicate&gt;</code></li>\n</ul>\n</li>\n<li>当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是否违反该断言。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 示例: “每个分行的贷款总量必须小于该分行所有账户的余额总和”</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> assertion sum_constraint <span class=\"keyword\">check</span></span><br><span class=\"line\">    (<span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> branch</span><br><span class=\"line\">    <span class=\"keyword\">where</span> (<span class=\"keyword\">select</span> <span class=\"built_in\">sum</span>(amount ) <span class=\"keyword\">from</span> loan</span><br><span class=\"line\">        <span class=\"keyword\">where</span> loan.branch_name <span class=\"operator\">=</span> branch.branch_name )</span><br><span class=\"line\">    <span class=\"operator\">&gt;=</span> (<span class=\"keyword\">select</span> <span class=\"built_in\">sum</span> (balance ) <span class=\"keyword\">from</span> account</span><br><span class=\"line\">        <span class=\"keyword\">where</span> account.branch_name <span class=\"operator\">=</span> branch.branch_name )))</span><br><span class=\"line\"><span class=\"comment\">-- 数据表：</span></span><br><span class=\"line\">account(branch_name, account_number,…, balance) <span class=\"operator\">/</span><span class=\"operator\">/</span>分行，账户及其余额</span><br><span class=\"line\">loan(branch_name , loan_number, amount,) <span class=\"operator\">/</span><span class=\"operator\">/</span>分行的每一笔贷款</span><br><span class=\"line\">branch(branch_name, … ) <span class=\"operator\">/</span><span class=\"operator\">/</span>分行</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>断言测试增加了数据库维护的负担，要小心使用复杂的断言。</p>\n</blockquote>\n<p><span id=\"id14\"><span></p>\n<h3 id=\"14-数据库的动态完整性-触发器\"><a href=\"#14-数据库的动态完整性-触发器\" class=\"headerlink\" title=\"14. 数据库的动态完整性(触发器)\"></a>14. 数据库的动态完整性(触发器)</h3><p>实现数据库动态完整的方法—触发器Trigger</p>\n<ol>\n<li><p>触发器Trigger</p>\n<ul>\n<li>Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger</li>\n<li>Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。</li>\n</ul>\n</li>\n<li><p>基本语法</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> trigger_name BEFORE <span class=\"operator\">|</span> AFTER</span><br><span class=\"line\">    &#123; <span class=\"keyword\">INSERT</span> <span class=\"operator\">|</span> <span class=\"keyword\">DELETE</span> <span class=\"operator\">|</span> UPDATE [<span class=\"keyword\">OF</span> colname &#123;, colname...&#125;] &#125;</span><br><span class=\"line\">    <span class=\"keyword\">ON</span> tablename [<span class=\"keyword\">REFERENCING</span> corr_name_def &#123;, corr_name_def...&#125; ]</span><br><span class=\"line\">    [<span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"type\">ROW</span> <span class=\"operator\">|</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> STATEMENT]</span><br><span class=\"line\">                <span class=\"operator\">/</span><span class=\"operator\">/</span>对更新操作的每一条结果(前者)，或整个更新操作完成(后者)</span><br><span class=\"line\">    [<span class=\"keyword\">WHEN</span> (search_condition)]           <span class=\"operator\">/</span><span class=\"operator\">/</span>检查条件，如满足执行下述程序</span><br><span class=\"line\">    &#123; statement         <span class=\"operator\">/</span><span class=\"operator\">/</span>单行程序直接书写，多行程序要用下行方式</span><br><span class=\"line\">    <span class=\"operator\">|</span> <span class=\"keyword\">BEGIN</span> <span class=\"keyword\">ATOMIC</span> statement; &#123; statement;...&#125; <span class=\"keyword\">END</span> &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>触发器Trigger意义：</p>\n<ul>\n<li>当某一事件发生时(Before|After),对该事件产生的结果(或是每一元组，或是整个操作的所有元组), 检查条件<code>search_condition</code>,如果满足条件，则执行后面的程序段。条件或程序段中引用的变量可用<code>corr_name_def</code>来限定。</li>\n</ul>\n</li>\n<li><p>事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}</p>\n<ul>\n<li>当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后After触发</li>\n<li>操作发生，执行触发器操作需处理两组值：更新前的值和更新后的值，这两个值由<code>corr_name_def</code>的使用来区分</li>\n</ul>\n</li>\n<li><p><code>corr_name_def</code>的定义</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"keyword\">OLD</span> [<span class=\"type\">ROW</span>] [<span class=\"keyword\">AS</span>] old_row_corr_name <span class=\"operator\">/</span><span class=\"operator\">/</span>更新前的旧元组命别名为</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">NEW</span> [<span class=\"type\">ROW</span>] [<span class=\"keyword\">AS</span>] new_row_corr_name <span class=\"operator\">/</span><span class=\"operator\">/</span>更新后的新元组命别名为</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">OLD</span> <span class=\"keyword\">TABLE</span> [<span class=\"keyword\">AS</span>] old_table_corr_name <span class=\"operator\">/</span><span class=\"operator\">/</span>更新前的旧<span class=\"keyword\">Table</span>命别名为</span><br><span class=\"line\"><span class=\"operator\">|</span> <span class=\"keyword\">NEW</span> <span class=\"keyword\">TABLE</span> [<span class=\"keyword\">AS</span>] new_table_corr_name <span class=\"operator\">/</span><span class=\"operator\">/</span>更新后的新<span class=\"keyword\">Table</span>命别名为</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>corr_name_def</code>将在检测条件或后面的动作程序段中被引用处理</p>\n</blockquote>\n</li>\n<li><p>示例1: 设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> teacher_chgsal before update <span class=\"keyword\">of</span> salary</span><br><span class=\"line\">    <span class=\"keyword\">on</span> teacher</span><br><span class=\"line\">    <span class=\"keyword\">referencing</span> <span class=\"keyword\">new</span> x, <span class=\"keyword\">old</span> y</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span> <span class=\"keyword\">when</span> (x.salary <span class=\"operator\">&lt;</span> y.salary)</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">    raise_application_error(<span class=\"number\">-20003</span>, <span class=\"string\">&#x27;invalid salary on update&#x27;</span>);</span><br><span class=\"line\">    <span class=\"operator\">/</span><span class=\"operator\">/</span>此条语句为Oracle的错误处理函数</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>示例2: 假设student(S#, Sname, SumCourse), SumCourse为该同学已学习课程的门数，初始值为0，以后每选修一门都要对其增1 。设计一个触发器自动完成上述功能。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> sumc after <span class=\"keyword\">insert</span> <span class=\"keyword\">on</span> sc</span><br><span class=\"line\">    <span class=\"keyword\">referencing</span> <span class=\"keyword\">new</span> <span class=\"type\">row</span> newi</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">    update student <span class=\"keyword\">set</span> SumCourse <span class=\"operator\">=</span> SumCourse <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">where</span> S# <span class=\"operator\">=</span> :newi.S# ;</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>示例3：假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。设计一个触发器完成上述功能</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> delS# after <span class=\"keyword\">delete</span> <span class=\"keyword\">on</span> Student</span><br><span class=\"line\">    <span class=\"keyword\">referencing</span> <span class=\"keyword\">old</span> oldi</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> sc <span class=\"keyword\">where</span> S# <span class=\"operator\">=</span> :oldi.S# ;</span><br><span class=\"line\"><span class=\"keyword\">end</span>; </span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><span id=\"id15\"><span></p>\n<h3 id=\"15-数据库索引\"><a href=\"#15-数据库索引\" class=\"headerlink\" title=\"15. 数据库索引\"></a>15. 数据库索引</h3><p>索引是对数据库表中一列或多列的值进行排序的一种<strong>数据结构</strong>（最常见的是B-Tree）</p>\n<ol>\n<li>索引的作用<ol>\n<li>快速取数据；</li>\n<li>保证数据记录的唯一性；</li>\n<li>实现表与表之间的参照完整性；</li>\n<li>在使用ORDER by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。</li>\n</ol>\n</li>\n<li>创建索引：<code>CREATE INDEX  索引名称  on 表名(字段名);</code></li>\n<li>删除索引：<code>DROP INDEX 索引名称</code></li>\n<li>索引注意事项：<ol>\n<li>查询时减少使用<code>*</code>返回全部列，不要返回不需要的列</li>\n<li>where表达式子句包含索引的表达式置前</li>\n<li>避免在Order by中使用表达式</li>\n<li>索引技术是数据库自动使用，一个表格只存在一个索引就够了</li>\n</ol>\n</li>\n<li>缺点<ol>\n<li>索引的缺点是创建和维护索引需要耗费时间和空间</li>\n<li>索引可以提高查询速度，会减慢写入速度</li>\n<li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"15-1-索引主要种类\"><a href=\"#15-1-索引主要种类\" class=\"headerlink\" title=\"15.1 索引主要种类\"></a>15.1 索引主要种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</p>\n<ol>\n<li>唯一索引<ul>\n<li>唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</li>\n</ul>\n</li>\n<li>主键索引<ul>\n<li>数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</li>\n</ul>\n</li>\n<li>聚集索引<ul>\n<li>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</li>\n</ul>\n</li>\n<li>索引列<ul>\n<li>可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id16\"><span></p>\n<h3 id=\"16-数据库序列\"><a href=\"#16-数据库序列\" class=\"headerlink\" title=\"16. 数据库序列\"></a>16. 数据库序列</h3><p>序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。创建序列需要<code>CREATE SEQUENCE</code>系统权限。</p>\n<h4 id=\"16-1-Oracle中的序列（Sequence）\"><a href=\"#16-1-Oracle中的序列（Sequence）\" class=\"headerlink\" title=\"16.1 Oracle中的序列（Sequence）\"></a>16.1 Oracle中的序列（Sequence）</h4><ol>\n<li><p>创建序列</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> sequence 序列名 </span><br><span class=\"line\">    [increment <span class=\"keyword\">by</span> n]   <span class=\"comment\">--每次增加n个，默认为1</span></span><br><span class=\"line\">    [<span class=\"keyword\">start</span> <span class=\"keyword\">with</span> n]     <span class=\"comment\">--起始值n，默认为1</span></span><br><span class=\"line\">    [&#123;maxvalue n <span class=\"operator\">|</span> nomaxvalue&#125;]  <span class=\"comment\">--最大值设置，递增默认10的27次方，递减默认-1</span></span><br><span class=\"line\">    [&#123;minvalue n <span class=\"operator\">|</span> nominvalue&#125;]  <span class=\"comment\">--最小值设置，递增默认1，递减默认-10的26次方</span></span><br><span class=\"line\">    [&#123;<span class=\"keyword\">cycle</span> <span class=\"operator\">|</span> nocycle&#125;]   <span class=\"comment\">--是否循环</span></span><br><span class=\"line\">    [&#123;cache n <span class=\"operator\">|</span> nocache&#125;] <span class=\"comment\">--是否对序列进行内存缓冲，默认为20</span></span><br></pre></td></tr></table></figure></li>\n<li><p>查询序列</p>\n<ul>\n<li><code>NEXTVAL</code>:返回序列中下一个有效的值，任何用户都可以引用。</li>\n<li><code>CURRVAL</code>:中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--查询下一个将要使用的序列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> 序列名.nextval <span class=\"keyword\">from</span> dual</span><br><span class=\"line\"><span class=\"comment\">--查询当前序列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> 序列名.currval <span class=\"keyword\">from</span> dual </span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>Oracle将sequence的定义存储在数据字典之中。</li>\n<li>Sequence是独立于事务的，就是说序列的增加不需要等待事务的完成，也就是说序列是异步于事务而增长的。这说明，你访问不到别的用户使用该sequence产生的值，也就是说你只能访问到你当前产生的值，即使其他用户已经增加了sequence的值；还说明如果事务回滚，sequence不会回滚，它所发生的改变是一维的。</li>\n</ul>\n</blockquote>\n<ol start=\"3\">\n<li>删除序列：<code>Drop sequence 序列名</code></li>\n<li>更改序列：<code>Alter sequence 序列名 [其余参数同创建序列]</code></li>\n<li>使用序列示例：</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 1.直接使用</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> person (id, name, password) <span class=\"keyword\">values</span> (序列名.nextval, <span class=\"string\">&#x27;张三&#x27;</span>, <span class=\"string\">&#x27;123&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 2.也可以通过建立触发器，当有数据插入表person时，使用oracle序列为其去的递增的主键值</span></span><br><span class=\"line\"><span class=\"comment\">-- 2.1创建触发器</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">or</span> replace <span class=\"keyword\">trigger</span> 触发器名 before <span class=\"keyword\">insert</span> <span class=\"keyword\">on</span> person</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> 序列名.nextval <span class=\"keyword\">into</span> :new.id <span class=\"keyword\">from</span> dual;</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 2.2插入数据</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> person ( username, age, password) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;张三&#x27;</span>, <span class=\"number\">20</span>, <span class=\"string\">&#x27;zhang123&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>注意点：<ul>\n<li>一个序列可以被多张别使用，不过一般建议为每个表建立单独的序列。</li>\n<li>当使用到序列的事务发生回滚。会造成序列号不连续。在用生成的序列值作为编号做插入数据库操作时，可能遇到事务提交失败，从而导致序号不连续。</li>\n<li>大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 n个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数最好不要设置过大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入n个。这种情况也能会在数据库关闭时也会导致序号不连续。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"16-2-Mysql中的序列（AUTO-INCREMENT）\"><a href=\"#16-2-Mysql中的序列（AUTO-INCREMENT）\" class=\"headerlink\" title=\"16.2 Mysql中的序列（AUTO_INCREMENT）\"></a>16.2 Mysql中的序列（AUTO_INCREMENT）</h4><p>MySQL中最简单使用序列的方法就是使用<code>AUTO_INCREMENT</code>来定义列。</p>\n<ol>\n<li>orale没有类似mysql的AUTO_INCREMENT这样的自增长字段，实现插入一条记录，自动增加1.oracle是通过sequence（序列）来完成的。</li>\n<li>首先mysql的自增长“序列”和序列是两回事，mysql本身不提供序列机制。</li>\n<li>mysql的AUTO_INCREMENT可以设置起始值，但是不能设置步长，其步长默认就是1.</li>\n<li>mysql一个表只能有一个自增长字段。自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。并且只能是数字型。</li>\n</ol>\n<p><span id=\"id17\"><span></p>\n<h3 id=\"17-数据库安全性\"><a href=\"#17-数据库安全性\" class=\"headerlink\" title=\"17. 数据库安全性\"></a>17. 数据库安全性</h3><p>数据库安全性是指DBMS应该保证的数据库的一种特性(机制或手段)：免受非法、非授权用户的使用、泄漏、更改或破坏</p>\n<ol>\n<li>数据库安全性管理涉及许多方面<ol>\n<li>社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法</li>\n<li>公共政策/制度方面：例如，政府或组织的信息公开或非公开制度</li>\n<li>安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略)</li>\n<li>数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)</li>\n<li>数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制</li>\n</ol>\n</li>\n<li>DBMS的安全机制<ol>\n<li><strong>自主安全性机制</strong>：存取控制(AccessControl)<ul>\n<li>通过权限在用户之间的传递，使用户自主管理数据库安全性</li>\n</ul>\n</li>\n<li><strong>强制安全性机制</strong>：<ul>\n<li>通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据</li>\n</ul>\n</li>\n<li>推断控制机制：<ul>\n<li>防止通过历史信息，推断出不该被其知道的信息；</li>\n<li>防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要</li>\n</ul>\n</li>\n<li>数据加密存储机制：<ul>\n<li>通过加密、解密保护数据，密钥、加密/解密方法与传输</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>DBA的责任和义务<ul>\n<li>熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略</li>\n<li>规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应，</li>\n<li><strong>划分好数据的安全级别以及用户的安全级别</strong></li>\n<li>实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id18\"><span></p>\n<h3 id=\"18-数据库自主安全性机制\"><a href=\"#18-数据库自主安全性机制\" class=\"headerlink\" title=\"18. 数据库自主安全性机制\"></a>18. 数据库自主安全性机制</h3><ul>\n<li>通常情况下，自主安全性是通过授权机制来实现的。</li>\n<li>用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。<ul>\n<li>授权者：决定用户权利的人</li>\n<li>授权：授予用户访问的权利</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>DBMS自动实现自主安全性：<ul>\n<li>DBMS允许用户定义一些安全性控制规则(用SQL-DCL来定义)</li>\n<li>当有DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许访问</li>\n</ul>\n</li>\n<li>DBMS将权利和用户(账户)结合在一起，形成一个访问规则表，依据该规则表可以实现对数据库的安全性控制<ul>\n<li><code>AccessRule ::=(S, O, t, P)</code><ul>\n<li>S: 请求主体(用户)</li>\n<li>O: 访问对象</li>\n<li>t: 访问权利</li>\n<li>P: 谓词</li>\n</ul>\n</li>\n<li>{AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利;</li>\n<li>用户多时，可以按用户组建立访问规则</li>\n<li>访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库</li>\n<li>权利：包括创建、增、删、改、查等</li>\n<li>谓词：拥有权利需满足的条件</li>\n</ul>\n</li>\n<li><strong>示例</strong>：员工管理数据库的安全性控制示例<code>Employee(P#,Pname,Page,Psex,Psalary,D#,HEAD)</code><ul>\n<li>示例要求：<ul>\n<li>员工管理人员：能访问该数据库的所有内容，便于维护员工信息</li>\n<li>收发人员：访问该数据库以确认某员工是哪一个部门的，便于收发工作，只能访问基本信息，其他信息不允许其访问</li>\n<li>每个员工：允许其访问关于自己的记录，以便查询自己的工资情况，但不能修改</li>\n<li>部门领导：能够查询其所领导部门人员的所有情况</li>\n<li>高层领导：能访问该数据库的所有内容，但只能读</li>\n</ul>\n</li>\n<li>两种控制示例<ul>\n<li>按名控制安全性：存储矩阵</li>\n<li>按内容控制安全性：视图</li>\n</ul>\n</li>\n<li>视图是安全性控制的重要手段</li>\n<li>通过视图可以限制用户对关系中某些数据项的存取,例如：<ul>\n<li>视图1：CreateEmpV1as select*fromEmployee</li>\n<li>视图2：CreateEmpV2as selectPname,D#fromEmployee</li>\n</ul>\n</li>\n<li>通过视图可将数据访问对象与谓词结合起来，限制用户对关系中某些元组的存取，例如：<ul>\n<li>视图1： CreateEmpV3asselect*fromEmployeewhereP#=:UserId</li>\n<li>视图2： CreateEmpV4asselect*fromEmployeewhereHead=:UserId</li>\n</ul>\n</li>\n<li>用户定义视图后，视图便成为一新的数据对象，参与到存储矩阵与能力表中进行描述</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"18-1-SQL语言的用户与权利\"><a href=\"#18-1-SQL语言的用户与权利\" class=\"headerlink\" title=\"18.1 SQL语言的用户与权利\"></a>18.1 SQL语言的用户与权利</h4><ol>\n<li><p>SQL语言包含了DDL,DML和DCL。数据库安全性控制是属于DCL范畴</p>\n</li>\n<li><p>授权机制—自主安全性；视图的运用</p>\n</li>\n<li><p>关系级别(普通用户) &lt;– 账户级别(程序员用户) &lt;– 超级用户(DBA) </p>\n<ul>\n<li>(级别1)Select : 读(读DB, Table, Record, Attribute, … )</li>\n<li>(级别2)Modify : 更新<ul>\n<li>Insert : 插入(插入新元组, … )</li>\n<li>Update : 更新(更新元组中的某些值, …)</li>\n<li>Delete : 删除(删除元组, …)</li>\n</ul>\n</li>\n<li>(级别3)Create : 创建(创建表空间、模式、表、索引、视图等)<ul>\n<li>Create : 创建</li>\n<li>Alter : 更新</li>\n<li>Drop : 删除</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为账户级别的权利，而将级别1和2称为关系级别的权利。</p>\n</li>\n<li><p>授权命令<code>GRANT</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GRANT</span> &#123;<span class=\"keyword\">all</span> PRIVILEGES <span class=\"operator\">|</span> privilege &#123;,privilege…&#125;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">ON</span> [<span class=\"keyword\">TABLE</span>] tablename <span class=\"operator\">|</span> viewname</span><br><span class=\"line\">    <span class=\"keyword\">TO</span> &#123;public <span class=\"operator\">|</span> <span class=\"keyword\">user</span><span class=\"operator\">-</span>id &#123;, <span class=\"keyword\">user</span><span class=\"operator\">-</span>id…&#125;&#125;</span><br><span class=\"line\">    [<span class=\"keyword\">WITH</span> <span class=\"keyword\">GRANT</span> OPTION];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>user-id ，某一个用户账户，由DBA创建的合法账户</li>\n<li>public, 允许所有有效用户使用授予的权利</li>\n<li>privilege是下面的权利<ul>\n<li>SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES</li>\n</ul>\n</li>\n<li>WITH GRANT OPTION选项是允许被授权者传播这些权利</li>\n</ul>\n</li>\n<li><p>SQL-DCL的控制安全性-授权示例:</p>\n<ul>\n<li>假定高级领导为Emp0001, 部门领导为Emp0021, 员工管理员为Emp2001,收发员为Emp5001(均为UserId, 也即员工的P#)<ul>\n<li>Grant All Priviledges ON Employee TO Emp2001;</li>\n<li>Grant SELECT ON EmpV2 TO Emp5001;</li>\n<li>Grant SELECT ON EmpV3 TO public;</li>\n<li>Grant SELECT ON EmpV4 TO Emp0021;</li>\n</ul>\n</li>\n<li>授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别)</li>\n<li>授权者授予的权利必须是授权者已经拥有的权利</li>\n</ul>\n</li>\n<li><p>收回授权命令<code>REVOKE</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">REVOKE</span> &#123;<span class=\"keyword\">all</span> privilEges <span class=\"operator\">|</span> priv &#123;, priv…&#125; &#125; </span><br><span class=\"line\">    <span class=\"keyword\">ON</span> tablename <span class=\"operator\">|</span> viewname</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> &#123;public <span class=\"operator\">|</span> <span class=\"keyword\">user</span> &#123;, <span class=\"keyword\">user</span>…&#125; &#125;; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>示例: <code>revoke select on employee from UserB;</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"18-2-自主安全性的授权过程及其问题\"><a href=\"#18-2-自主安全性的授权过程及其问题\" class=\"headerlink\" title=\"18.2 自主安全性的授权过程及其问题\"></a>18.2 自主安全性的授权过程及其问题</h4><h5 id=\"18-2-1-授权过程\"><a href=\"#18-2-1-授权过程\" class=\"headerlink\" title=\"18.2.1 授权过程:\"></a>18.2.1 授权过程:</h5><ol>\n<li>第一步：DBA创建DB, 并为每一个用户创建一个账户<ul>\n<li>假定建立了五个用户：UserA, UserB, UserC, UserD, UserE</li>\n</ul>\n</li>\n<li>第二步：DBA授予某用户账户级别的权利<ul>\n<li>假定授予UserA</li>\n</ul>\n</li>\n<li>第三步：具有账户级别的用户可以创建基本表或视图, 他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问 权利<ul>\n<li>假定UserA创建了Employee, 则UserA就是Employee表的属主账户</li>\n</ul>\n</li>\n<li>第四步：拥有属主账户的用户可以将其中的一部分权利授予另外的用户，该用户也可将权利进一步授给其他的用户…<ul>\n<li>假定UserA将读权限授予UserB, 而userB又将其拥有的权限授予UserC,如此将权利不断传递下去。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>注意授权的传播范围<ul>\n<li>传播范围包括两个方面：水平传播数量和垂直传播数量<ul>\n<li>水平传播数量是授权者的再授权用户数目(树的广度)</li>\n<li>垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权者, …传播的深度(树的深度)</li>\n</ul>\n</li>\n<li>有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。</li>\n<li>当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回</li>\n<li>如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当UserB收回时，其还将保持UserE赋予其的权利。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"18-2-2-强制安全性机制\"><a href=\"#18-2-2-强制安全性机制\" class=\"headerlink\" title=\"18.2.2 强制安全性机制\"></a>18.2.2 强制安全性机制</h5><ol>\n<li>强制安全性机制<ul>\n<li>强制安全性通过对数据对象进行安全性分级<ul>\n<li>绝密(Top Secret), 机密(Secret), 可信(Confidential) 和 无分类(Unclassified)</li>\n</ul>\n</li>\n<li>同时对用户也进行上述的安全性分级</li>\n<li>从而强制实现不同级别用户访问不同级别数据的一种机制</li>\n</ul>\n</li>\n<li>强制安全性机制的实现<ul>\n<li>DBMS引入强制安全性机制, 可以通过扩展关系模式来实现<ul>\n<li>关系模式: R(A1: D1, A2: D2, …, An:Dn)</li>\n<li>对属性和元组引入安全性分级特性或称分类特性<ul>\n<li>R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>这样, 关系中的每个元组, 都将扩展为带有安全分级的元组</li>\n<li>强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。</li>\n</ul>\n</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckx2vb6uz000bvcueg9qrafrv","category_id":"ckx2vb6uq0006vcue6kjsbcvu","_id":"ckx2vb6v7000kvcue8our4gef"},{"post_id":"ckx2vb6um0003vcue55ld6yfr","category_id":"ckx2vb6uq0006vcue6kjsbcvu","_id":"ckx2vb6vc000ovcue0net62va"},{"post_id":"ckx2vb6uu0009vcue8gqq7r5g","category_id":"ckx2vb6uq0006vcue6kjsbcvu","_id":"ckx2vb6vf000rvcue70q40yxo"},{"post_id":"ckx2vb6v1000dvcuehove0kwk","category_id":"ckx2vb6v7000lvcue4kf39ypx","_id":"ckx2vb6vi000yvcue1qe19gyn"},{"post_id":"ckx2vb6v5000hvcuefp7mg157","category_id":"ckx2vb6v7000lvcue4kf39ypx","_id":"ckx2vb6vj0012vcueclueeiiz"},{"post_id":"ckx2vb6v7000jvcuedid2ddy6","category_id":"ckx2vb6vi000xvcuebgl2guja","_id":"ckx2vb6vk0018vcue59ul7nzx"},{"post_id":"ckx2vb6v9000nvcuecnjbb7j6","category_id":"ckx2vb6vi000xvcuebgl2guja","_id":"ckx2vb6vl001cvcueab8x7sa3"},{"post_id":"ckx2vb6vd000qvcueezw254zh","category_id":"ckx2vb6vk0017vcuee7tf26td","_id":"ckx2vb6vm001hvcueddqugmhv"},{"post_id":"ckx2vb6vg000vvcue66q96wcl","category_id":"ckx2vb6vm001evcuecksu7x6m","_id":"ckx2vb6vn001kvcue6zhs6bpw"},{"post_id":"ckx2vb6vh000wvcuefbe21qri","category_id":"ckx2vb6vm001evcuecksu7x6m","_id":"ckx2vb6vo001ovcuefn9k6rre"},{"post_id":"ckx2vb6wi001zvcue9qvy45i1","category_id":"ckx2vb6vi000xvcuebgl2guja","_id":"ckx2vb6wp0025vcue60ud7tkn"},{"post_id":"ckx2vb6wj0020vcue7f9sgck9","category_id":"ckx2vb6vi000xvcuebgl2guja","_id":"ckx2vb6wq0027vcuehu6a8pid"},{"post_id":"ckx2vb6wl0022vcue6flldowv","category_id":"ckx2vb6vi000xvcuebgl2guja","_id":"ckx2vb6wq0029vcueelc417dl"},{"post_id":"ckx2vb6wn0024vcue145jcdnu","category_id":"ckx2vb6vi000xvcuebgl2guja","_id":"ckx2vb6wr002bvcue15xx95kg"},{"post_id":"ckx2vb6x0002fvcue0as566wg","category_id":"ckx2vb6vi000xvcuebgl2guja","_id":"ckx2vb6x1002ivcue0ei72ohu"},{"post_id":"ckx2vb6x1002jvcuehtq9hsgh","category_id":"ckx2vb6vi000xvcuebgl2guja","_id":"ckx2vb6x2002mvcue5z884zr4"}],"PostTag":[{"post_id":"ckx2vb6um0003vcue55ld6yfr","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6vc000pvcue1yqf8ylr"},{"post_id":"ckx2vb6um0003vcue55ld6yfr","tag_id":"ckx2vb6v2000fvcuebct6bng0","_id":"ckx2vb6vf000svcue02vnakab"},{"post_id":"ckx2vb6uu0009vcue8gqq7r5g","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6vj0010vcuebznw11xo"},{"post_id":"ckx2vb6uu0009vcue8gqq7r5g","tag_id":"ckx2vb6v2000fvcuebct6bng0","_id":"ckx2vb6vj0011vcue60e90406"},{"post_id":"ckx2vb6uz000bvcueg9qrafrv","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6vk0015vcue6slxgfdc"},{"post_id":"ckx2vb6uz000bvcueg9qrafrv","tag_id":"ckx2vb6v2000fvcuebct6bng0","_id":"ckx2vb6vk0016vcue9dr93xq7"},{"post_id":"ckx2vb6v1000dvcuehove0kwk","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6vl001avcuebg6967nj"},{"post_id":"ckx2vb6v1000dvcuehove0kwk","tag_id":"ckx2vb6vj0013vcueai3789qv","_id":"ckx2vb6vl001bvcue0zee64j0"},{"post_id":"ckx2vb6v5000hvcuefp7mg157","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6vm001fvcue05cb9peg"},{"post_id":"ckx2vb6v5000hvcuefp7mg157","tag_id":"ckx2vb6vj0013vcueai3789qv","_id":"ckx2vb6vm001gvcue4z1ogpg1"},{"post_id":"ckx2vb6v7000jvcuedid2ddy6","tag_id":"ckx2vb6vl001dvcuehqos67tg","_id":"ckx2vb6vo001mvcue6lz6dedt"},{"post_id":"ckx2vb6v7000jvcuedid2ddy6","tag_id":"ckx2vb6vn001ivcuefx3wg9ku","_id":"ckx2vb6vo001nvcuea59t49on"},{"post_id":"ckx2vb6v9000nvcuecnjbb7j6","tag_id":"ckx2vb6vl001dvcuehqos67tg","_id":"ckx2vb6vp001qvcuehggxfdk4"},{"post_id":"ckx2vb6v9000nvcuecnjbb7j6","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6vp001rvcue42sndwfk"},{"post_id":"ckx2vb6vd000qvcueezw254zh","tag_id":"ckx2vb6vp001pvcue4sux5vx1","_id":"ckx2vb6vr001uvcueeudgh6mt"},{"post_id":"ckx2vb6vd000qvcueezw254zh","tag_id":"ckx2vb6vp001svcuea92g6c8f","_id":"ckx2vb6vr001vvcueea38cbon"},{"post_id":"ckx2vb6vg000vvcue66q96wcl","tag_id":"ckx2vb6vq001tvcue6v4q7p07","_id":"ckx2vb6vs001xvcue8lwbhqdc"},{"post_id":"ckx2vb6vh000wvcuefbe21qri","tag_id":"ckx2vb6vq001tvcue6v4q7p07","_id":"ckx2vb6vt001yvcuefb4tbn8j"},{"post_id":"ckx2vb6wi001zvcue9qvy45i1","tag_id":"ckx2vb6vl001dvcuehqos67tg","_id":"ckx2vb6wl0021vcuebx1jaofj"},{"post_id":"ckx2vb6wi001zvcue9qvy45i1","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6wn0023vcuef70w5stw"},{"post_id":"ckx2vb6wj0020vcue7f9sgck9","tag_id":"ckx2vb6vl001dvcuehqos67tg","_id":"ckx2vb6wq0026vcuehoy3hi1q"},{"post_id":"ckx2vb6wj0020vcue7f9sgck9","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6wq0028vcue9czqanlq"},{"post_id":"ckx2vb6wl0022vcue6flldowv","tag_id":"ckx2vb6vl001dvcuehqos67tg","_id":"ckx2vb6wr002avcue1row9rak"},{"post_id":"ckx2vb6wl0022vcue6flldowv","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6wr002cvcue7c16b0pv"},{"post_id":"ckx2vb6wn0024vcue145jcdnu","tag_id":"ckx2vb6vl001dvcuehqos67tg","_id":"ckx2vb6wr002dvcue5vtfhljd"},{"post_id":"ckx2vb6wn0024vcue145jcdnu","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6wr002evcue9mmqe4ly"},{"post_id":"ckx2vb6x0002fvcue0as566wg","tag_id":"ckx2vb6vl001dvcuehqos67tg","_id":"ckx2vb6x0002gvcueg5xab6xd"},{"post_id":"ckx2vb6x0002fvcue0as566wg","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6x1002hvcuegmlw7tvf"},{"post_id":"ckx2vb6x1002jvcuehtq9hsgh","tag_id":"ckx2vb6vl001dvcuehqos67tg","_id":"ckx2vb6x2002kvcue9hs64saw"},{"post_id":"ckx2vb6x1002jvcuehtq9hsgh","tag_id":"ckx2vb6us0007vcuefva9hk2r","_id":"ckx2vb6x2002lvcue5mj25lak"}],"Tag":[{"name":"后端开发","_id":"ckx2vb6us0007vcuefva9hk2r"},{"name":"Redis","_id":"ckx2vb6v2000fvcuebct6bng0"},{"name":"安全认证","_id":"ckx2vb6vj0013vcueai3789qv"},{"name":"数据库","_id":"ckx2vb6vl001dvcuehqos67tg"},{"name":"mongodb","_id":"ckx2vb6vn001ivcuefx3wg9ku"},{"name":"杂谈","_id":"ckx2vb6vp001pvcue4sux5vx1"},{"name":"开源","_id":"ckx2vb6vp001svcuea92g6c8f"},{"name":"环境配置","_id":"ckx2vb6vq001tvcue6v4q7p07"}]}}